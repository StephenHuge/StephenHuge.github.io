[{"title":"HashMap","date":"2020-07-31T12:17:00.000Z","path":"2020/07/31/HashMap/","content":"<h1 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h1><p>常见的数据存储结构有：数组和链表，其中存储的数据都为有序。</p>\n<ol>\n<li>数组</li>\n</ol>\n<p>优势：可以直接通过二分查找来找数据，时间复杂度$O(N)$，<strong>访问快</strong></p>\n<p>劣势：大小固定，需要添加元素且保持有序时，可能需要移动很多原来的元素，时间复杂度高为$O(N)$， <strong>插入慢</strong></p>\n<ol>\n<li>链表</li>\n</ol>\n<p>优势：插入时相对方便，时间复杂度为$O(N)$，但是不需要移动数据， <strong>插入相对快</strong></p>\n<p>劣势：查询某个元素时平均时间复杂度为 $O(N )$，<strong>访问慢</strong></p>\n<ol>\n<li>散列表HashMap</li>\n</ol>\n<p>集合了数据和链表的优势</p>\n<p>查询时间复杂度：$O(1)$</p>\n<p>插入时间复杂度：$O(1)$</p>\n<a id=\"more\"></a>\n<h1 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h1><h2 id=\"2-2-常量，变量和构造方法\"><a href=\"#2-2-常量，变量和构造方法\" class=\"headerlink\" title=\"2.2 常量，变量和构造方法\"></a>2.2 常量，变量和构造方法</h2><h3 id=\"a-常量\"><a href=\"#a-常量\" class=\"headerlink\" title=\"a. 常量\"></a>a. 常量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The default initial capacity - MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">   * 默认table大小，为16</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class=\"line\"><span class=\"comment\">   * by either of the constructors with arguments.</span></span><br><span class=\"line\"><span class=\"comment\">   * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class=\"line\"><span class=\"comment\">   * table最大长度，为1,073,741,824</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The load factor used when none specified in constructor.</span></span><br><span class=\"line\"><span class=\"comment\">   * 默认的负载因子</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The bin count threshold for using a tree rather than list for a</span></span><br><span class=\"line\"><span class=\"comment\">   * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class=\"line\"><span class=\"comment\">   * bin with at least this many nodes. The value must be greater</span></span><br><span class=\"line\"><span class=\"comment\">   * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class=\"line\"><span class=\"comment\">   * tree removal about conversion back to plain bins upon</span></span><br><span class=\"line\"><span class=\"comment\">   * shrinkage.</span></span><br><span class=\"line\"><span class=\"comment\">   * 树化阈值</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class=\"line\"><span class=\"comment\">   * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class=\"line\"><span class=\"comment\">   * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class=\"line\"><span class=\"comment\">   * 树降级为链表的阈值</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * The smallest table capacity for which bins may be treeified.</span></span><br><span class=\"line\"><span class=\"comment\">   * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class=\"line\"><span class=\"comment\">   * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class=\"line\"><span class=\"comment\">   * between resizing and treeification thresholds.</span></span><br><span class=\"line\"><span class=\"comment\">   * table达到这个长度时才可以树化</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"b-变量\"><a href=\"#b-变量\" class=\"headerlink\" title=\"b. 变量\"></a>b. 变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The table, initialized on first use, and resized as</span></span><br><span class=\"line\"><span class=\"comment\">    * necessary. When allocated, length is always a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">    * (We also tolerate length zero in some operations to allow</span></span><br><span class=\"line\"><span class=\"comment\">    * bootstrapping mechanics that are currently not needed.)</span></span><br><span class=\"line\"><span class=\"comment\">    * 哈希表，什么时候初始化？第一次put的时候</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class=\"line\"><span class=\"comment\">    * for keySet() and values().</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\">    * 哈希表中元素的个数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The number of times this HashMap has been structurally modified</span></span><br><span class=\"line\"><span class=\"comment\">    * Structural modifications are those that change the number of mappings in</span></span><br><span class=\"line\"><span class=\"comment\">    * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\">    * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class=\"line\"><span class=\"comment\">    * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class=\"line\"><span class=\"comment\">    * 哈希表结构变化次数：put已有的key不会造成modCount变化</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\">    * 触发resize()扩容的阈值，当元素个数大于这个值时，触发扩容</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\">   <span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\">   <span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\">   <span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\">    * 负载因子：threshold = capacity * loadFactor，其中capacity是哈希表数组的长度 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n<h3 id=\"c-构造方法\"><a href=\"#c-构造方法\" class=\"headerlink\" title=\"c. 构造方法\"></a>c. 构造方法</h3><p>一共4个构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty &#123;<span class=\"doctag\">@code</span> HashMap&#125; with the specified initial</span></span><br><span class=\"line\"><span class=\"comment\">     * capacity and load factor.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>  initialCapacity the initial capacity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>  loadFactor      the load factor</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class=\"line\"><span class=\"comment\">     *         or the load factor is nonpositive</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 判断传入的initialCapacity是否异常，其取值必须大于且小于MAXIMUM_CAPACITY（1 &lt;&lt; 30）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">            <span class=\"comment\">// load factor必须大于0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"comment\">// 此处有个针对threshold的处理方法</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty &#123;<span class=\"doctag\">@code</span> HashMap&#125; with the specified initial</span></span><br><span class=\"line\"><span class=\"comment\">     * capacity and the default load factor (0.75).</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>  initialCapacity the initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用了双参数的构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty &#123;<span class=\"doctag\">@code</span> HashMap&#125; with the default initial capacity</span></span><br><span class=\"line\"><span class=\"comment\">     * (16) and the default load factor (0.75).</span></span><br><span class=\"line\"><span class=\"comment\">     * 最常用的方法，只对load factor进行了设置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs a new &#123;<span class=\"doctag\">@code</span> HashMap&#125; with the same mappings as the</span></span><br><span class=\"line\"><span class=\"comment\">     * specified &#123;<span class=\"doctag\">@code</span> Map&#125;.  The &#123;<span class=\"doctag\">@code</span> HashMap&#125; is created with</span></span><br><span class=\"line\"><span class=\"comment\">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class=\"line\"><span class=\"comment\">     * hold the mappings in the specified &#123;<span class=\"doctag\">@code</span> Map&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">        putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><code>tableSizeFor(int)</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回大于等于传入的数且为2的幂的数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 减1后，n的非符号不为0的最高位一定小于或等于cap的</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 无符号右移1位</span></span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-get-方法\"><a href=\"#3-get-方法\" class=\"headerlink\" title=\"3. get()方法\"></a>3. get()方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the value to which the specified key is mapped,</span></span><br><span class=\"line\"><span class=\"comment\"> * or &#123;<span class=\"doctag\">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> k&#125; to a value &#123;<span class=\"doctag\">@code</span> v&#125; such that &#123;<span class=\"doctag\">@code</span> (key==null ? k==null :</span></span><br><span class=\"line\"><span class=\"comment\"> * key.equals(k))&#125;, then this method returns &#123;<span class=\"doctag\">@code</span> v&#125;; otherwise</span></span><br><span class=\"line\"><span class=\"comment\"> * it returns &#123;<span class=\"doctag\">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;A return value of &#123;<span class=\"doctag\">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class=\"line\"><span class=\"comment\"> * possible that the map explicitly maps the key to &#123;<span class=\"doctag\">@code</span> null&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * The &#123;<span class=\"doctag\">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class=\"line\"><span class=\"comment\"> * distinguish these two cases.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #put(Object, Object)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>getNode()</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// tab : 哈希表</span></span><br><span class=\"line\">        <span class=\"comment\">// first : 哈希表数组计算出的小标中的第一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">// e : </span></span><br><span class=\"line\">        <span class=\"comment\">// n : 哈希表的数组长度</span></span><br><span class=\"line\">        <span class=\"comment\">// k : </span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 哈希表不为空，数组长度不为0且对应的桶里有数据时进入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 桶中的第一个元素满足条件，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">            <span class=\"comment\">// 不是第一个元素，需要遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果是红黑树，从红黑树中拿</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"comment\">// 通过遍历循环获取其值</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-put-方法\"><a href=\"#4-put-方法\" class=\"headerlink\" title=\"4. put()方法\"></a>4. put()方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Associates the specified value with the specified key in this map.</span></span><br><span class=\"line\"><span class=\"comment\"> * If the map previously contained a mapping for the key, the old</span></span><br><span class=\"line\"><span class=\"comment\"> * value is replaced.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key key with which the specified value is to be associated</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value value to be associated with the specified key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class=\"line\"><span class=\"comment\"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class=\"line\"><span class=\"comment\"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class=\"line\"><span class=\"comment\"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 将键值对插入hashMap</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法调用了<code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key : key的哈希值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put : 要设置的值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don't change existing value : 如果为true，只有key未保存在HashMap中时才进行插入，否则不处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none : 返回之前key对应之前的value，如果不存在返回null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// tab : 哈希表的引用</span></span><br><span class=\"line\">    <span class=\"comment\">// p : node数组中的节点*</span></span><br><span class=\"line\">    <span class=\"comment\">// n : 哈希表中元素的个数</span></span><br><span class=\"line\">    <span class=\"comment\">// i : node数组的下标</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// table为空或者哈希表大小为0，此时对hashMap进行赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 计算得出数组下标，如果数组元素为空，则为其赋值一个新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// e : 临时Node节点</span></span><br><span class=\"line\">        <span class=\"comment\">// k : 要插入的key*</span></span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 如果key就是数组里的第一个元素，把p赋值给e</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p是一个树节点，证明数组下标内存储的数据结构是红黑树，插入红黑树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果节点的next节点为空，表示一直未找到和插入key相同的key，此时直接在next节点插入新节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// binCount从0开始，TREEIFY_THRESHOLD为8</span></span><br><span class=\"line\">                    <span class=\"comment\">// binCount为0时，实际插入的是第2个元素p.next，所以，binCount为7时，插入了第9个元素，此时需要树化</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 插入完跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 找到和要插入的key 相同的key，此时e持有这个节点的引用，直接跳出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 上面两个if均不满足，表名p.next!=null 且没找到和要插入的key相同的Node，将e赋给p，继续下一次循环</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果e不为空，表名前面的代码找到了旧的Node，进行value的赋值操作，此处操作完直接返回，没有对modCount进行操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// 如果onlyIfAbsent为false或者旧的value为空时，将新的value赋值进去</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 到此处表示对哈希表的结构进行了改变，modCount+1</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 如果添加了元素后的哈希表size大于扩容阈值，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-resize-方法\"><a href=\"#5-resize-方法\" class=\"headerlink\" title=\"5. resize()方法\"></a>5. resize()方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\">    * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\">    * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\">    * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">       <span class=\"comment\">// oldTab : 扩容前的数组</span></span><br><span class=\"line\">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">       <span class=\"comment\">// oldCap : 扩容前的数组长度</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">       <span class=\"comment\">// oldThr : 扩容前的扩容阈值</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">       <span class=\"comment\">// region 计算 newCap和newThr</span></span><br><span class=\"line\">       <span class=\"comment\">// newCap : 扩容后的数组长度，需要计算</span></span><br><span class=\"line\">       <span class=\"comment\">// newThr : 扩容后的扩容阈值，需要计算</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 旧数组长度大于0，表示已经初始化过了</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 如果旧的数组长度已经大于最大数组长度MAXIMUM_CAPACITY，此时不再扩容，将扩容阈值设置为int最大值，直接返回</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">               threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// newCap = oldCap &lt;&lt; 1表示新的数组大小为旧数组的2倍</span></span><br><span class=\"line\">           <span class=\"comment\">// 如果新数组的长度小于最大数组长度，且旧的数组长度大于等于默认初始长度16，扩容阈值也变为旧的2倍</span></span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">               newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 之前未初始化（put操作）过，且旧的扩容阈值大于0，有两种情况</span></span><br><span class=\"line\">       <span class=\"comment\">// new HashMap(int capacity, float loadFactor)</span></span><br><span class=\"line\">       <span class=\"comment\">// new HashMap(int capacity)</span></span><br><span class=\"line\">       <span class=\"comment\">// 此时threashold为第一次赋值的2的幂次方，所以直接赋值成为下一次的数组长度</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">           newCap = oldThr;</span><br><span class=\"line\">       <span class=\"comment\">// 之前未初始化（put操作）过，且旧的扩容阈值为0，有一种情况</span></span><br><span class=\"line\">       <span class=\"comment\">// new HashMap()</span></span><br><span class=\"line\">       <span class=\"comment\">// 此时新的数组长度为16，新的阈值长度为默认长度乘以默认负载因子 16 * 0.75 = 12</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">           newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 未设置新的扩容阈值时，根据新的数组长度和负载因子算出来</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                     (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// endregion</span></span><br><span class=\"line\">       <span class=\"comment\">// 算出来的扩容阈值赋值给threshold</span></span><br><span class=\"line\">       threshold = newThr;</span><br><span class=\"line\">       <span class=\"comment\">// 创建新的数组</span></span><br><span class=\"line\">       <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">       table = newTab;</span><br><span class=\"line\">       <span class=\"comment\">// 只有第一次创建时，旧的数组为空，此时直接返回</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 遍历旧数组的，重新插入数据</span></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// e : 临时元素，持有当前操作的Node</span></span><br><span class=\"line\">               Node&lt;K,V&gt; e;</span><br><span class=\"line\">               <span class=\"comment\">// 如果当前下标数组元素不为空</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// 旧数据被e持有，后续可直接对旧数组进行GC</span></span><br><span class=\"line\">                   oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                   <span class=\"comment\">// 此下标只有一个元素，直接计算出元素的下标，赋值到新数组</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                       newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                   <span class=\"comment\">// 如果是树节点，往红黑树插入</span></span><br><span class=\"line\">                   <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                       ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                   <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                       <span class=\"comment\">// 数组扩容后，长度多了一位，旧的hash值计算出来有两种情况</span></span><br><span class=\"line\">                       <span class=\"comment\">// 高位是0，此时和旧数组中的下标一致oldHash</span></span><br><span class=\"line\">                       <span class=\"comment\">// 高位是1，此时下标为 oldHash + oldCap</span></span><br><span class=\"line\">                       <span class=\"comment\">// 低位链表 loHead链表头，loTail链表尾部</span></span><br><span class=\"line\">                       Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                       <span class=\"comment\">// 高位链表</span></span><br><span class=\"line\">                       Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                       Node&lt;K,V&gt; next;</span><br><span class=\"line\">                       <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                           next = e.next;</span><br><span class=\"line\">                           <span class=\"comment\">// (e.hash &amp; oldCap) == 0表明新hash值是低位</span></span><br><span class=\"line\">                           <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                               <span class=\"comment\">// 第一次插入loTail为空，把loHead赋值为当前Node</span></span><br><span class=\"line\">                               <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                   loHead = e;</span><br><span class=\"line\">                               <span class=\"comment\">// 不是第一次插入，在loTail后面新插入即可</span></span><br><span class=\"line\">                               <span class=\"keyword\">else</span></span><br><span class=\"line\">                                   loTail.next = e;</span><br><span class=\"line\">                               <span class=\"comment\">// loTail一直指向最新插入的值</span></span><br><span class=\"line\">                               loTail = e;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                           <span class=\"comment\">// 高位插入，具体逻辑和低位类似</span></span><br><span class=\"line\">                           <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                               <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                   hiHead = e;</span><br><span class=\"line\">                               <span class=\"keyword\">else</span></span><br><span class=\"line\">                                   hiTail.next = e;</span><br><span class=\"line\">                               hiTail = e;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                           <span class=\"comment\">// 去掉新插入后低位链表尾部的引用</span></span><br><span class=\"line\">                           loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                           <span class=\"comment\">// 把低位链表头赋值到数组里，下标是当前下标</span></span><br><span class=\"line\">                           newTab[j] = loHead;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                           <span class=\"comment\">// 去掉新插入后低位链表尾部的引用</span></span><br><span class=\"line\">                           hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                           <span class=\"comment\">// 把低位链表头赋值到数组里，下标是当前下标 + oldCap</span></span><br><span class=\"line\">                           newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2020/07/31/HashMap/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"链表","slug":"链表","permalink":"https://stevehuge.gitee.io/blog/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"MacBook使用","date":"2020-07-27T13:13:50.000Z","path":"2020/07/27/MacBook使用/","content":"<h1 id=\"Brew\"><a href=\"#Brew\" class=\"headerlink\" title=\"Brew\"></a>Brew</h1><h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。<br><a id=\"more\"></a></p>\n<p>注意事项</p>\n<ul>\n<li>Homebrew会将软件包安装到独立目录,一般为<code>/usr/local/Cellar</code>目录.</li>\n<li>然后将文件软连接至执行路径,一般为<code>/usr/local/bin</code>目录.</li>\n</ul>\n<h2 id=\"2-常用命令\"><a href=\"#2-常用命令\" class=\"headerlink\" title=\"2. 常用命令\"></a>2. 常用命令</h2><ul>\n<li><code>brew install [包名]</code></li>\n<li><code>brew update</code></li>\n<li><code>brew update -verbose</code></li>\n<li><code>brew cleanup</code>:清理旧有软件包.</li>\n<li><code>brew doctor</code>:诊断Homebrew的问题.</li>\n<li><code>brew update-reset</code></li>\n</ul>\n<h2 id=\"3-brew-install-xx卡死问题\"><a href=\"#3-brew-install-xx卡死问题\" class=\"headerlink\" title=\"3. brew install xx卡死问题\"></a>3. <code>brew install xx</code>卡死问题</h2><p>一般都会卡死在<code>Updating Homebrew..</code>界面，原因是brew会使用github作为源，国内访问速度很有限。<br>解决的方法：</p>\n<ol>\n<li>按下<code>Control-c</code>，会停止更新，直接下载。这种方法可以临时使用，但是治标不治本。</li>\n<li>替换源</li>\n</ol>\n<p>使用 <code>brew install -verbose</code>查看brew安装时使用的源<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fetching /usr/<span class=\"built_in\">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core...</span><br><span class=\"line\">Fetching /usr/<span class=\"built_in\">local</span>/Homebrew...</span><br><span class=\"line\">Fetching /usr/<span class=\"built_in\">local</span>/Homebrew/Library/Taps/homebrew/homebrew-cask...</span><br></pre></td></tr></table></figure><br>可以看到，使用了<code>homebrew</code>, <code>homebrew-cask</code>,<code>homebrew-core</code>3个源，因此我们对这三个源进行替换，推荐使用<a href=\"http://mirrors.ustc.edu.cn/\" target=\"_blank\" rel=\"noopener\">中科大镜像源</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"string\">\"<span class=\"variable\">$(brew --repo)</span>\"</span> <span class=\"comment\"># `$(brew --repo)`是用来自动指向Homebrew的目录的</span></span><br><span class=\"line\">git remote <span class=\"built_in\">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"string\">\"<span class=\"variable\">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core\"</span></span><br><span class=\"line\">git remote <span class=\"built_in\">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"string\">\"<span class=\"variable\">$(brew --repo)</span>\"</span>/Library/Taps/homebrew/homebrew-cask</span><br><span class=\"line\">git remote <span class=\"built_in\">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure>\n<p>参考<a href=\"http://mirrors.ustc.edu.cn/help/brew.git.html\" target=\"_blank\" rel=\"noopener\">Homebrew源使用帮助</a>.<br>参考<a href=\"http://mirrors.ustc.edu.cn/help/homebrew-core.git.html\" target=\"_blank\" rel=\"noopener\">Homebrew Core源使用帮助</a>.<br>参考<a href=\"http://mirrors.ustc.edu.cn/help/homebrew-cask.git.html\" target=\"_blank\" rel=\"noopener\">Homebrew Cask源使用帮助</a>.</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>[1] <a href=\"https://www.cnblogs.com/tp0829/p/Homebrew.html\" target=\"_blank\" rel=\"noopener\">[Linux实践] macOS平台Homebrew更新brew update卡死,完美解决</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2020/07/27/MacBook%E4%BD%BF%E7%94%A8/","tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"MacBook","slug":"MacBook","permalink":"https://stevehuge.gitee.io/blog/tags/MacBook/"}]},{"title":"Redis数据类型","date":"2020-07-27T13:13:41.000Z","path":"2020/07/27/Redis数据类型/","content":"<h1 id=\"1-什么是Redis\"><a href=\"#1-什么是Redis\" class=\"headerlink\" title=\"1. 什么是Redis\"></a>1. 什么是Redis</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href=\"http://www.redis.cn/topics/data-types-intro.html#strings\" target=\"_blank\" rel=\"noopener\">字符串（strings）</a>， <a href=\"http://www.redis.cn/topics/data-types-intro.html#hashes\" target=\"_blank\" rel=\"noopener\">散列（hashes）</a>， <a href=\"http://www.redis.cn/topics/data-types-intro.html#lists\" target=\"_blank\" rel=\"noopener\">列表（lists）</a>， <a href=\"http://www.redis.cn/topics/data-types-intro.html#sets\" target=\"_blank\" rel=\"noopener\">集合（sets）</a>， <a href=\"http://www.redis.cn/topics/data-types-intro.html#sorted-sets\" target=\"_blank\" rel=\"noopener\">有序集合（sorted sets）</a> 与范围查询， <a href=\"http://www.redis.cn/topics/data-types-intro.html#bitmaps\" target=\"_blank\" rel=\"noopener\">bitmaps</a>， <a href=\"http://www.redis.cn/topics/data-types-intro.html#hyperloglogs\" target=\"_blank\" rel=\"noopener\">hyperloglogs</a> 和 <a href=\"http://www.redis.cn/commands/geoadd.html\" target=\"_blank\" rel=\"noopener\">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href=\"http://www.redis.cn/topics/replication.html\" target=\"_blank\" rel=\"noopener\">复制（replication）</a>，<a href=\"http://www.redis.cn/commands/eval.html\" target=\"_blank\" rel=\"noopener\">LUA脚本（Lua scripting）</a>， <a href=\"http://www.redis.cn/topics/lru-cache.html\" target=\"_blank\" rel=\"noopener\">LRU驱动事件（LRU eviction）</a>，<a href=\"http://www.redis.cn/topics/transactions.html\" target=\"_blank\" rel=\"noopener\">事务（transactions）</a> 和不同级别的 <a href=\"http://www.redis.cn/topics/persistence.html\" target=\"_blank\" rel=\"noopener\">磁盘持久化（persistence）</a>， 并通过 <a href=\"http://www.redis.cn/topics/sentinel.html\" target=\"_blank\" rel=\"noopener\">Redis哨兵（Sentinel）</a>和自动 <a href=\"http://www.redis.cn/topics/cluster-tutorial.html\" target=\"_blank\" rel=\"noopener\">分区（Cluster）</a>提供高可用性（high availability）。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-Redis数据类型\"><a href=\"#2-Redis数据类型\" class=\"headerlink\" title=\"2. Redis数据类型\"></a>2. Redis数据类型</h1><h2 id=\"z-key的一些操作\"><a href=\"#z-key的一些操作\" class=\"headerlink\" title=\"z. key的一些操作\"></a>z. key的一些操作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置键值</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> key val </span><br><span class=\"line\"><span class=\"comment\"># 获取键对应的值</span></span><br><span class=\"line\">get key</span><br><span class=\"line\"><span class=\"comment\"># 删除键值对</span></span><br><span class=\"line\">del key</span><br><span class=\"line\"><span class=\"comment\"># 设置key的超时时间，单位是秒</span></span><br><span class=\"line\">expire key seconds</span><br><span class=\"line\"><span class=\"comment\"># 查看键对应的超时时间，返回单位是秒</span></span><br><span class=\"line\">ttl key</span><br><span class=\"line\"><span class=\"comment\"># 设置key的超时时间，单位是毫秒</span></span><br><span class=\"line\">pexpire key milliseconds</span><br><span class=\"line\"><span class=\"comment\"># 查看键对应的超时时间，返回单位是毫秒</span></span><br><span class=\"line\">pttl key</span><br><span class=\"line\"><span class=\"comment\"># 判断key是否存在</span></span><br><span class=\"line\">exists key</span><br><span class=\"line\"><span class=\"comment\"># 获取所有key</span></span><br><span class=\"line\">keys *</span><br><span class=\"line\"><span class=\"comment\"># 获取满足特定模式的key</span></span><br><span class=\"line\">keys pattern</span><br><span class=\"line\"><span class=\"comment\"># 换DB, Redis有16个Database，下标为0-15，默认处于第0个</span></span><br><span class=\"line\">select index</span><br><span class=\"line\"><span class=\"comment\"># 将key移动到指定DB</span></span><br><span class=\"line\">move key index</span><br><span class=\"line\"><span class=\"comment\"># 获取value的类型</span></span><br><span class=\"line\"><span class=\"built_in\">type</span> key</span><br></pre></td></tr></table></figure>\n<h2 id=\"a-String\"><a href=\"#a-String\" class=\"headerlink\" title=\"a. String\"></a>a. String</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置键值</span></span><br><span class=\"line\">SET key val </span><br><span class=\"line\"><span class=\"comment\"># 获取键对应的值</span></span><br><span class=\"line\">GET key</span><br><span class=\"line\"><span class=\"comment\"># 获取key对应的旧值，设置key的新值，如果旧值不存在，会返回nil</span></span><br><span class=\"line\">GETSET key val</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取key指定偏移量上的位（bit）</span></span><br><span class=\"line\">GETBIT key offset</span><br><span class=\"line\"><span class=\"comment\"># 设置key指定偏移量上的位（bit）</span></span><br><span class=\"line\">SETBIT key offset val</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 设置key-val，并且设置其过期时间（单位为秒）</span></span><br><span class=\"line\">SETEX key seconds val</span><br><span class=\"line\"><span class=\"comment\"># 设置key-val，只有key不存在时才能设置成功</span></span><br><span class=\"line\">SETNX key val</span><br><span class=\"line\"><span class=\"comment\"># 设置key-val，并且设置其过期时间（单位为毫秒）  </span></span><br><span class=\"line\">PSETEX key milliseconds val</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取多个key对应的值</span></span><br><span class=\"line\">MGET key1 [key2] ...</span><br><span class=\"line\"><span class=\"comment\"># 设置多个key-val对</span></span><br><span class=\"line\">MSET key1 val1 [key2 val2]...</span><br><span class=\"line\"><span class=\"comment\"># 设置多个key-val，仅在所有被设置的key都不存在时设置成功，只要里面有一个key存在，返回0表示设置失败，设置成功时返回1</span></span><br><span class=\"line\">MSETNX key1 val1 [key2 val2]...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取范围内的字符串（和Java不同，字符串的截取范围既包括startIndex，也包括endIndex）</span></span><br><span class=\"line\">GETRANGE key startIndex endIndex</span><br><span class=\"line\"><span class=\"comment\"># 使用val覆盖从偏移量offset开始的字符</span></span><br><span class=\"line\">SETRANGE key offset val</span><br><span class=\"line\"><span class=\"comment\"># 在key后追加val的值，如果key不存在，会设置key-val，此时APPEND命令相当于SET</span></span><br><span class=\"line\">APPEND key val</span><br><span class=\"line\"><span class=\"comment\"># 获取key对应的字符串长度，key不存在时返回0</span></span><br><span class=\"line\">STRLEN key </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># INCR 命令将 key 中储存的数字值增一，如果key不存在，按照初始值为0处理；如果key对应的值不是数字，会返回一个错误；</span></span><br><span class=\"line\"><span class=\"comment\"># 本操作的值限制在64bit内；INCR命令放在字符串中的原因是int值在Redis中以字符串的形式保存</span></span><br><span class=\"line\">INCR key</span><br><span class=\"line\"><span class=\"comment\"># 将key中存储的的数字加一个指定的数字increment</span></span><br><span class=\"line\">INCRBY key increment</span><br><span class=\"line\"><span class=\"comment\"># 将key中存储的数字值减一，和INCR功能类似</span></span><br><span class=\"line\">DECR key</span><br><span class=\"line\"><span class=\"comment\"># 将key中存储的的数字减一个指定的数字decrement</span></span><br><span class=\"line\">DECRBY key decrement</span><br></pre></td></tr></table></figure>\n<h2 id=\"b-List\"><a href=\"#b-List\" class=\"headerlink\" title=\"b. List\"></a>b. List</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 移出并获取列表的第一个元素</span></span><br><span class=\"line\">LPOP key</span><br><span class=\"line\"><span class=\"comment\"># 将一个或多个值插入到列表头部</span></span><br><span class=\"line\">LPUSH key value1 [value2]</span><br><span class=\"line\"><span class=\"comment\"># 将一个值插入到已存在的列表头部</span></span><br><span class=\"line\">LPUSHX key value</span><br><span class=\"line\"><span class=\"comment\"># 移除列表的最后一个元素，返回值为移除的元素</span></span><br><span class=\"line\">RPOP key</span><br><span class=\"line\"><span class=\"comment\"># 在列表中添加一个或多个值</span></span><br><span class=\"line\">RPUSH key value1 [value2]</span><br><span class=\"line\"><span class=\"comment\"># 为已存在的列表添加值</span></span><br><span class=\"line\">RPUSHX key value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过索引获取列表中的元素</span></span><br><span class=\"line\">LINDEX key index</span><br><span class=\"line\"><span class=\"comment\"># 通过索引设置列表元素的值</span></span><br><span class=\"line\">LSET key index value</span><br><span class=\"line\"><span class=\"comment\"># 获取列表长度</span></span><br><span class=\"line\">LLEN key</span><br><span class=\"line\"><span class=\"comment\"># 获取列表指定范围内的元素</span></span><br><span class=\"line\">LRANGE key start stop</span><br><span class=\"line\"><span class=\"comment\"># 移除列表元素</span></span><br><span class=\"line\">LREM key count value</span><br><span class=\"line\"><span class=\"comment\"># 通过索引获取列表中的元素</span></span><br><span class=\"line\">LINDEX key index</span><br><span class=\"line\"><span class=\"comment\"># 在列表的元素前或者后插入元素</span></span><br><span class=\"line\">LINSERT key BEFORE|AFTER pivot value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</span></span><br><span class=\"line\">LTRIM key start stop</span><br><span class=\"line\"><span class=\"comment\"># 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class=\"line\">BLPOP key1 [key2 ] timeout</span><br><span class=\"line\"><span class=\"comment\"># 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class=\"line\">BRPOP key1 [key2 ] timeout</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-Hash\"><a href=\"#c-Hash\" class=\"headerlink\" title=\"c. Hash\"></a>c. Hash</h2><p>Hash采用的数据结构是哈希表，每个hash中最多可以存2^31-1个键值对，约40多亿个</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将哈希表 key 中的字段 field 的值设为 value </span></span><br><span class=\"line\">HSET key field val</span><br><span class=\"line\"><span class=\"comment\"># 获取存储在哈希表中指定字段的值</span></span><br><span class=\"line\">HGET key field</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个或多个哈希表字段</span></span><br><span class=\"line\">HDEL key field1 [field2]</span><br><span class=\"line\"><span class=\"comment\"># 查看哈希表 key 中，指定的字段是否存在</span></span><br><span class=\"line\"></span><br><span class=\"line\">HEXISTS key field</span><br><span class=\"line\"><span class=\"comment\"># 获取所有哈希表中的字段</span></span><br><span class=\"line\">HKEYS key</span><br><span class=\"line\"><span class=\"comment\"># 获取哈希表中所有值</span></span><br><span class=\"line\">HVALS key</span><br><span class=\"line\"><span class=\"comment\"># 获取哈希表中字段的数量</span></span><br><span class=\"line\">HLEN key</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class=\"line\">HGETALL key</span><br><span class=\"line\"><span class=\"comment\"># 同时将多个 field-value (域-值)对设置到哈希表 key 中</span></span><br><span class=\"line\">HMSET key field1 val1 [field2, val2]...</span><br><span class=\"line\"><span class=\"comment\"># 获取所有给定字段的值</span></span><br><span class=\"line\">HMGET key field1 [field2]...</span><br></pre></td></tr></table></figure>\n<h2 id=\"d-Set\"><a href=\"#d-Set\" class=\"headerlink\" title=\"d. Set\"></a>d. Set</h2><h2 id=\"e-ZSet\"><a href=\"#e-ZSet\" class=\"headerlink\" title=\"e. ZSet\"></a>e. ZSet</h2><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1] <a href=\"http://www.redis.cn/\" target=\"_blank\" rel=\"noopener\"><em>redis</em>中文官方网站</a></p>\n<p>[2] </p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2020/07/27/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":[{"name":"Redis","slug":"Redis","permalink":"https://stevehuge.gitee.io/blog/tags/Redis/"},{"name":"分布式","slug":"分布式","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"缓存","slug":"缓存","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"Hello World","date":"2020-06-30T13:43:16.739Z","path":"2020/06/30/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2020/06/30/hello-world/","tags":[]},{"title":"LaTeX简介及其在Mardown中的用法","date":"2017-11-04T14:21:11.000Z","path":"2017/11/04/LaTeX简介及其在Mardown中的用法/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Tools/LaTeX/top.jpg?raw=true\" alt=\"\"></p>\n<h1 id=\"1-LaTeX-是什么？\"><a href=\"#1-LaTeX-是什么？\" class=\"headerlink\" title=\"1. $\\LaTeX$是什么？\"></a>1. $\\LaTeX$是什么？</h1><p>在介绍$\\LaTeX$之前，我们得知道什么是$\\TeX$。</p>\n<h2 id=\"TeX\"><a href=\"#TeX\" class=\"headerlink\" title=\"$\\TeX$\"></a>$\\TeX$</h2><p>$\\TeX$（希腊语：/tɛx/，音译“泰赫”，文本模式下写作TeX），是一个由美国计算机教授高德纳（Donald Ervin Knuth）编写的功能强大的排版软件。它在学术界十分流行，特别是数学、物理学和计算机科学界。$\\TeX$被普遍认为是一个优秀的排版工具，特别是在处理复杂的数学公式时。利用诸如是$\\LaTeX$等终端软件，$\\TeX$就能够排版出精美的文本以帮助人们辨认和查找。</p>\n<p>高德纳（Donald Knuth,1938/01/10 -）最早开始自行编写 $\\TeX$ 的原因，是因为当时的排版技术十分粗糙，已经影响到他的巨著《计算机程序设计艺术》的印刷质量。他以典型的黑客思维模式，决定自行编写一个排版软件：$\\TeX$。他原本以为他只需要半年时间，在1978年下半年就能完成，但最终他用了超过十年时间，直到1989年$\\TeX$才最终停止修改。</p>\n<a id=\"more\"></a>\n<h2 id=\"LaTeX\"><a href=\"#LaTeX\" class=\"headerlink\" title=\"$\\LaTeX$\"></a>$\\LaTeX$</h2><p>$\\LaTeX$（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/），文字形式写作LaTeX，是一种基于$\\TeX$的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由$\\TeX$所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学、化学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。<br>$\\LaTeX$使用$\\TeX$作为它的格式化引擎，当前的版本是$\\LaTeX2_ε$。</p>\n<p>$\\LaTeX$ 本质上是用编程语言写成的一个“$\\TeX$ 宏包”，它扩展了 $\\TeX$ 的功能，使我们很方便的逻辑的进行创作而不是专心于字体，缩进这些烦人的东西。</p>\n<h1 id=\"2-LaTeX-能干什么？\"><a href=\"#2-LaTeX-能干什么？\" class=\"headerlink\" title=\"2. $\\LaTeX$能干什么？\"></a>2. $\\LaTeX$能干什么？</h1><p>$\\LaTeX$能较为友好的在网页或者文档中显示出规范整洁的各类公式和符号，例如</p>\n<script type=\"math/tex; mode=display\">\n\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}</script><p>$\\log_3 G$， $\\Omega (N^2)$ <script type=\"math/tex\">x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</script></p>\n<p>这些公式都是通过$\\LaTeX$实现的，对应的$\\LaTeX$语句如下：</p>\n<p><code>$$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$$</code></p>\n<p><code>$\\log_3 G$</code></p>\n<p><code>$\\Omega (N^2)$</code></p>\n<p><code>$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</code></p>\n<p>可以发现，有些公式和正常文字一样，有些却是在页面正中间。这是行内公式和行间公式的区别，对应到语法上就是行内公式使用<code>$formula$</code>，而行间公式使用<code>$$formula$$</code>， <code>formula</code>代表公式的内容。</p>\n<p>$\\LaTeX$的功能远不止这么简单，很多高级数学公式例如求和，求积以及一些复杂的物理公式都可以用其表示。</p>\n<h1 id=\"3-LaTeX-在Markdown中的用法\"><a href=\"#3-LaTeX-在Markdown中的用法\" class=\"headerlink\" title=\"3. $\\LaTeX$在Markdown中的用法\"></a>3. $\\LaTeX$在Markdown中的用法</h1><p>先说$\\LaTeX$的简单用法：</p>\n<ol>\n<li>在数学公式中，经常用到 <strong>上标和下标</strong>，在LaTeX语法中对应<code>^</code>和<code>-</code>。例如<code>x_i^2</code> : $x_i^2$, <code>\\log_2 N</code> : $\\log_2 N$。</li>\n<li><strong>分组</strong>，简单来说就是当遇到下标或者上标不是单字符时会用到，例如 $x<em>{a1}^2$, 用式子<code>x_a1^2</code>会得出错误的公式$x_a1^2$。由于这时<code>a</code>和<code>1</code>属于同一组，所以需要声明它们是一起的。$\\LaTeX$中使用大括号<code>{}</code>将同一组的符号括到一起。刚才的式子正确表示是<code>x</em>{a1}^2&lt;/code&gt;。</li>\n<li><strong>括号</strong>，如果式子中本来就有括号<code>()[]{}</code>，那么使用时<code>()[]</code>正常使用即可，而<code>{}</code>在括号之前需要加转义符<code>\\</code>。例如$(2 + 3)[4 + 4]{5 + 6}$ : <code>(2 + 3)[4 + 4]\\{5 + 6\\}</code>。</li>\n<li><strong>分数</strong>，分数通过<code>\\frac{}{}</code>实现。例如 $\\frac{3}{5}$ : <code>\\frac{3}{5}</code>。稍微复杂的分数也能表示</li>\n</ol>\n<p><script type=\"math/tex\">\\frac{\\log_2 N + N^3}{\\ln N - 2N^2}</script> 式子是<code>\\frac{\\log_2 N + N^3}{\\ln N - 2N^2}</code>。</p>\n<p>在Markdown中可以使用<code>$formula$</code>或<code>$$formula$$</code>插入公式，也可以使用<code>\\\\(formula\\\\)</code>插入，但是由于Hexo使用的markdown解析引擎的问题，后一种时有出错，推荐使用第一种方式。</p>\n<h1 id=\"4-附录\"><a href=\"#4-附录\" class=\"headerlink\" title=\"4. 附录\"></a>4. 附录</h1><p> <strong>常见函数</strong>表达方法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数名称</th>\n<th style=\"text-align:center\">函数符号</th>\n<th style=\"text-align:center\">表达方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">根号</td>\n<td style=\"text-align:center\">$\\sqrt3$</td>\n<td style=\"text-align:center\"><code>\\sqrt3</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">求和</td>\n<td style=\"text-align:center\">$\\sum_{i=0}^N i$</td>\n<td style=\"text-align:center\"><code>\\sum_{i=0}^N i</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">求积</td>\n<td style=\"text-align:center\">$\\prod_{0}^5 a$</td>\n<td style=\"text-align:center\"><code>\\prod_{0}^5 a</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">积分</td>\n<td style=\"text-align:center\">$\\int_{0}^\\infty x^3$</td>\n<td style=\"text-align:center\"><code>\\int_{0}^\\infty x^3</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">多次开方</td>\n<td style=\"text-align:center\">$\\sqrt[3]{\\frac xy}$</td>\n<td style=\"text-align:center\"><code>\\sqrt[3]{\\frac xy}</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">三角函数</td>\n<td style=\"text-align:center\">$\\sin$, $\\cos$, $\\tan$</td>\n<td style=\"text-align:center\"><code>\\sin</code>, <code>\\cos</code>, <code>\\tan</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">极限</td>\n<td style=\"text-align:center\">$\\lim_{x\\to0}$</td>\n<td style=\"text-align:center\"><code>\\lim_{x\\to0}</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">对数函数</td>\n<td style=\"text-align:center\">$\\log_5 x$, $\\ln y$</td>\n<td style=\"text-align:center\"><code>\\log_5 x</code>, <code>\\ln y</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p> <strong>常见符号</strong>表示方法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号名称</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">表达方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">希腊字母</td>\n<td style=\"text-align:center\">$ \\alpha$, $\\beta$, …, $\\omega$</td>\n<td style=\"text-align:center\">\\alpha, \\beta, …, \\omega</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">希腊字母大写</td>\n<td style=\"text-align:center\">$\\Gamma$, $\\Delta$, …, $\\Omega$</td>\n<td style=\"text-align:center\">\\Gamma, \\Delta, …, \\Omega</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">比较符</td>\n<td style=\"text-align:center\">$\\lt$ $\\gt$ $\\le$ $\\ge$ $\\neq$</td>\n<td style=\"text-align:center\">\\lt \\gt \\le \\ge \\neq</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">运算符</td>\n<td style=\"text-align:center\">$\\times$ $\\div$ $\\pm$ $\\mp$</td>\n<td style=\"text-align:center\">\\times \\div \\pm \\mp</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常见数学符号1</td>\n<td style=\"text-align:center\">$\\cup$ $\\cap$ $\\setminus$ $\\subset$ $\\subseteq$ $\\subsetneq$ $\\supset$ $\\in$ $\\notin$ $\\emptyset$ $\\varnothing$</td>\n<td style=\"text-align:center\">\\cup \\cap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常见数学符号2</td>\n<td style=\"text-align:center\">$\\land$ $\\lor$ $\\lnot$ $\\forall$ $\\exists$ $\\top$ $\\bot$ $\\vdash$ $\\vDash$</td>\n<td style=\"text-align:center\">\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">箭头</td>\n<td style=\"text-align:center\">$\\to$ $\\rightarrow$ $\\leftarrow$ $\\Rightarrow$ $\\Leftarrow$ $\\mapsto$</td>\n<td style=\"text-align:center\">\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在<a href=\"http://docs.mathjax.org/en/latest/tex.html#supported-latex-commands\" target=\"_blank\" rel=\"noopener\"> list of currently supported LATEXLATEX commands</a>中有更多$\\LaTeX$ 支持的语法。</p>\n<h1 id=\"5-遇到的问题\"><a href=\"#5-遇到的问题\" class=\"headerlink\" title=\"5. 遇到的问题\"></a>5. 遇到的问题</h1><p>刚开始使用的时候，经常发现页面中的公式解析出错，例如<code>_</code>在Hexo中会生成<em>斜体的字符</em>，在$\\LaTeX$中生成的$是_{下标}$。这就导致了矛盾。<br>可行的解决方法有两个：</p>\n<ul>\n<li>更换Hexo的markdown引擎。Hexo自带的引擎是 <code>hexo-renderer-marked</code>，可以换成功能更强大的Pandoc。   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save   &#x2F;&#x2F; 卸载旧的引擎</span><br><span class=\"line\">npm install hexo-renderer-pandoc --save     &#x2F;&#x2F; 安装pandoc</span><br></pre></td></tr></table></figure></li>\n<li>手动修改Hexo渲染源码</li>\n</ul>\n<p>修改hexo的渲染源码: 打开<code>nodes_modules/marked/lib/marked.js</code>:<br>第一步: 去掉\\的额外转义。 先备份一下，然后修改第449行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: &#x2F;^\\\\([\\\\&#96;*&#123;&#125;\\[\\]()# +\\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure><br>改为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: &#x2F;^\\\\([&#96;*&#123;&#125;\\[\\]()# +\\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure><br>这样就会去掉\\的转义了。<br>第二步:将<code>em</code>标签对应的符号中，去掉<code>_</code>。第459行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: &#x2F;^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;,</span><br></pre></td></tr></table></figure><br>修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em:&#x2F;^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;,</span><br></pre></td></tr></table></figure><br>因为markdown中有<code>*</code>可以表示斜体，<code>_</code>就去掉了,这样问题就解决了。</p>\n<p>这部分参考天空的城的<a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/#\" target=\"_blank\" rel=\"noopener\">Hexo下mathjax的转义问题</a>。</p>\n<h1 id=\"参考网站\"><a href=\"#参考网站\" class=\"headerlink\" title=\"参考网站\"></a>参考网站</h1><p>[1] <a href=\"https://www.mathjax.org/\" target=\"_blank\" rel=\"noopener\">mathjax官网</a><br>[2] <a href=\"https://zh.wikipedia.org/wiki/TeX\" target=\"_blank\" rel=\"noopener\">TeX维基百科</a><br>[3] <a href=\"https://zh.wikipedia.org/wiki/LaTeX\" target=\"_blank\" rel=\"noopener\">LaTeX维基百科</a><br>[3] <a href=\"https://github.com/hexojs/hexo/issues/524\" target=\"_blank\" rel=\"noopener\">Github上的issue</a><br>[4] <a href=\"https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax basic tutorial and quick reference</a><br>[5] <a href=\"https://www.zhihu.com/question/31298277/answer/275151599\" target=\"_blank\" rel=\"noopener\">知乎上的公式是怎么打出来的？</a><br>[6] <a href=\"https://segmentfault.com/q/1010000003987383\" target=\"_blank\" rel=\"noopener\">hexo 如何解决markdown下划线要加反斜杠，以及如何使用其他markdown的渲染引擎？</a><br>[7] <a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/#\" target=\"_blank\" rel=\"noopener\">Hexo下mathjax的转义问题</a><br>[8] <a href=\"http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/\" target=\"_blank\" rel=\"noopener\">如何处理Hexo和MathJax的兼容问题</a><br>[9] <a href=\"https://www.jianshu.com/p/68e6f82d88b7\" target=\"_blank\" rel=\"noopener\">使用LaTex添加公式到Hexo博客里</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/11/04/LaTeX%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%9C%A8Mardown%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/","tags":[{"name":"工具","slug":"工具","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://stevehuge.gitee.io/blog/tags/LaTeX/"},{"name":"markdown","slug":"markdown","permalink":"https://stevehuge.gitee.io/blog/tags/markdown/"}]},{"title":"Java中的Comparable接口和Comparator接口","date":"2017-10-19T14:00:53.000Z","path":"2017/10/19/Java中的Comparable接口和Comparator接口/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/JDK%E6%BA%90%E7%A0%81/Comparable&amp;Comparator/top.jpg?raw=true\" alt=\"\"></p>\n<p>最近Algorithms 4 课上提到了排序。趁着这个机会，梳理一下。<br><a id=\"more\"></a></p>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><p><code>Comparable&lt;T&gt;</code>接口和<code>Comparator&lt;T&gt;</code>接口都是JDK中提供的和比较相关的接口。使用它们可以对<strong>对象进行比较大小，排序</strong>等操作。这算是之后排序的先导知识吧。<br><code>Comparable</code>， 字面意思是“可以比较的”，所以实现它的类的多个实例应该可以相互比较“大小”或者“高低”等等。<br><code>Comparator</code>， 字面意思是“比较仪，比较器”， 它应该是专门用来比较用的“工具”。</p>\n<h1 id=\"2-Comparable\"><a href=\"#2-Comparable\" class=\"headerlink\" title=\"2. Comparable\"></a>2. Comparable</h1><p><code>Comparable&lt;T&gt;</code>接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(T o)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先看看JDK中怎么说的：</p>\n<blockquote>\n<p> This interface imposes a total ordering on the objects of each class that implements it.  This ordering is referred to as the class’s <i>natural ordering</i>, and the class’s <tt>compareTo</tt> method is referred to as its <i>natural comparison method</i>.<p></p>\n</blockquote>\n<p>大意是: 任何实现这个接口的类，其多个实例能以固定的次序进行排列。次序具体由接口中的方法<code>compareTo</code>方法决定。  </p>\n<blockquote>\n<p>Lists (and arrays) of objects that implement this interface can be sorted automatically by {@link Collections#sort(List) Collections.sort} (and {@link Arrays#sort(Object[]) Arrays.sort}).  </p>\n</blockquote>\n<p>如果某个类实现了这个接口，则它的<code>List</code>或数组都能使用<code>Collections.sort()</code>或<code>Arrays.sort()</code>进行排序。<br>常见的类如<code>Integer</code>, <code>Double</code>, <code>String</code>都实现了此类。一会儿会结合源码进行分析。</p>\n<h2 id=\"2-1-Integer类中Comparable接口的实现\"><a href=\"#2-1-Integer类中Comparable接口的实现\" class=\"headerlink\" title=\"2.1 Integer类中Comparable接口的实现\"></a>2.1 Integer类中Comparable接口的实现</h2><p>我们先来看<code>Integer</code>中的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Integer anotherInteger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compare(<span class=\"keyword\">this</span>.value, anotherInteger.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (x &lt; y) ? -<span class=\"number\">1</span> : ((x == y) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareUnsigned</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compare(x + MIN_VALUE, y + MIN_VALUE);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们只贴出了和比较相关的方法。<br>可以看到，<code>compareTo</code>方法其中调用了<code>compare</code>方法，这是JDK1.7增加的方法。在<code>Integer</code>中新增这个方法是为了减少不必要的自动装箱拆箱。传入<code>compare</code>方法的是两个<code>Integer</code>的值<code>x</code>和<code>y</code>。<br>如果<code>x &lt; y</code>， 返回<code>-1</code>；如果<code>x = y</code>， 返回<code>0</code>；如果<code>x &gt; y</code>， 返回<code>1</code>。<br>顺便一说，JDK中的实现非常简洁，只有一行代码， 当判断情况有三种时，使用这种嵌套的判断 <code>x ? a : b</code> 可以简洁不少，这是该学习的。</p>\n<p>后面的<code>compareUnsigned</code>是JDK1.8新加入的方法, 用来比较无符号数。这里的无符号数意思是默认二进制最高位不再作为符号位，而是计入数的大小。<br>其实现是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareUnsigned</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> compare(x + MIN_VALUE, y + MIN_VALUE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接为每个值加了<code>Integer</code>的最小值 -2<sup>31</sup>。我们知道Java中<code>int</code>类型为4个字节，共32位。符号位占用一位的话，则其范围为-2<sup>31</sup> 到2<sup>31</sup> - 1。<br>使用此方法时，所有正数都比负数小。最大值为 <code>-1</code>，因为 <code>-1</code>的二进制所有位均为 1。<br>也就是<code>1111 1111 1111 1111 1111 1111 1111 1111</code> &gt; 其它任何32位数。</p>\n<p>关于编码可参考此篇博文<a href=\"https://stephenhuge.github.io/2017/10/18/计算机编码简介/\" target=\"_blank\" rel=\"noopener\">计算机编码简介</a></p>\n<h2 id=\"2-2-String类型的compareTo方法\"><a href=\"#2-2-String类型的compareTo方法\" class=\"headerlink\" title=\"2.2 String类型的compareTo方法\"></a>2.2 String类型的compareTo方法</h2><p>看完<code>Integer</code>后，我们再来看<code>String</code>中<code>compareTo</code>的实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];     <span class=\"comment\">// String的值</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len2 = anotherString.value.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lim = Math.min(len1, len2);     <span class=\"comment\">// limit， 表示两个String中长度较小的String长度</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c1 = v1[k];</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c2 = v2[k];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> c1 - c2;     <span class=\"comment\">// 如果char不相同，则取其差值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;    <span class=\"comment\">// 如果char值相同，则继续往后比较</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len1 - len2;     <span class=\"comment\">// 如果所有0 ~ (lim - 1)的char均相同，则比较两个String的长短</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 字面意思是对大小写不敏感的比较器</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class=\"line\">                                         = <span class=\"keyword\">new</span> CaseInsensitiveComparator();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaseInsensitiveComparator</span></span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8575799808933029326L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> n1 = s1.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n2 = s2.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = Math.min(n1, n2);     <span class=\"comment\">// 和上面类似，均是取两个String间的最短长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; min; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c1 = s1.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c2 = s2.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">                    c1 = Character.toUpperCase(c1); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    c2 = Character.toUpperCase(c2); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 大写如果不相等则再换为小写试试</span></span><br><span class=\"line\">                        c1 = Character.toLowerCase(c1);</span><br><span class=\"line\">                        c2 = Character.toLowerCase(c2);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 到此处则确定不相等</span></span><br><span class=\"line\">                            <span class=\"comment\">// No overflow because of numeric promotion</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1 - n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** Replaces the de-serialized object. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// String的方法，可以直接使用这个方法和其它String进行比较，</span></span><br><span class=\"line\">    <span class=\"comment\">// 内部实现是调用内部比较器的compare方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareToIgnoreCase</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER.compare(<span class=\"keyword\">this</span>, str);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>String</code>中的关于<code>compare</code>的方法相对复杂一点，但还是比较简单。我们先不看其他的代码，只重点关注<code>compareTo</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len1 = value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len2 = anotherString.value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lim = Math.min(len1, len2);     <span class=\"comment\">// limit， 表示两个String中长度较小的String长度</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c1 = v1[k];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c2 = v2[k];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c1 - c2;     <span class=\"comment\">// 如果char不相同，则取其差值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k++;    <span class=\"comment\">// 如果char值相同，则继续往后比较</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len1 - len2;     <span class=\"comment\">// 如果所有0 ~ (lim - 1)的char均相同，则比较两个String的长短</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内容很简洁，就是取两个<code>String</code>的长度中较小的，作为限定值(<code>lim</code>)。之后对数组下标为从<code>0</code>到<code>lim - 1</code>的<code>char</code>变量进行遍历比较，如果遇到不相同的值，返回其差值。一般我们只用其正负性，如果返回负数则说明第一个对象比第二个对象“小”。<br>例如比较 <code>&quot;abc&quot;</code>和<code>&quot;bcd&quot;</code>，当对各自第一个字符<code>&#39;a&#39;</code>和 <code>&#39;b&#39;</code>进行比较时，发现 <code>&#39;a&#39; != &#39;b&#39;</code>，则返回 <code>&#39;a&#39; - &#39;b&#39;</code> ，这个值是负数， <code>char</code>类型的<code>-1</code>，Java会自动将其类型强转为<code>int</code>型。最后得出结论<code>&quot;abc&quot;</code>比<code>&quot;bcd&quot;</code>小。</p>\n<h1 id=\"3-Comparator\"><a href=\"#3-Comparator\" class=\"headerlink\" title=\"3. Comparator\"></a>3. Comparator</h1><p><code>Comparator&lt;T&gt;</code>接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这是一个外部排序接口，它的功能是规定“比较大小”的方式。实现它的类可以作为参数传入<code>Collections.sort()</code>或<code>Arrays.sort()</code>，使用它的比较方式进行排序。<br><strong>它可以为没有实现<code>Comparable</code>接口的类提供排序方式。</strong><br><code>String</code>类中以及<code>Array</code>类等都有实现此接口的内部类。</p>\n<p>在上面<code>String</code>的源码中就有一个内部的自定义<code>Comparator</code>类<code>CaseInsensitiveComparator</code>， 我们看看它的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class=\"line\">                                         = <span class=\"keyword\">new</span> CaseInsensitiveComparator();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaseInsensitiveComparator</span></span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8575799808933029326L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> n1 = s1.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n2 = s2.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = Math.min(n1, n2);     <span class=\"comment\">// 和上面类似，均是取两个String间的最短长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; min; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c1 = s1.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c2 = s2.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">                    c1 = Character.toUpperCase(c1); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    c2 = Character.toUpperCase(c2); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 大写如果不相等则再换为小写试试</span></span><br><span class=\"line\">                        c1 = Character.toLowerCase(c1);</span><br><span class=\"line\">                        c2 = Character.toLowerCase(c2);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 到此处则确定不相等</span></span><br><span class=\"line\">                            <span class=\"comment\">// No overflow because of numeric promotion</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1 - n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** Replaces the de-serialized object. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// String的方法，可以直接使用这个方法和其它String进行比较，</span></span><br><span class=\"line\">    <span class=\"comment\">// 内部实现是调用内部比较器的compare方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareToIgnoreCase</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER.compare(<span class=\"keyword\">this</span>, str);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>CaseInsensitiveComparator</code>, 字面意思是对大小写不敏感的比较器。<br>我们观察它的<code>compare</code>方法，可以发现，它和上面的<code>compareTo</code>方法实现类似，都是取两个<code>String</code>中长度较小的，作为限定值<code>min</code>，之后对数组下标为从<code>0</code>到<code>min - 1</code>的<code>char</code>变量进行遍历比较。和上面稍有不同的是，此处先将<code>char</code>字符统一换成大写（upper case）， 如果仍然不相等，再将其换为小写（lower case）比较。一个字母只有大写或者小写两种情形，如果这两种情况都不想等则确定不相等，返回其差值。如果限定值内所有的<code>char</code>都相等的话，再去比较两个<code>String</code>类型的长度。</p>\n<p>例如比较 <code>&quot;abC&quot;</code>和<code>&quot;ABc&quot;</code>，<code>compareTo</code>会直接返回 <code>&#39;a&#39; - &#39;A&#39;</code>，而<code>compareToIgnoreCase</code>方法由于使用了<code>CaseInsensitiveComparator</code>，比较结果最终会返回<code>true</code>。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p> 【1】<a href=\"http://blog.csdn.net/Yvonne8_5/article/details/50957079\" target=\"_blank\" rel=\"noopener\">Java源码学习之Integer类（二）——1.8新增的几个函数和变量</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/19/Java%E4%B8%AD%E7%9A%84Comparable%E6%8E%A5%E5%8F%A3%E5%92%8CComparator%E6%8E%A5%E5%8F%A3/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"Sorting","slug":"Sorting","permalink":"https://stevehuge.gitee.io/blog/tags/Sorting/"},{"name":"Comparable","slug":"Comparable","permalink":"https://stevehuge.gitee.io/blog/tags/Comparable/"},{"name":"Comparator","slug":"Comparator","permalink":"https://stevehuge.gitee.io/blog/tags/Comparator/"}]},{"title":"计算机编码简介","date":"2017-10-18T14:00:53.000Z","path":"2017/10/18/计算机编码简介/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81_top.jpg?raw=true\" alt=\"\"></p>\n<h1 id=\"计算机编码\"><a href=\"#计算机编码\" class=\"headerlink\" title=\"计算机编码\"></a>计算机编码</h1><h2 id=\"1-原码、反码和补码\"><a href=\"#1-原码、反码和补码\" class=\"headerlink\" title=\"1. 原码、反码和补码\"></a>1. 原码、反码和补码</h2><p>首先我们知道，在计算机中，所有数都是以二进制存在，也就是<code>0</code>和<code>1</code>的组合。  </p>\n<p>但是通过研究二进制，人们发现了二进制并不能很好的和十进制对应起来。首先十进制中有正数和负数，而二进制中的负号<code>-</code>该如何表示呢？有人想到用二进制的最高位表示，此位为<code>0</code>则表示正数，<code>1</code>表示这个数为负数。</p>\n<a id=\"more\"></a>\n<h2 id=\"举个例子：\"><a href=\"#举个例子：\" class=\"headerlink\" title=\"举个例子：\"></a>举个例子：</h2><p><code>1</code>的二进制为<code>0001</code>，那么<code>-1</code>的二进制就是<code>1001</code>。</p>\n<p>但是直接这么表示就会出现刚才提到的对应问题。</p>\n<p>例如如果<code>1</code>和<code>-1</code>直接相加，则<code>1 + （-1） = 0</code>，十进制是没有问题的。而二进制表示为<code>0001 + 1001 = 1010 != 0</code>，所以不能直接使用这种方式做运算。而这种直接用最高位表示符号位，其他位表示数字的编码形式称为<strong>原码</strong>。</p>\n<p>原码不能解决这个问题，于是又出现了<strong>反码</strong>，反码是当这个数为负数时，原码除符号位外其他位取反。<code>1001（-1）</code>（原码）取反后为<code>1110</code>。</p>\n<p>继续进行刚才的计算，这次使用反码： （反码）<code>0001 （1） + 1110 （-1） = 1111</code> 。由于<code>1111</code>最高位为1，是负数，所以再次取反之后才是其真实值，取反后为<code>1000</code>，也就是<code>-0</code>。</p>\n<p>这能满足条件了，但是美中不足的是，<code>0</code>带了负号。唯一的问题其实就出现在<code>0</code>这个特殊的数值上。 虽然人们理解上<code>+0</code>和<code>-0</code>是一样的， 但是0带符号是没有任何意义的。 而且会有<code>0000</code>原和<code>1000</code>原两个编码表示<code>0</code>。怎么办呢？</p>\n<p>人们又想出了补码，它的定义是反码加<code>1</code>。<code>-1</code>的补码是 <code>1111</code>，以上的运算用补码表示就是<code>0001 （1） + 1111 （-1） = 0000 = 0</code>。神奇的发现，这个式子完美契合了十进制加法！<br>同时我们留出了<code>1000</code>，可以用它表示<code>-8</code></p>\n<p><code>(-1) + (-7) = (补码) 1111 + 1001 = 1000 = -8</code>。注意，由于此处的<code>-8</code>使用了之前<code>-0</code>的补码来表示，所以<code>-8</code>没有没有原码和反码表示（针对的四位，如果是八位，则没有原码和反码的是<code>-128</code>，依次类推）。</p>\n<p>使用补码, 不仅仅修复了<code>0</code>的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么4位二进制, 使用原码或反码表示的范围为<code>[-7, +7]</code>, 而使用补码表示的范围为<code>[-8, 7]</code>.</p>\n<p>推广到<code>k</code>位：在处理k位的有符号数时，用二进制补码的形式表示负整数<code>-n</code>(1 $\\le$ n $\\le$ $2^k - 1$)， 则补码的二进制值为$2^k - n$ 。非负整数<code>p</code>(0 $\\le$ p $\\le$ $2^{k - 1} - 1$)，只是简单的用k位二进制数表示<code>p</code>的值。因此对于给定的<code>k</code>位，我们可以通过二进制补码表示$-2^{k - 1}$到$2^{k - 1} - 1$的值。</p>\n<p><strong>总结</strong></p>\n<p>为了使数字在计算机中运算不出错，出现了原码，反码和补码。原码就是一个数的二进制表示，其中最高位为符号位，表示其正负。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/JDK%E6%BA%90%E7%A0%81/Comparable&amp;Comparator/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81.jpg?raw=true\" alt=\"\"></p>\n<p>原码，反码和补码运算对比。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/JDK%E6%BA%90%E7%A0%81/Comparable&amp;Comparator/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95.jpg?raw=true\" alt=\"\"></p>\n<p>这就是简单的要用反码和补码的原因。</p>\n<h2 id=\"2-大数溢出问题\"><a href=\"#2-大数溢出问题\" class=\"headerlink\" title=\"2. 大数溢出问题\"></a>2. 大数溢出问题</h2><p><code>int</code>类型在32位系统中占4个字节、32bit，补码表示的的数据范围为：</p>\n<p>[10000000 00000000 00000000 00000000] ~ [01111111 11111111 11111111 11111111]</p>\n<p>[−2<sup>31</sup>,2<sup>31</sup>−1]<br>[-2147483648, 2147483647]</p>\n<p>在java中表示为：</p>\n<p>[Integer.MIN_VALUE, Integer.MAX_VALUE]</p>\n<p>与<code>byte</code>类型的表示一样，由于负数比正数多表示了一个数字。对下限取相反数后的数值会超过上限值，溢出到下限，因此下限的相反数与下限相等；对上限去相反数的数值为负值，该负值比下限的负值大1，在可以表示的范围内，因此上限的相反数是上限直接取负值。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>【1】<a href=\"http://blog.csdn.net/u011080472/article/details/51280919\" target=\"_blank\" rel=\"noopener\">计算机原码、反码、补码详解</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E7%AE%80%E4%BB%8B/","tags":[{"name":"编码","slug":"编码","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"动态代理2","date":"2017-08-20T16:21:27.000Z","path":"2017/08/21/动态代理2/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/proxy_top.jpg?raw=true\" alt=\"代理模式\"></p>\n<h1 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h1><p>我们在上篇文章中提到通过调用<code>Proxy</code>类的<code>newProxyInstance()</code>方法生成了一个临时实例，这个实例就是我们需要的代理类。我们的代理类被动态的创建，省去了我们针对业务方法而手动实现如日志记录等功能。<br>我们继续深入，来详细看一下这个过程：<br><a id=\"more\"></a></p>\n<pre><code>    public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, \n                                                InvocationHandler h) {\n            ...        \n            //1. 获取传入的之前被代理类实现的接口\n            final Class&lt;?&gt;[] intfs = interfaces.clone();    \n            ...\n             //2. 生成设计好的代理类的Class对象\n            Class&lt;?&gt; cl = getProxyClass0(loader, intfs);   \n            ...\n            //3. 获取生成好代理类的带参构造方法，其中参数就是InvocationHandler接口的实例\n            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);   \n\n            final InvocationHandler ih = h; \n            ...\n            //4. 通过构造方法生成代理类实例\n            return cons.newInstance(new Object[]{h});   \n            ...\n    }\n</code></pre><p>这就是<code>Proxy</code>类<code>newProxyInstance</code>方法的核心逻辑，其中去除了一些判断和异常处理代码，这些都跟我们目前的讨论没有太大关系。<br>可以看出来，这里最重要的就是这一句：</p>\n<pre><code>    //2. 生成设计好的代理类的Class对象\n    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    \n</code></pre><p>生成了设计好的临时代理类的<code>Class</code>对象之后，我们可以使用反射获取它的构造方法进而生成它的实例，这个<code>Class</code>对象的具体生成方法是什么呢？<br>我们继续探究它的实现方式：</p>\n<pre><code>    /**\n     * 生成代理类的Class对象\n     */\n     private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,\n                                               Class&lt;?&gt;... interfaces) {\n            ...\n            // If the proxy class defined by the given loader implementing\n            // the given interfaces exists, this will simply return the cached copy;\n            // otherwise, it will create the proxy class via the ProxyClassFactory\n\n            //使用缓存获取之前生成的Class对象，如果之前未生成，则使用ProxyClassFactory生成\n            return proxyClassCache.get(loader, interfaces);\n        }\n</code></pre><p>这里使用到了缓存技术，如果之前生成过该类的Class对象，直接通过缓存返回它。我们这是第一次生成，看注释中提到：</p>\n<pre><code>    If the proxy class defined by the given loader implementing \n    the given interfaces exists, this will simply return the cached copy;\n    otherwise, it will create the proxy class via the ProxyClassFactory\n</code></pre><p>意思是之前已经创建过这个代理类，那么直接使用缓存，未建立的话使用<code>ProxyClassFactory</code>类建立代理类，通过缓存类的代码，我们发现其中调用了<code>ProxyClassFactory</code>的<code>apply</code>方法。我们现在做的就是研究代理类的生成机理，所以来看看<code>ProxyClassFactory</code>。<br>我使用的是<code>eclipse</code>，使用快捷键：<code>Ctrl+Shift+T</code>打开搜索界面，输入<code>ProxyClassFactory</code>，找到这个类。这个类其实是<code>Proxy</code>类 的一个内部类，我们通过<code>eclipse</code>发现其中只有一个方法<code>apply</code>，看来就是它了，它的代码是：</p>\n<pre><code>    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {\n        ...\n        //1. 生成指定的代理类的二进制数组\n        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n        proxyName, interfaces, accessFlags);    \n        ...\n        //2. 通过生成的二进制数组proxyClassFile生成一个Class&lt;?&gt;类型的实例，这是一个native方法\n        return defineClass0(loader, proxyName,\n                        proxyClassFile, 0, proxyClassFile.length); \n    }\n</code></pre><p>和之前一样，略去了一些判断语句和生成细节等代码。<br>我们发现直接通过<code>ProxyGenerator</code>类的<code>generateProxyClass</code>方法得到了一个二进制文件，这个也就是我们平时说的<code>.class</code>文件。到此处已经比较清楚代理类的生成过程了，之后二进制文件的具体生成步骤不再跟进，有兴趣的读者可以继续深入研究。<br>最后根据这个<code>.class</code>文件通过虚拟机加载，解析，初始化生成代理类的<code>Class</code>类对象，最终，使用反射获取其构造方法后生成代理类的对象。  </p>\n<p>我们通过下面的图看可能会清晰一点：  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/Proxy%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE.jpg?raw=true\" alt=\"Proxy函数调用图\"></p>\n<p>其实用户接触的只有一个<code>newProxyInstance</code>方法，其余的方法都是层层调用被使用的。其实就具体就干了两件事：生成代理类<code>Class</code>对象和生成代理类对象，后者依赖于前者。<br>按照图中标注的顺序而且根据方法具体的行为来说：<br>a. 外部测试代码调用<code>Proxy</code>类的<code>newProxyInstance</code>方法<br>b. <code>newProxyInstance</code>方法中调用了<code>Proxy</code>类的<code>getProxyClass0</code>方法<br>c. <code>getProxyClass0</code>方法中调用<code>Proxy</code>类的内部类<code>ProxyClassFactory</code>类的<code>apply</code>方法<br>d. <code>ProxyClassFactory</code>类的<code>apply</code>方法中调用<code>ProxyGenerator</code>类的<code>generateProxyClass</code>方法，这步生成了一个二进制数组<br>e. <code>generateProxyClass</code>方法把二进制数组返回给<code>apply</code>方法<br>f. 之后<code>apply</code>方法继续调用<code>native</code>方法<code>defineClass0</code>，然后生成了一个<code>Class</code>类对象<br>g. <code>Class</code>对象返回给<code>apply</code>方法<br>h. <code>Class</code>对象返回给<code>getProxyClass0</code>方法<br>i. <code>Class</code>对象返回给<code>newProxyInstance</code>方法<br>j. <code>newProxyInstance</code>方法中使用返回的<code>Class</code>对象，通过反射获取其带参构造方法，之后生成一个代理类的对象，返回给测试类  </p>\n<p>具体行为对应的方法：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95%E4%BD%9C%E7%94%A8.jpg?raw=true\" alt=\"动态代理具体方法作用\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>[1] <a href=\"http://blog.csdn.net/luanlouis/article/details/24589193#t2\" target=\"_blank\" rel=\"noopener\">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a>  </p>\n<p>[2] <a href=\"http://blog.csdn.net/zhangerqing/article/details/42504281\" target=\"_blank\" rel=\"noopener\">Java之美[从菜鸟到高手演练]之JDK动态代理的实现及原理）</a>  </p>\n<p>[3] <a href=\"https://mp.weixin.qq.com/s/t5pU_aHiqQt3yUJKgs4hqQ\" target=\"_blank\" rel=\"noopener\">JAVA 动态代理</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/08/21/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%862/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://stevehuge.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"https://stevehuge.gitee.io/blog/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://stevehuge.gitee.io/blog/tags/AOP/"},{"name":"Proxy","slug":"Proxy","permalink":"https://stevehuge.gitee.io/blog/tags/Proxy/"}]},{"title":"动态代理1","date":"2017-08-20T12:40:27.000Z","path":"2017/08/20/动态代理1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/proxy_top.jpg?raw=true\" alt=\"代理模式\"></p>\n<h1 id=\"0-代理模式\"><a href=\"#0-代理模式\" class=\"headerlink\" title=\"0. 代理模式\"></a>0. 代理模式</h1><p>代理模式是一个很常见的设计模式，简单来说就是代理类<code>Proxy</code>替被代理类做一些东西。其中具体又有静态代理和动态代理两种。<br><a id=\"more\"></a></p>\n<h2 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. 静态代理</h2><p>现在移动支付在中国各个大中小城市都已经非常普及了，平时我们出去吃饭购物都可以使用支付宝或者微信支付轻松完成交易，而不再使用现金。我们现在就以这个作为例子来说明一下代理模式。<br>有两个角色：微信支付（<code>WeChatPay</code>）和银行（<code>Bank</code>），微信支付本质上就是银行的一个代理。每当你使用微信支付付款时，事实上是微信支付“代理”你和银行进行交互，最终完成了支付。两个类的代码如下：</p>\n<p>Bank.java</p>\n<pre><code>    public class Bank {\n        ...\n        public void pay() { //付款功能\n            ...\n        }\n        public void gathering() {   //收款功能\n            ...\n        }\n        ...\n    }\n</code></pre><p>WeChatPay.java</p>\n<pre><code>    public class WeChatPay {\n        ...\n        public void pay() { //付款功能\n            ...\n        }\n        public void gathering() {   //收款功能\n            ...\n        }\n        ...\n    }\n</code></pre><p>我们发现两个类的方法都是一样的，两个类的本质功能一致，都是对我们的财产进行管理，所以给它们抽象出一个共同的接口：<br>WealthManagement.java</p>\n<pre><code>    public interface WealthManagement {\n        public void pay();\n\n        public void gathering();\n    }\n</code></pre><p>然后让两个类均实现这个接口。同时由于微信支付是代理了银行的功能，事实上工作的实体是银行,所以一般它需要绑定一个银行类，我们改变后的代码是：<br>WeChatPay.java</p>\n<pre><code>    public class WeChatPay implements WealthManagement {\n        ...\n        private Bank bank = new Bank();\n\n        public void pay() { //付款功能\n            bank.pay();\n        }\n        public void gathering() {   //收款功能\n            bank.gathering();\n        }\n        ...\n    }\n</code></pre><p>一个最简单的微信支付模型出来了，它其中有一个银行类的成员变量，每当需要进行付款或者收款操作时，它都会调用银行的收款和付款方法。<br>看起来还不错，但是仍然有需要改进之处：<br>(1) 我们不希望在微信支付中固定某个银行，而是希望用户能在使用微信时手动的添加；<br>(2) 微信支付调用了银行的功能，我们希望给用户一些提示，告知他们正在使用微信支付代理而非原版的银行功能。<br>加上之后这两个请求之后，完整的微信支付功能如下：<br>WeChatPay.java</p>\n<pre><code>    public class WeChatPay implements WealthManagement {\n        //...\n        private Bank bank;\n\n        public WeChatPay(Bank bank) {\n            this.bank = bank;\n        }\n\n        public void pay() { //付款功能\n            System.out.println(&quot;您正在使用微信支付...&quot;);\n            bank.pay();\n            System.out.println(&quot;微信支付使用完毕...&quot;);\n        }\n        public void gathering() {   //收款功能\n            System.out.println(&quot;您正在使用微信支付...&quot;);\n            bank.gathering();\n            System.out.println(&quot;微信支付使用完毕...&quot;);\n        }\n        //...\n    }\n</code></pre><p>我们使用构造方法传入一个银行类变量<code>bank</code>，进行指定具体的银行，并且在微信支付的每个方法中都加入了提醒功能。<br>完整的银行代码：<br>Bank.java</p>\n<pre><code>    public class Bank implements WealthManagement {\n        //...\n        public void pay() { //付款功能\n            System.out.println(&quot;使用银行的付款功能&quot;);\n        }\n        public void gathering() {   //收款功能\n            System.out.println(&quot;使用银行的收款功能&quot;);\n        }\n        //...\n    }\n</code></pre><p>现在貌似可以使用了，我们写一个测试类<code>Test</code>测试一下：<br>Test.java</p>\n<pre><code>    public class Test {\n        public static void main(String[] args) {\n            Bank construction = new Bank();\n\n            WeChatPay wePay = new WeChatPay(construction);\n\n            wePay.pay();\n            System.out.println(&quot;----------&quot;);\n            wePay.gathering();\n        }\n    }\n</code></pre><p>打印结果:</p>\n<pre><code>您正在使用微信支付...\n使用银行的付款功能\n微信支付使用完毕...\n----------\n您正在使用微信支付...\n使用银行的收款功能\n微信支付使用完毕...\n</code></pre><p>这其实就是一个简单的代理模式的例子。被代理类（<code>Bank</code>类）和代理类（<code>WeChatPay</code>类）实现同一个接口，然后代理类（<code>WeChatPay</code>类）持有一个被代理类（<code>Bank</code>类）的成员变量。这样做两个类实现了同样的方法，代理类（<code>WeChatPay</code>类）中的方法会调用自己持有的被代理类（<code>Bank</code>类）对象的方法，相当于是“包装”了一下被代理类的方法。代理类（<code>WeChatPay</code>）做的就是在被代理类（<code>Bank</code>）的基础上加一点工作，它是为被代理类服务的。    </p>\n<p>这个例子中就是：微信支付<code>WeChatPay</code>代理银行<code>Bank</code>让用户进行财产管理操作，在我们使用微信支付的付款<code>pay</code>方法时，事实上调用的是<code>Bank</code>的<code>pay</code>方法，只不过这个过程在微信<code>WeChatPay</code>的<code>pay</code>方法的“代理”下完成，微信支付的<code>pay</code>方法对银行的<code>pay</code>方法进行了一下“包装”，在其前后添加了两个提醒的功能。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/银行_微信代理.jpg?raw=true\" alt=\"银行_微信代理\"></p>\n<p>这就是一个静态代理的简单的例子。想说明的一点就是：代理模式就是通过一个代理类来替一个正常工作的类完成额外的一些操作，这些操作对于被代理类来说可以完全不用知道，由代理类完成即可。<br>例如简单的日志打印模块，我们需要在业务操作之前之后打印相关数据的日志，输入为一个业务操作相关的实例。<br>我们用代理模式完成，只需要在代理类（日志打印模块）中传入这个实例（业务操作），通过业务操作实例的一些get方法获取一些数据，然后用代理类（日志打印模块）的打印方法打印出这些数据，之后再去调用正常的业务方法即可。  </p>\n<h3 id=\"原理分析以及静态代理的问题\"><a href=\"#原理分析以及静态代理的问题\" class=\"headerlink\" title=\"原理分析以及静态代理的问题\"></a><strong>原理分析以及静态代理的问题</strong></h3><p>静态代理是AOP（Aspect Oriented Programming， 面向切面编程）最简单的实现，想在多个相同实例的方法之前之后都加上点权限管理或者类似的功能，那么使用代理类就可以轻松完成而不用修改代码。  </p>\n<p>我们针对上面的例子深入分析：<br>当在代码阶段规定好了代理关系（微信支付代理银行支付，我们需要支付操作时，直接使用微信支付即可）后，微信支付类<code>WeChatPay</code>类通过编译器编译成<code>class</code>文件，当系统运行时，此<code>class</code>已经存在了。这种静态的代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；<br>并且由于<code>WeChatPay</code>和<code>Bank</code>的功能 本质上是相同的，<code>WeChatPay</code>只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。<br>让我们把这个例子补充的更完整一点：对应到现实生活中就是除了使用微信支付进行付款和收款操作之外，我们有时可能还需要进行退款（<code>refund</code>）操作，如果继续使用之前的方法，操作就是：<br>（1） 在<code>WealthManagement</code>接口中添加<code>refund</code>方法；<br>（2） 在<code>Bank</code>类中实现<code>refund</code>方法；<br>（3） 在<code>WeChatPay</code>类中实现<code>refund</code>方法。  </p>\n<p>实现<code>refund</code>方法的WeChatPay.java</p>\n<pre><code>    public class WeChatPay implements WealthManagement {\n        //...\n\n        public void refund() { //退款功能\n            System.out.println(&quot;您正在使用微信支付...&quot;);\n            bank.refund();\n            System.out.println(&quot;微信支付使用完毕...&quot;);\n        }\n        //...\n    }\n</code></pre><p>如果以后要再实现其它新的方法时，也要重复上述三个步骤。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/微信_静态代理局限.jpg?raw=true\" alt=\"微信_静态代理局限\"></p>\n<p>我们发现，第（3）步中事实上只是继续在“包装”<code>Bank</code>的<code>refund</code>方法前后继续添加提醒功能。其内容和<code>pay</code>以及<code>gathering</code>方法几乎一样，这样做其实导致业务代码中夹杂了大量的重复的提醒代码，做了大量不必要的重复性工作，同时系统的冗余大量增加。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%A0%81.jpg?raw=true\" alt=\"静态代理代码\"></p>\n<p>提醒代码事实上只有一份就足够了。如何实现呢？<br>我们希望可以一次性实现这个功能，之后我们不再需要对每个具体的被代理方法实现对应的代理方法。这叫做<strong>针对某一类功能实现</strong>：例如说提示功能，不需要每个业务方法都有一个对应的带提醒的“包装”方法，而是最好由一个类或者一个方法直接实现所有的提醒功能，类似可以实现的功能还有日志打印。<br>这时不得不提一个很厉害的工具——<strong>动态代理</strong>。</p>\n<p>动态代理正是为了解决代理类中代码爆炸的问题而出现的。具体实现为：在运行状态中，需要代理的地方，根据代理接口和被代理类，动态地创建一个代理类，用完之后，就会销毁，无需我们手动去创建代理类，这样就可以避免了代理类角色的<code>class</code>在系统中代码冗杂的问题了。  </p>\n<h2 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. 动态代理</h2><p>上述的问题使用动态代理该怎么做呢？我们看代码：<br>动态代理类NewWeChatPay.java</p>\n<pre><code>    public class NewWeChatPay implements InvocationHandler {\n\n        private Object obj;\n\n        public NewWeChatPay(Object obj) {\n            this.obj = obj;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n            System.out.println(&quot;您正在使用微信支付...&quot;);\n\n            Object result = method.invoke(obj, args);\n\n            System.out.println(&quot;微信支付使用完毕...&quot;);\n\n            return result;\n        }\n    }\n</code></pre><p>在这里<code>NewWeChatPay</code> 是一个新的微信支付类，它实现了<code>InvocationHandler</code>接口。这个接口是个调用处理器，每当我们生成的代理类执行方法时，都会调用这个接口实现类的方法。我们先不着急了解它的原理，因为在下一篇文章中会详细阐述。   </p>\n<p>测试类 DynamicTest.java</p>\n<pre><code>    import java.lang.reflect.InvocationHandler;\n    import java.lang.reflect.Proxy;\n\n    public class DynamicTest {\n        public static void main(String[] args) throws Throwable {\n\n            Bank construction = new Bank();  //这是一个银行实例\n\n            InvocationHandler handle = new NewWeChatPay(construction); //新建一个微信支付调用处理器\n\n            ClassLoader loader = handle.getClass().getClassLoader(); //获取加载handle的类加载器\n\n            Class[] interfaces = construction.getClass().getInterfaces();  //获取银行实现的接口\n\n\n            InvocationHandler h = handle;\n\n            Object proxy = Proxy.newProxyInstance(loader, interfaces, h);     //这一句生成了代理银行的微信支付类\n\n            WealthManagement myProxy = (WealthManagement) proxy;\n\n            myProxy.pay();    //微信支付代理类执行pay方法\n\n        }\n    }\n</code></pre><p>打印结果：</p>\n<pre><code>您正在使用微信支付...\n使用银行的付款功能\n微信支付使用完毕...\n</code></pre><p>看着很长，但是大家不要怕，其实主要就一句：</p>\n<pre><code>Object proxy = Proxy.newProxyInstance(loader, interfaces, h);     //这一句生成了代理银行的微信支付类\n</code></pre><p>调用<code>Proxy</code>类的<code>newProxyInstance()</code>方法生成了一个代理类实例，这个实例就是我们需要的代理类。<br>我们发现，在使用动态代理之后，的确减少了代码量。之前<code>Bank</code>类的每个方法都需要代理类实现对应的方法，而现在，只需要<code>NewWeChatPay</code>类中的一个<code>invoke</code>方法就可以完成多个方法的代理。<br>在动态代理中生成的代理类是一个临时的类，我们的代理类需要实现<code>Bank</code>类所实现的接口，所以传入了<code>Bank</code>实现的接口，传入其类加载器是为了确认这些接口的Class类对象和动态代理类的Class对象都是被同一个类加载器加载的，最后的<code>InvocationHandler</code>接口的实例就是我们之前创建好的调用处理器。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&amp;%20Proxy/%E5%BE%AE%E4%BF%A1_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%B3%E7%B3%BB.jpg?raw=true\" alt=\"动态代理关系\"></p>\n<p>在接下来的一篇文章中，我们会详细探讨<code>Proxy</code>类的<code>newProxyInstance()</code>方法生成临时代理类的过程。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>[1] <a href=\"http://blog.csdn.net/luanlouis/article/details/24589193#t2\" target=\"_blank\" rel=\"noopener\">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a>  </p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/08/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%861/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://stevehuge.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"https://stevehuge.gitee.io/blog/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://stevehuge.gitee.io/blog/tags/AOP/"},{"name":"Proxy","slug":"Proxy","permalink":"https://stevehuge.gitee.io/blog/tags/Proxy/"}]},{"title":"JDBC的总结","date":"2017-08-06T10:56:27.000Z","path":"2017/08/06/JDBC总结/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/JDBC/top.jpg?raw=true\" alt=\"JDBC top\">  </p>\n<a id=\"more\"></a>\n<h1 id=\"记录JDBC的学习过程\"><a href=\"#记录JDBC的学习过程\" class=\"headerlink\" title=\"记录JDBC的学习过程\"></a>记录JDBC的学习过程</h1><h2 id=\"学习心得\"><a href=\"#学习心得\" class=\"headerlink\" title=\"学习心得\"></a>学习心得</h2><p>　　最近两周总结了一下JDBC的大致原理和一些API的使用。 </p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>　　整体来说，JDBC是一组公共接口，用来确定如何让应用程序和数据库打交道，而各个数据库厂商会针对JDBC公共接口提供自己的实现类。  </p>\n<p>项目在GitHub上的地址：<a href=\"https://github.com/StephenHuge/MyJDBCReWrite\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/MyJDBCReWrite</a><br>其中分为6个包：<br><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/common\" target=\"_blank\" rel=\"noopener\">com.jdbc.common</a>：存储一些JDBC的基础知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/extensions\" target=\"_blank\" rel=\"noopener\">com.jdbc.extensions</a>： 存储一些初基础之外接近扩展工具的知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/transaction\" target=\"_blank\" rel=\"noopener\">com.jdbc.transaction</a>： 存储JDBC中关于数据库事务的知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/connectionpool\" target=\"_blank\" rel=\"noopener\">com.jdbc.connectionpool</a>： 存储JDBC中关于数据库连接池的知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/dbutilstest\" target=\"_blank\" rel=\"noopener\">com.jdbc.dbutilstest</a>： 存储对Apache开发的一个工具类DBUtils的简单测试</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/mytools\" target=\"_blank\" rel=\"noopener\">com.jdbc.mytools</a>： 工具包，存储自己抽取出来的一些工具代码</strong>  </p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/08/06/JDBC%E6%80%BB%E7%BB%93/","tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://stevehuge.gitee.io/blog/tags/JDBC/"},{"name":"数据库","slug":"数据库","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://stevehuge.gitee.io/blog/tags/Hibernate/"}]},{"title":"聊赖一记","date":"2017-05-05T13:22:07.000Z","path":"2017/05/05/聊赖一记/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E9%9A%8F%E7%AC%94/%E6%A1%83%E8%8A%B1.jpg?raw=true\" alt=\"\"><br><a id=\"more\"></a><br>　这两天可以说是百无聊赖了。</p>\n<p>　　自从5.1放假之后，状态就不是很好。做完一个和手头项目不相关的实验，仿佛用掉了大部分的力气。现在便是和以前有段时间一样——脑袋昏沉不已，仿若脑中被抽成了真空，没有一丝的声音，也没有一丝的光线。而这种状态，经常如同春末夏初的风和雨，说来便来，说走就走。而我，对此无可奈何，任何尝试性的努力，看再多的鸡汤文也无济于事。只能等啊、等啊，等到这股无形的劲儿过去了，一切便风轻云淡，一如从前了。<br>　　风还在刮，这八楼的风一如从前，每到换季的日子，这些从西伯利亚吹来的冷空气，便又开始喋喋不休地在窗外回旋。而楼下刚开的丁香花，在这一轮又一轮的风中，瑟缩颤抖，直到被吹落到地上，再被风给卷起，不知飘到何处去了。寥落，便是这些花中一大部分成员的一生。春风来了，她们便也跟着来了，季风来了，她们也就跟着这风，这雨，一起飘到城市的另一端去了。<br>　　还记得前两天这些花刚绽放时，都是一簇簇，一团团地开，极美却又绝不妖艳。那花儿，缩成一小团却每团却又通透的紧，如同一个个刚出锅的糯米团，给人一种软软的很轻柔的亲切，又如同一颗颗月中时分的小月亮，透着明亮、干净，而又馨香馥郁。<br>　　来这科学园的人不少，大多数都是附近的白领，周末带着孩子来游玩。往往是一家三口，拍照的、小孩子玩轮滑的，一番和谐气象。在这些花、这些树的下面，便都是快乐的声音，这声音往往极富感染力，让你不由自主的亲近，不，应该是沉浸，沉浸在快乐和和谐交织的情境中，总能回忆起家的温馨、家的舒适自如。而过后的，便是怅然若失。<br>　　平日里总是一个人，幽寂得活着，不跟身边的人交流，而自己也在日复一日的沉默寡言和患得患失中，沉沦了。读书是个很好的消解寂寞的方式，但沉沦的人往往静不下心来，尝试这古老却又流行的法子。沉沦的人会出去闲逛，在春日的俯视下，在心中有无限沟壑却因不知如何表达的情况下，面沉如水。去逛逛吧，这是他对自己说的话。他也是这么做的，提着自己的身体，仰望园中各类的古树名木，静静地走一圈，又走一圈。身体累了，他便在园中随意找个地方，席地而坐，休息一会儿，但想来却也说不出什么名堂来。<br>…</p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/05/%E8%81%8A%E8%B5%96%E4%B8%80%E8%AE%B0/","tags":[{"name":"随笔","slug":"随笔","permalink":"https://stevehuge.gitee.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"我的git使用教程2","date":"2017-05-04T15:00:48.000Z","path":"2017/05/04/我的git使用教程2/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/Git.jpg?raw=true\" alt=\"Git\"></p>\n<h1 id=\"为仓库创建一个分支（branch）\"><a href=\"#为仓库创建一个分支（branch）\" class=\"headerlink\" title=\"为仓库创建一个分支（branch）\"></a>为仓库创建一个分支（branch）</h1><p>现在我们有个提交过几次的git仓库，如果我们想在给我们的项目加点测试的东西，而又不想留一份原始不被影响的代码。传统的做法是复制项目，创建一个副本项目，在副本项目中进行测试，这样原来的项目不会受到影响。<br>这样看似不错，但是万一我们觉得测试代码不错，想要把它放进原始项目中，我们又不得不把测试代码复制到原始项目中（测试副本要不断进行新的开发），多来几次，万一其中有次出现了错误而没有发现，那修改就很麻烦了。<br>不过不用担心，git提供了另一个很有用的功能——分支(branch)。使用它能多层次、用户进行开发，十分便于管理且提升了效率。版本控制软件的好处就是你可以回到任何一个之前的开发版本中，而分支功能能很好在不影响稳定代码的情况下，允许我们进行更多操作，快来学习一下吧。分支的建立详细参见<a href=\"https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6\" target=\"_blank\" rel=\"noopener\" title=\"Git分支 - 分支的新建与合并\">Git分支 - 分支的新建与合并</a>。<br><a id=\"more\"></a><br>1.在git bash中输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b develop\t&#x2F;&#x2F;创建并切换到develop</span><br></pre></td></tr></table></figure><br> 这句话等价于<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch develop\t&#x2F;&#x2F;创建develop分支</span><br><span class=\"line\">git checkout develop\t&#x2F;&#x2F;切换到develop分支</span><br></pre></td></tr></table></figure><br>我们现在处于develop分支中，与原来的master分支相对应，develop就是一个git分支，我们可以在develop分支中对代码进行各种修改，添加，删除操作，提交后（这个不能忘记），这些操作只会修改develop分支中的内容，而对主分支master不会造成任何影响。如果修改出现了问题，想要回到之前的master分支，只需要输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master\t&#x2F;&#x2F;回到master主分支</span><br></pre></td></tr></table></figure><br> 就可回到主分支了。<br>2.如果在develop中开发了一段时间中，觉得代码已经稳定了，想要将develop分支合并到主分支去,那么git也提供合并操作。具体做法是：切换到主分支（不要忘记）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master\t&#x2F;&#x2F;回到master主分支</span><br></pre></td></tr></table></figure><br> 合并分支<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge develop\t&#x2F;&#x2F;合并master和develop</span><br></pre></td></tr></table></figure><br> 这样master分支和develop分支就合并到一起了，之前在develop分支开发的版本仍然存在，但是如果觉得develop版本已经没用了，以后不会再用到它，那么可以使用删除操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d develop\t&#x2F;&#x2F;删除develop分支</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"为项目添加-gitignore文件\"><a href=\"#为项目添加-gitignore文件\" class=\"headerlink\" title=\"为项目添加.gitignore文件\"></a>为项目添加.gitignore文件</h1><p>虽然上面的方法能帮助我们成功的将项目托管到GitHub上，但是总会遇到一些不完全如我们愿的事情。  </p>\n<p><center>![生成.gitigore文件之前](https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/gitignore之前.jpg?raw=true)</center><br>如图所示，我们把一个在eclipse上完成的项目上传到GitHub上。但是发现项目中的一些不想或者不必要上传的文件或文件夹也被上传了，例如其中的bin文件夹是存放由.java文件编译成的.class文件的地方，.class文件是虚拟机执行的文件，所以这是一个不必要上传的文件夹。事实上，如图中的bin文件夹、.setting文件夹、.classpath文件和.project文件都是不必要上传的。<br>怎么样能不上传这些文件和文件夹呢？一个不错的答案是每次使用<code>git add</code> 的时候手动添加文件盒文件夹，把这些文件不添加就行了。这可能在文件比较少的时候可行，如果遇到一个较大的项目，动辄几百个文件，手动添加就太耗费精力了，而且也没有必要。<br>其实Git已经给我们提供成熟的工具——<code>.gitignore</code> 文件，只要在<code>.gitignore</code> 文件中添加忽略路径就能达到有选择性的上传文件了，一起来学习一下。<br>在项目文件夹下打开git bash，输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch .gitignore    &#x2F;&#x2F;生成.gitigore文件</span><br></pre></td></tr></table></figure><br>之后.gitignore文件就由Git自动生成了，打开<code>.gitignore</code> 文件，我以上面图中的项目为例，在里面添加如下字段：</p>\n<blockquote>\n<p>bin/<br>.settings<br>.classpath<br>.project  </p>\n</blockquote>\n<p>这样上面提到的文件和文件夹都可以被过滤掉了。之后继续输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached .&#x2F;&#x2F;清空缓存      </span><br><span class=\"line\">git add .&#x2F;&#x2F;重新提交     </span><br><span class=\"line\">git commit -m &quot;update .gitignore&quot;       </span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure></p>\n<p>效果如图：  </p>\n<p><center>![生成.gitigore文件之后](https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/gitignore之后.jpg?raw=true)  </center><br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/gitignore%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99.jpg?raw=true\" alt=\"具体过滤规则\"></p>\n<h1 id=\"撤销未提交的修改\"><a href=\"#撤销未提交的修改\" class=\"headerlink\" title=\"撤销未提交的修改\"></a>撤销未提交的修改</h1><p>例如对<code>README.md</code>文件进行了修改，之后发现提交不必要，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- README.md</span><br></pre></td></tr></table></figure>\n<p>则能取消修改，回到之前文件未修改的状态。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>[1] <a href=\"https://zhidao.baidu.com/question/2053485325521871027.html\" target=\"_blank\" rel=\"noopener\">如何创建.gitignore文件，忽略不必要提交的文件</a><br>[2] <a href=\"http://blog.csdn.net/qq_32388047/article/details/67724085\" target=\"_blank\" rel=\"noopener\">git更新.gitignore后如何提交</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/04/%E6%88%91%E7%9A%84git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B2/","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"git","slug":"git","permalink":"https://stevehuge.gitee.io/blog/tags/git/"}]},{"title":"我的git使用教程1","date":"2017-05-03T15:00:48.000Z","path":"2017/05/03/我的git使用教程1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/Git.jpg?raw=true\" alt=\"Git\"></p>\n<h1 id=\"将一个项目放到GitHub上\"><a href=\"#将一个项目放到GitHub上\" class=\"headerlink\" title=\"将一个项目放到GitHub上\"></a>将一个项目放到GitHub上</h1><hr>\n<p>Git是一个分布式的代码托管仓库，是每个程序员必备的工具。<br><a id=\"more\"></a><br>前提：</p>\n<ul>\n<li>有一个GitHub账号</li>\n<li>本地已经安装Git</li>\n<li>github账号已经绑定本地ssh值</li>\n</ul>\n<p>这是后面步骤的基础，如果没有请参考此教程 <a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000\" target=\"_blank\" rel=\"noopener\" title=\"安装Git\">安装Git</a>，<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013752340242354807e192f02a44359908df8a5643103a000\" target=\"_blank\" rel=\"noopener\" title=\"Git添加远程仓库\">Git添加远程仓库</a>。</p>\n<p>步骤如下:<br>1.在github上新建一个repository,例如为“swordOffer”，带README.md文件；<br>2.在本地新建文件夹swordOffer，本地的swordOffer已存在的忽略这一步；<br>3.进入swordOffer；<br>4.在swordOffer文件夹内右键打开git bash；<br>5.现在我们github和本地都有文件夹swordOffer，不同的是github上文件夹内有README.md文件，而本地文件夹为空（或者有文件）；<br>6.在本地打开的git bash中输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure><br> 进行初始化本地git仓库，本地swordOffer文件夹内会出现一个隐藏的.git文件夹。这个文件夹是本地的仓库，动了会破坏本地仓库，所以不要动它；<br>7.之后我们要做的是将本地和远程联系起来：在远程仓库中找到其地址，例如我的是：<br><a href=\"https://github.com/StephenHuge/swordOffer.git\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/swordOffer.git</a> 。在git bash中输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;StephenHuge&#x2F;swordOffer.git</span><br></pre></td></tr></table></figure><br> 之后没有什么报错的话就是成功了，现在本地仓库和远程仓库绑到一起了；<br>8.由于远程仓库中相比本地仓库还有一个README.md文件，所以我们必须先将这个文件同步到本地，之后才能在本地进行添加上传动作。git bash中输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><br> pull是拉的意思，这个命令将README文件“拉”到本地来。此时本地会出现一个README文件。<br>9.之后我们就可以在本地添加代码了，写好之后，输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .\t&#x2F;&#x2F;添加修改</span><br></pre></td></tr></table></figure><br>进行添加修改，其中的<code>.</code>表示添加所有已编辑文件，然后输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;**&quot;\t\t&#x2F;&#x2F;提交修改，**为本次修改的大概描述</span><br></pre></td></tr></table></figure><br>进行提交，可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status\t\t&#x2F;&#x2F;查看Git状态</span><br></pre></td></tr></table></figure><br>来查看当前的Git状态，显示更改已经全部提交，之后输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure><br>push是推的意思，将本地代码“推”到远程仓库中。”-u”选项的意思是指定一个默认主机，第一次输入需要使用”-u”，以后可以不加任何参数使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure><br>或者<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure><br>进行提交。刷新github的页面，就会发现代码已经上传到远程仓库上了；<br>10.一段时间后又有新代码写好，要同步，add和commit按照第9步来，就可以直接推送了。<br>11.在github网页上改动了文件，需要同步到本地，本地应该怎么操作呢？在网页上修改了文件后，保存，然后在本地git bash中输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin</span><br></pre></td></tr></table></figure><br> 就完成了远程修改。  </p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/03/%E6%88%91%E7%9A%84git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B1/","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"git","slug":"git","permalink":"https://stevehuge.gitee.io/blog/tags/git/"}]},{"title":"使用Hexo+github搭建个人博客","date":"2017-05-01T10:11:35.000Z","path":"2017/05/01/使用Hexo-github搭建个人博客/","content":"<h1 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a><strong>环境搭建</strong></h1><p>使用Hexo+github搭建个人博客。<br><a id=\"more\"></a><br>由于本文只是一个对于搭建博客过程的记录而不是教程，所以仅供参考。想要详细的教程请参考参考文章中的第一篇。<br>需要的具体环境有：<br>Node.js<br>Git<br>GitHub账号<br>Hexo<br>简单介绍一下，Node.js 是一个Javascript运行环境，是一个基于Javascipt，性能十分优秀的前端框架。Git就不说了，是一个分布式的代码托管仓库。程序员必备工具，如果你还不会，赶紧去学，这里有篇很好的教程 <a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Git教程</a> 。<br><br>而GitHub是一个基于Git的线上代码托管仓库，你可以把你的代码上传到网站服务器进行托管。GitHub在这里充当的角色是服务器，通过访问你的线上仓库你就可以使用个人博客了~<br>当然只有这些还不够，之后是Hexo的安装，Hexo是一个开源的静态博客生成器，基于Node.js开发。安装结束后就可以进行博客的写作了。</p>\n<h1 id=\"个人博客的维护\"><a href=\"#个人博客的维护\" class=\"headerlink\" title=\"个人博客的维护\"></a><strong>个人博客的维护</strong></h1><p>这个部分可以分为两个部分：1.主题更换；2.发布文章。</p>\n<h2 id=\"主题更换\"><a href=\"#主题更换\" class=\"headerlink\" title=\"主题更换\"></a><strong>主题更换</strong></h2><p>主题就是基于个人博客的页面布局等具体结构的封装文件。每个不同的主题有不同的页面布置，操作方式等。<br>我用的主题是<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\" rel=\"noopener\">cafe</a>，将其下载下来放到Hexo安装目录下themes文件夹中，例如我的Hexo安装位置是G:\\Blog，cafe的位置是G:\\Blog\\themes\\cafe。<br>在Hexo中有两份配置文件，名称均为 _config.yml，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的各类选项。下面举例说明一下：<br>在G:\\Blog下的 _config.yml是整个<b>网站的配置文件</b>，而在G:\\Blog\\themes\\cafe\\下还有一个 _config.y文件，这个文件是cafe<b>主题的配置文件</b>。<br><b>主题配置文件</b>由主题作者提供，如何进行配置，主题作者都会在README中详细说明，例如主题cafe的 <a href=\"https://github.com/giscafer/hexo-theme-cafe/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">cafe的README文件</a>，故在此不再详述。<br>而<b>网站配置文件</b>是通用的。其中一般包括网站名称、作者（你的名字）、语言、友情链接等设置。其中重要的是两个：theme和repo（线上仓库的位置）。例如我的是：<br><img src=\"http://img.blog.csdn.net/20170501164908990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9tb255MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Hexo配置\"><br>其中theme是cafe，这样我就可以用cafe主题了。而deploy中type为git，repo为我自己在github中的io仓库。这样主题设置完成了。具体设置参见参考文章的第一个连接，其中有详细说明。</p>\n<h2 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a><strong>发布文章</strong></h2><p>新建一篇博客：<br>打开cmd（我用的是Windows，Linux用户直接Ctrl+Shift+T打开terminal），进入到Hexo的安装目录下，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>\n<p>其中<code>article title </code>是你的文章题目。这时候在安装目录下的source_posts文件夹下将看到  article title.md  文件，用MarkDown编辑器（我用的是MarkdownPad 2）打开就可以编辑文章了。文章编辑好之后保存，可以先预览一下我们写好的文章。运行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g\t&#x2F;&#x2F;部署文章</span><br><span class=\"line\">hexo server -p 4000\t&#x2F;&#x2F;打开本地server</span><br></pre></td></tr></table></figure><br>第二句执行完效果如图  </p>\n<center>![hexoServer](https://github.com/StephenHuge/Markdown_Pic/blob/master/我的Git教程/hexoServer.jpg?raw=true)</center>\n\n<p>第二句的操作的作用是打开本地的server。其中-p为设置端口（port）操作，数字4000为默认端口，如果端口4000被占用也可以用别的数字。<br>之后通过访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\" title=\"http://localhost:4000\">http://localhost:4000</a> 即可预览我们部署好的文章。如果有排版或内容问题则继续修改，在本地修改好之后，执行 <code>hexo g</code> 重新部署。确认无误后，在远程生成文章<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d\t&#x2F;&#x2F;生成</span><br></pre></td></tr></table></figure><br>部署成功后访问你的远程地址，例如我的是<a href=\"https://stephenhuge.github.io/\" target=\"_blank\" rel=\"noopener\">https://stephenhuge.github.io/</a>，打开就可以看到生成的文章了。<br>当然如果不需要在本地预览时，文章写好之后可以直接在git bash执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d -g &#x2F;&#x2F;在部署前生成</span><br></pre></td></tr></table></figure></p>\n<p>这句等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g\t&#x2F;&#x2F;部署\t</span><br><span class=\"line\">hexo d\t&#x2F;&#x2F;生成</span><br></pre></td></tr></table></figure>\n<p>之后访问远程地址也能看到生成好的文章。<br>ps:如果提示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deployer not found:git</span><br></pre></td></tr></table></figure>\n<p>则是没有安装扩展，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>即可。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a><strong>参考文章</strong></h1><p>[1] 安装教程  <a href=\"http://blog.csdn.net/gdutxiaoxu/article/details/53576018\" target=\"_blank\" rel=\"noopener\">手把手教你用Hexo+Github 搭建属于自己的博客</a></p>\n<p>[2] 主题配置 <a href=\"http://www.zipperary.com/2013/05/29/hexo-guide-3/\" target=\"_blank\" rel=\"noopener\">hexo系列教程：（三）hexo博客的配置、使用</a></p>\n<p>[3] 遇到各种问题  <a href=\"https://segmentfault.com/q/1010000003870970\" target=\"_blank\" rel=\"noopener\">使用localhost:4000访问本地blog一直无响应</a></p>\n<p>[4] 遇到各种问题  <a href=\"http://bbs.csdn.net/topics/390538669\" target=\"_blank\" rel=\"noopener\">网站处于联机状态,但未对连接尝试做出响应</a></p>\n<p><strong>扩展阅读</strong></p>\n<p><a href=\"http://baixin.io/2016/10/jekyll_tutorials1/\" target=\"_blank\" rel=\"noopener\">Jekyll搭建个人博客</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/01/%E4%BD%BF%E7%94%A8Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"hexo","permalink":"https://stevehuge.gitee.io/blog/tags/hexo/"}]}]