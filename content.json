[{"title":"Hello World","date":"2020-06-30T13:43:16.739Z","path":"2020/06/30/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2020/06/30/hello-world/","tags":[]},{"title":"Java中Lambda表达式的常见用法","date":"2018-07-21T13:20:47.000Z","path":"2018/07/21/Java中Lambda表达式的常见用法/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/lambda.jpg?raw=true\" alt=\"lambda\"></p>\n<p>Java在1.8版本中新增了对Lambda表达式的支持，通过Lambda表达式，软件开发人员可以更加便利地实现之前操作麻烦的操作，如针对某种特定的规则对集合进行排序等，Lambda表达式使得程序变得简洁而更加易于理解。</p>\n<a id=\"more\"></a>\n\n<p>Lambda表达式通常要配合流（Stream）进行使用，常见获得流的方式有以下几种方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从Collection和数组</span></span><br><span class=\"line\">Collection.stream()</span><br><span class=\"line\">Collection.parallelStream()</span><br><span class=\"line\">Arrays.stream(T array) or Stream.of()</span><br><span class=\"line\"><span class=\"comment\">// 从 BufferedReader</span></span><br><span class=\"line\">java.io.BufferedReader.lines()</span><br><span class=\"line\"><span class=\"comment\">// 静态工厂</span></span><br><span class=\"line\">java.util.stream.IntStream.range()</span><br><span class=\"line\">java.nio.file.Files.walk()</span><br><span class=\"line\"><span class=\"comment\">// 自己构建</span></span><br><span class=\"line\">java.util.Spliterator</span><br><span class=\"line\"><span class=\"comment\">// 其它</span></span><br><span class=\"line\">Random.ints()</span><br><span class=\"line\">BitSet.stream()</span><br><span class=\"line\">Pattern.splitAsStream(java.lang.CharSequence)</span><br><span class=\"line\">JarFile.stream()</span><br></pre></td></tr></table></figure>\n\n<p>而对于流的操作也可以分为三种：</p>\n<ul>\n<li><strong>Intermediate</strong>：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</li>\n<li><strong>Terminal</strong>：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li>\n<li><strong>Short-circuiting</strong>：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</li>\n</ul>\n<p>区别是：</p>\n<ul>\n<li><p><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>\n</li>\n<li><p><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>\n</li>\n<li><p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指：</p>\n<ul>\n<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>\n<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>\n</ul>\n<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>\n</li>\n</ul>\n<h1 id=\"1-常用的方法\"><a href=\"#1-常用的方法\" class=\"headerlink\" title=\"1. 常用的方法\"></a>1. 常用的方法</h1><h3 id=\"1-filter-方法\"><a href=\"#1-filter-方法\" class=\"headerlink\" title=\"1. filter()方法\"></a>1. filter()方法</h3><p>例如获取list中满足特定条件的子list</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; a = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">a.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">a.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">a.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">a.add(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取list中满足特定条件的子list</span></span><br><span class=\"line\">List&lt;Integer&gt; b = a.stream().filter(x -&gt; x &gt; <span class=\"number\">5</span>)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-allMatch-amp-anyMatch-amp-nonMatch-方法\"><a href=\"#2-allMatch-amp-anyMatch-amp-nonMatch-方法\" class=\"headerlink\" title=\"2. allMatch() &amp; anyMatch() &amp; nonMatch() 方法\"></a>2. allMatch() &amp; anyMatch() &amp; nonMatch() 方法</h3><p>返回值是boolean类型的，满足条件则返回true，否则返回false<br>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; a = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">     a.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">     a.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">     a.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">     a.add(<span class=\"number\">100</span>);</span><br><span class=\"line\">     <span class=\"comment\">// 判断是否满足特定条件</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (a.stream().allMatch(x -&gt; x &gt; <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"all greater than 5\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"not all greater than 5\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-map-方法\"><a href=\"#3-map-方法\" class=\"headerlink\" title=\"3. map()方法\"></a>3. map()方法</h3><p>传入的方法会对当前Stream进行操作，之后得到新的元素组成一个流作为该方法的返回值。</p>\n<p>进行数据重新装配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 匿名内部类必须在后一个&lt;&gt;中添加类型</span></span><br><span class=\"line\">  List&lt;Fruit&gt; fruits = <span class=\"keyword\">new</span> ArrayList&lt;Fruit&gt;() &#123;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          add(<span class=\"keyword\">new</span> Fruit(<span class=\"string\">\"苹果\"</span>, <span class=\"number\">1.25</span>));</span><br><span class=\"line\">          add(<span class=\"keyword\">new</span> Fruit(<span class=\"string\">\"香蕉\"</span>, <span class=\"number\">0.99</span>));</span><br><span class=\"line\">          add(<span class=\"keyword\">new</span> Fruit(<span class=\"string\">\"梨\"</span>, <span class=\"number\">1.02</span>));</span><br><span class=\"line\">          add(<span class=\"keyword\">new</span> Fruit(<span class=\"string\">\"西瓜\"</span>, <span class=\"number\">2.03</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 生成新的String类型的list</span></span><br><span class=\"line\">  List&lt;String&gt; fruitNames = fruits.stream()</span><br><span class=\"line\">          .map(f -&gt; f.getName()).collect(Collectors.toList());</span><br><span class=\"line\">  <span class=\"comment\">// for (String f : fruitNames) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     System.out.println(f);</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  \tfruitNames.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-distinct-方法\"><a href=\"#4-distinct-方法\" class=\"headerlink\" title=\"4. distinct()方法\"></a>4. distinct()方法</h3><p>去除集合中重复的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">20</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">30</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; newNums = nums.stream().distinct().collect(Colletors.toList());</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-forEach-方法\"><a href=\"#5-forEach-方法\" class=\"headerlink\" title=\"5. forEach()方法\"></a>5. forEach()方法</h3><p>可以直接使用forEach()方法遍历集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; users = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Leo\"</span>));</span><br><span class=\"line\">users.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-Lambda表达式实战\"><a href=\"#2-Lambda表达式实战\" class=\"headerlink\" title=\"2. Lambda表达式实战\"></a>2. Lambda表达式实战</h2><ul>\n<li>拿出两个list中重复的值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   List&lt;User&gt; users1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">   users1.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">   users1.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">   users1.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>));</span><br><span class=\"line\">   users1.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Leo\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;User&gt; users2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">   users2.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>));</span><br><span class=\"line\">   users2.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Sam\"</span>));</span><br><span class=\"line\">   users2.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Amy\"</span>));</span><br><span class=\"line\">   users2.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Leo\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// filter传入一个Predicate（谓词类型）（boolean返回值的函数），之后嵌套一个使用anyMatch作为判断条件的Stream完成逻辑</span></span><br><span class=\"line\">   List&lt;User&gt; intersection = users1.stream().filter(u1 -&gt; users2.stream().anyMatch(u2 -&gt; u2.getName().equals(u1.getName()))).collect(Collectors.toList());</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (User u : intersection) &#123;</span><br><span class=\"line\">       System.out.println(u);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据特定的条件去重</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   List&lt;User&gt; users = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">   users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">   users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">   users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>));</span><br><span class=\"line\">   users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Leo\"</span>));</span><br><span class=\"line\">   <span class=\"comment\">// 根据特定的条件进行去重</span></span><br><span class=\"line\">List&lt;User&gt; distinctUsers = users.stream()</span><br><span class=\"line\">               .filter(distinctByKey(User::getName))</span><br><span class=\"line\">               .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (User u : distinctUsers) &#123;</span><br><span class=\"line\">         System.out.println(u);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Predicate&lt;T&gt; <span class=\"title\">distinctByKey</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;</span><br><span class=\"line\">       Map&lt;Object, Boolean&gt; seen = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> object -&gt; seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; users = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jim\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Simon\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Amy\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"AMY\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"TOM\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"BOB\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Steve\"</span>));</span><br><span class=\"line\">users.add(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Leo\"</span>));</span><br><span class=\"line\">Comparator&lt;User&gt; comparator = (u1, u2) -&gt; u1.getName().compareTo(u2.getName());</span><br><span class=\"line\">users.stream()</span><br><span class=\"line\">    <span class=\"comment\">// 倒序</span></span><br><span class=\"line\">    .sorted(comparator.reversed())</span><br><span class=\"line\">    <span class=\"comment\">// 顺序</span></span><br><span class=\"line\"><span class=\"comment\">//  .sorted((u1, u2) -&gt; u1.getName().compareTo(u2.getName()))</span></span><br><span class=\"line\">    .map(User::getName).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ol>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/\" target=\"_blank\" rel=\"noopener\">Java 8 中的 Streams API 详解</a></li>\n</ol>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2018/07/21/Java%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"Lambda表达式","slug":"Lambda表达式","permalink":"https://stevehuge.gitee.io/blog/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"sort","slug":"sort","permalink":"https://stevehuge.gitee.io/blog/tags/sort/"}]},{"title":"Java反射初探 -- 1","date":"2018-04-23T08:09:25.000Z","path":"2018/04/23/Java反射初探 -- 01/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/refletion_top2.jpg?raw=true\" alt=\"反射\"></p>\n<h1 id=\"0-反射是什么\"><a href=\"#0-反射是什么\" class=\"headerlink\" title=\"0. 反射是什么\"></a>0. 反射是什么</h1><p>一般Java类的运行是在代码中声明并实例化后才可以被使用的，而很多时候不能先直接去声明和实例化（为了解耦等原因）。Java为我们提供了一个工具：反射（Reflection）。</p>\n<a id=\"more\"></a>\n<p>反射是一组在包<code>java.lang.reflect</code> 下的API，这组API可以获取某个对象的变量、方法、构造方法，实现的接口等信息。而所有的行为都是在程序 <strong>运行时</strong> 实现的，一般代码运行是在编译时即完成。<br>反射有以下功能：</p>\n<ol>\n<li>获取判断对象的类型；</li>\n<li>获取类的所有变量、构造方法、方法；</li>\n<li>获取类继承的超类或实现的接口。<br>…<br>接下来学习一下反射中常用的工具类。</li>\n</ol>\n<h1 id=\"1-Class类\"><a href=\"#1-Class类\" class=\"headerlink\" title=\"1. Class类\"></a>1. Class类</h1><h2 id=\"1-1-Class类是什么\"><a href=\"#1-1-Class类是什么\" class=\"headerlink\" title=\"1.1 Class类是什么\"></a>1.1 Class类是什么</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Instances of the class &#123;@code Class&#125; represent classes and</span><br><span class=\"line\"> * interfaces in a running Java application.  An enum is a kind of</span><br><span class=\"line\"> * class and an annotation is a kind of interface.  Every array also</span><br><span class=\"line\"> * belongs to a class that is reflected as a &#123;@code Class&#125; object</span><br><span class=\"line\"> * that is shared by all arrays with the same element type and number</span><br><span class=\"line\"> * of dimensions.  The primitive Java types (&#123;@code boolean&#125;,</span><br><span class=\"line\"> * &#123;@code byte&#125;, &#123;@code char&#125;, &#123;@code short&#125;,</span><br><span class=\"line\"> * &#123;@code int&#125;, &#123;@code long&#125;, &#123;@code float&#125;, and</span><br><span class=\"line\"> * &#123;@code double&#125;), and the keyword &#123;@code void&#125; are also</span><br><span class=\"line\"> * represented as &#123;@code Class&#125; objects.</span><br><span class=\"line\"> *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这是JDK中对于Class类的简单介绍。其中说程序中的类和接口可以用Class类的实例对象表示。个人理解是Class类类似一个“元类”，其它所有类（这里不包括Object类）都是Class类的一个实例，而这些类又可以有自己的实例。如下代码可能有助于理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;String&gt; c = String<span class=\"class\">.<span class=\"keyword\">class</span></span>;\t<span class=\"comment\">// String.class是Class类的实例</span></span><br><span class=\"line\">String s = <span class=\"keyword\">new</span> String();\t    <span class=\"comment\">// s是String类的实例</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么Object类要单独拿出来，我现在还不能很清楚的表述出来，这个问题应该在学习完.class文件的结构后得到答案，此处不想多提，但是有兴趣的同学可以参考知乎上的这篇撒迦大大的<a href=\"https://www.zhihu.com/question/30301819\" target=\"_blank\" rel=\"noopener\">回答</a>，对于这个问题有十分详细而精彩的解答。</p>\n<h2 id=\"1-2-Class类的作用\"><a href=\"#1-2-Class类的作用\" class=\"headerlink\" title=\"1.2 Class类的作用\"></a>1.2 Class类的作用</h2><p>Class类的作用就在于它提供的许多API，这些API可以让Java程序员很方便地使用完成特定的功能。</p>\n<p>先来看个例子：如何获取一个Class对象呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"haha\"</span>);</span><br><span class=\"line\">Class&lt;?&gt; c1 = String<span class=\"class\">.<span class=\"keyword\">class</span>\t\t// 直接声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Class</span>&lt;?&gt; <span class=\"title\">c2</span> </span>= s.getClass();\t\t<span class=\"comment\">// 通过实例对象获取其class</span></span><br><span class=\"line\">Class&lt;?&gt; c3 = Class.forName(</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"java.lang.String\"</span>);\t<span class=\"comment\">// 通过Class类的forName()方法获取class</span></span><br></pre></td></tr></table></figure>\n\n<p>以上有三种方法实例化一个Class对象，前两种很直接也很简单，但是都需要导入明确的类，如果某个类操作不明确，使用会造成很大不便。第三章虽然较为复杂，但是只需要传入一个字符串作为参数，方法灵活性很高，给实际操作带来了更大的空间，它可能抛出一个<code>ClassNotFoundException</code> 异常（代码中未体现）。</p>\n<p>Class类的实例表示Java应用运行时的类(class and enum)或接口(interface and annotation)，每个java类运行时都在JVM里表现为一个Class对象，可通过</p>\n<ul>\n<li>类名.class</li>\n<li>类型.getClass()</li>\n<li>Class.forName(“类名”)</li>\n</ul>\n<p>等方法获取Class对象。</p>\n<p>数组同样也被映射为为Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p>\n<p>基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 Class  对象。</p>\n<p>当然，Class类的作用远不止于此，它还可以获取Class对象的所有变量、构造方法、方法，继承的超类或实现的接口，以及标注于其上的注解等等。在下一节中会总结一些常用的方法。</p>\n<h2 id=\"1-3-Class类的常用方法\"><a href=\"#1-3-Class类的常用方法\" class=\"headerlink\" title=\"1.3 Class类的常用方法\"></a>1.3 Class类的常用方法</h2><p>篇幅所限，略去方法所抛异常和修饰符。</p>\n<p>表1 常用方法1</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">返回值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">forName(String className)</td>\n<td align=\"center\">Class&lt;?&gt;</td>\n<td align=\"center\">传完成的“包.类”名称实例化Class对象</td>\n</tr>\n<tr>\n<td align=\"center\">getName()</td>\n<td align=\"center\">String</td>\n<td align=\"center\">得到完整的“包.类”名称</td>\n</tr>\n<tr>\n<td align=\"center\">getPackage()</td>\n<td align=\"center\">Package</td>\n<td align=\"center\">得到一个类的包</td>\n</tr>\n<tr>\n<td align=\"center\">newInstance()</td>\n<td align=\"center\">T</td>\n<td align=\"center\">根据Class定义的类实例化对象</td>\n</tr>\n<tr>\n<td align=\"center\">isArray()</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">判断此Class是否是一个数组</td>\n</tr>\n</tbody></table>\n<p>表2 常用方法2</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">返回值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getAnnotations()</td>\n<td align=\"center\">Annotation[]</td>\n<td align=\"center\">得到修饰一个类所有注解</td>\n</tr>\n<tr>\n<td align=\"center\">getConstructors()</td>\n<td align=\"center\">Constructor&lt;?&gt;[]</td>\n<td align=\"center\">得到一个类中所有的构造方法</td>\n</tr>\n<tr>\n<td align=\"center\">getFields()</td>\n<td align=\"center\">Field[]</td>\n<td align=\"center\">得到本类继承得来的全部属性</td>\n</tr>\n<tr>\n<td align=\"center\">getInterfaces[]</td>\n<td align=\"center\">Class&lt;?&gt;[]</td>\n<td align=\"center\">得到本类实现的全部接口</td>\n</tr>\n<tr>\n<td align=\"center\">getMethods()</td>\n<td align=\"center\">Method[]</td>\n<td align=\"center\">得到本类继得来的全部方法</td>\n</tr>\n<tr>\n<td align=\"center\">getDeclaredAnnotations()</td>\n<td align=\"center\">Annotation[]</td>\n<td align=\"center\">得到修饰一个类所有注解</td>\n</tr>\n<tr>\n<td align=\"center\">getDeclaredConstructors()</td>\n<td align=\"center\">Constructor&lt;?&gt;[]</td>\n<td align=\"center\">得到本类全部构造方法</td>\n</tr>\n<tr>\n<td align=\"center\">getDeclaredFields()</td>\n<td align=\"center\">Field[]</td>\n<td align=\"center\">得到本类单独定义的全部属性</td>\n</tr>\n<tr>\n<td align=\"center\">getDeclaredMethods()</td>\n<td align=\"center\">Method[]</td>\n<td align=\"center\">得到本类单独定义的全部方法</td>\n</tr>\n<tr>\n<td align=\"center\">getSuperClass()</td>\n<td align=\"center\">Class&lt;? super T&gt;</td>\n<td align=\"center\">得到本类的父类</td>\n</tr>\n<tr>\n<td align=\"center\">getComponentType()</td>\n<td align=\"center\">Class&lt;?&gt;</td>\n<td align=\"center\">返回表示数组类型的Class</td>\n</tr>\n</tbody></table>\n<p>方法非常多，此处仅列举部分常见的。</p>\n<p>此处还有一个知识点：<code>Class&lt;?&gt;</code>和<code>Class&lt;T&gt;</code>的区别。</p>\n<blockquote>\n<p>单独的T 代表一个类型，而 Class<T>和Class<?>代表这个类型所对应的类。 Class<T>在实例化的时候，T要替换成具体类；而Class<?>它是个通配泛型，?可以代表任何类型。<br><? extends T>受限统配，表示T的一个未知子类。\n<? super T>下限统配，表示T的一个未知父类。\npublic T find(Class<T> clazz, int id)，根据类来反射生成一个实例，而单独用T没法做到。\nObject类中包含一个方法名叫getClass，利用这个方法就可以获得一个实例的Class对象。Class对象指的是代表一个类型的对象，因为一切皆是对象，类型也不例外，在Java使用Class对象来表示一个类型。所有的Class对象都是Class类的实例。getClass() 会看到返回Class<?>。<br>JDK中，普通的Class.newInstance()方法的定义返回Object，要将该返回类型强制转换为另一种类型，但是使用泛型的Class<T>，Class.newInstance()方法具有一个特定的返回类型。</p>\n</blockquote>\n<h1 id=\"2-参考文章\"><a href=\"#2-参考文章\" class=\"headerlink\" title=\"2. 参考文章\"></a>2. 参考文章</h1><p>【1】 <a href=\"http://blog.sina.com.cn/s/blog_605f5b4f0100i77k.html\" target=\"_blank\" rel=\"noopener\">Reflections中的getDeclared<strong>与get</strong>的区别</a> </p>\n<p>【2】 <a href=\"https://blog.csdn.net/witewater/article/details/53462385\" target=\"_blank\" rel=\"noopener\">T和Class<T>以及Class&lt;?&gt;的理解</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2018/04/23/Java%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%20--%2001/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"算法4（Algorithms4）- Part 5 图（Graph）-无向图（Undirected Graph）1","date":"2017-11-10T13:30:23.000Z","path":"2017/11/10/算法4（Algorithms4）- Part 5 图（Graph）-无向图（Undirected Graph）1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/TOP.JPG?raw=true\" alt=\"\"></p>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><p>图（Graph）的概念: 图是由一组顶点（vertices）和一组能够将两个顶点相连的边（edges）组成的。</p>\n<a id=\"more\"></a>\n<h2 id=\"和图相关的术语\"><a href=\"#和图相关的术语\" class=\"headerlink\" title=\"和图相关的术语\"></a>和图相关的术语</h2><p>路径（Path）：由边连接的顶点序列<br>环（Cycle）： 第一个和最后一个顶点相同的路径</p>\n<p>如果在两个顶点之间有一条路径，就称它们是连接的。</p>\n<h1 id=\"2-图的API\"><a href=\"#2-图的API\" class=\"headerlink\" title=\"2. 图的API\"></a>2. 图的API</h1><p>怎么用代码表现图呢？<br>下图是一个图的两种画法，虽然是同一个图，但视觉上可能相差很大，所以除了肉眼，我们需要更精确的模型来描述它。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/1.JPG?raw=true\" alt=\"\"></p>\n<p>我们需要做的是表示顶点和对应的边。<br>在应用中可以使用符号表（symbol table）表示顶点名称与数字之间的对应关系。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/2.JPG?raw=true\" alt=\"\"></p>\n<p>在本课程中，使用<code>0</code> 到 <code>V - 1</code>之间数字表示顶点，如上图。</p>\n<p>在图中有时候会有一些特殊情况，例如下图是一个自环和平行边的示意图。但是本课程中一般都不涉及自环和平行边的判定或者其它操作，默认图中没有这两种情况，如果有会说明。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/3.JPG?raw=true\" alt=\"\"></p>\n<p>这是图的API 和一些典型的方法，包括两个构造方法和一些常见操作，如：添加一条边，获取某个顶点的相邻点，得到顶点和边的数量等。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/4.JPG?raw=true\" alt=\"\"></p>\n<p>一些常见的方法，包含获取某个顶点的度（也就是和它相连的点的个数），图中度最大的顶点，所有顶点的平均度数以及自环的个数。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/5.JPG?raw=true\" alt=\"\"></p>\n<p>顶点的度（degree）:和每个顶点相连的顶点的个数称之为该顶点的度。</p>\n<p>具体的问题：用什么数据结构表示边呢？<br>可以使用集合将边作为一个数据类型存储起来，当然弊端就是想找某个具体的点所在的边就必须遍历整个集合，这是不能接受的。</p>\n<p>可以使用邻接矩阵，也就是有<code>V</code>个顶点，使用<code>V * V</code>大小的二维<code>boolean</code>矩阵<code>adj</code>，其中所有值默认为<code>false</code>。当某两个顶点v和w相连时，同时将<code>adj[v][w]</code>和<code>adj[w][v]</code>置为<code>true</code>。这样操作弊端是大量空间被浪费，因为一般图中边较为稀疏，而且数据多了一倍的冗余，遍历起来也非常慢，所以这种方法被舍弃了。</p>\n<p>更有效率的方法是邻接表（Adjacency-list）：<br>也是<code>V</code>个顶点，创建一个长度为<code>V</code>的链表类型的数组，其中每个链表存储和数组下标代表的顶点相邻的点，从而可以表示边。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/6.JPG?raw=true\" alt=\"\"></p>\n<p>这能满足内存要求，也能满足速度要求。</p>\n<p>邻接表和用来表示边的其它数据结构的比较：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/8.JPG?raw=true\" alt=\"\"></p>\n<p>以下是使用邻接表之后的Graph的API：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/7.JPG?raw=true\" alt=\"\"></p>\n<h1 id=\"3-深度优先搜索（depth-first-search）\"><a href=\"#3-深度优先搜索（depth-first-search）\" class=\"headerlink\" title=\"3. 深度优先搜索（depth - first - search）\"></a>3. 深度优先搜索（depth - first - search）</h1><p>深度优先搜索是一个经典的递归算法（遍历所有顶点和边）。要搜索一幅图，只需要一个递归方法来遍历所有顶点。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/9.JPG?raw=true\" alt=\"\"></p>\n<p>这种方法被称为深度优先搜索（<code>DFS</code>）。它使用一个<code>boolean</code>数组来记录和起点连通的所有顶点，递归方法会标记给定的顶点，并调用该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。</p>\n<p>具体步骤为，在访问其中一个顶点时：</p>\n<ul>\n<li>将它标记为已访问</li>\n<li>递归地访问它的所有没有被标记过的邻居顶点<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/10.JPG?raw=true\" alt=\"\"></li>\n</ul>\n<p>怎么用代码实现呢？<br>选择一： 把它写到<code>Graph</code>里面，作为一个方法<br>选择二： 单独作为一个类，把<code>Graph</code>作为构造方法的参数传入</p>\n<p>根据设计模式中的<strong>单一职责原则</strong>，选择二是更好的做法，我们对选择二进行实现。</p>\n<p>将<code>Graph</code>的API和对<code>Graph</code>进行操作的代码（除了基本操作）分开是比较好的选择。例如我们想要在<code>Graph</code>中找到一条特定的路径（先不管这条路径的要求），我们可以先确定一个大概我们要实现的API：</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/11.JPG?raw=true\" alt=\"\"></p>\n<p>之后是确定路径的具体寻找方式，这节是深度优先搜索，所以根据DFS实现算法：</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/12.JPG?raw=true\" alt=\"\"></p>\n<p>在<code>DFS</code>之后，可以在常数时间内找到与<code>s</code>相连的顶点并能找到一条它和<code>s</code>相连的路径。</p>\n<p>其中数组<code>marked</code>记录某个数是否和顶点<code>s</code>相连，例如<code>marked[1] == true</code>，则说明<code>s</code>和顶点<code>1</code>相连。 <code>edgeTo</code>数组则记录了其父顶点的位置，例如下图，<code>edgeTo[1] == 2</code>，则说明顶点<code>1</code>的父节点是<code>2</code>，在这个树中，根顶点是<code>s</code>，在<code>edgeTo</code>中下标为<code>0</code>，依次类推。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part5/UndirectedGraph/13.JPG?raw=true\" alt=\"\"></p>\n<p>以上是深度优先搜索的内容。</p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/11/10/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%205%20%E5%9B%BE%EF%BC%88Graph%EF%BC%89-%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%88Undirected%20Graph%EF%BC%891/","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法4","slug":"算法4","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%954/"},{"name":"Graph","slug":"Graph","permalink":"https://stevehuge.gitee.io/blog/tags/Graph/"}]},{"title":"LaTeX简介及其在Mardown中的用法","date":"2017-11-04T14:21:11.000Z","path":"2017/11/04/LaTeX简介及其在Mardown中的用法/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Tools/LaTeX/top.jpg?raw=true\" alt=\"\"></p>\n<h1 id=\"1-LaTeX-是什么？\"><a href=\"#1-LaTeX-是什么？\" class=\"headerlink\" title=\"1. $\\LaTeX$是什么？\"></a>1. $\\LaTeX$是什么？</h1><p>在介绍$\\LaTeX$之前，我们得知道什么是$\\TeX$。</p>\n<h2 id=\"TeX\"><a href=\"#TeX\" class=\"headerlink\" title=\"$\\TeX$\"></a>$\\TeX$</h2><p>$\\TeX$（希腊语：/tɛx/，音译“泰赫”，文本模式下写作TeX），是一个由美国计算机教授高德纳（Donald Ervin Knuth）编写的功能强大的排版软件。它在学术界十分流行，特别是数学、物理学和计算机科学界。$\\TeX$被普遍认为是一个优秀的排版工具，特别是在处理复杂的数学公式时。利用诸如是$\\LaTeX$等终端软件，$\\TeX$就能够排版出精美的文本以帮助人们辨认和查找。</p>\n<p>高德纳（Donald Knuth,1938/01/10 -）最早开始自行编写 $\\TeX$ 的原因，是因为当时的排版技术十分粗糙，已经影响到他的巨著《计算机程序设计艺术》的印刷质量。他以典型的黑客思维模式，决定自行编写一个排版软件：$\\TeX$。他原本以为他只需要半年时间，在1978年下半年就能完成，但最终他用了超过十年时间，直到1989年$\\TeX$才最终停止修改。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"LaTeX\"><a href=\"#LaTeX\" class=\"headerlink\" title=\"$\\LaTeX$\"></a>$\\LaTeX$</h2><p>$\\LaTeX$（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/），文字形式写作LaTeX，是一种基于$\\TeX$的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由$\\TeX$所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学、化学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。<br>$\\LaTeX$使用$\\TeX$作为它的格式化引擎，当前的版本是$\\LaTeX2_ε$。</p>\n<p>$\\LaTeX$ 本质上是用编程语言写成的一个“$\\TeX$ 宏包”，它扩展了 $\\TeX$ 的功能，使我们很方便的逻辑的进行创作而不是专心于字体，缩进这些烦人的东西。</p>\n<h1 id=\"2-LaTeX-能干什么？\"><a href=\"#2-LaTeX-能干什么？\" class=\"headerlink\" title=\"2. $\\LaTeX$能干什么？\"></a>2. $\\LaTeX$能干什么？</h1><p>$\\LaTeX$能较为友好的在网页或者文档中显示出规范整洁的各类公式和符号，例如<br>$$<br>\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}<br>$$</p>\n<p>$\\log_3 G$， $\\Omega (N^2)$ $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p>\n<p>这些公式都是通过$\\LaTeX$实现的，对应的$\\LaTeX$语句如下：</p>\n<p><code>$$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$$</code></p>\n<p><code>$\\log_3 G$</code></p>\n<p><code>$\\Omega (N^2)$</code></p>\n<p><code>$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</code></p>\n<p>可以发现，有些公式和正常文字一样，有些却是在页面正中间。这是行内公式和行间公式的区别，对应到语法上就是行内公式使用<code>$formula$</code>，而行间公式使用<code>$$formula$$</code>， <code>formula</code>代表公式的内容。</p>\n<p>$\\LaTeX$的功能远不止这么简单，很多高级数学公式例如求和，求积以及一些复杂的物理公式都可以用其表示。</p>\n<h1 id=\"3-LaTeX-在Markdown中的用法\"><a href=\"#3-LaTeX-在Markdown中的用法\" class=\"headerlink\" title=\"3. $\\LaTeX$在Markdown中的用法\"></a>3. $\\LaTeX$在Markdown中的用法</h1><p>先说$\\LaTeX$的简单用法：</p>\n<ol>\n<li>在数学公式中，经常用到 <strong>上标和下标</strong>，在LaTeX语法中对应<code>^</code>和<code>-</code>。例如<code>x_i^2</code> : $x_i^2$, <code>\\log_2 N</code> : $\\log_2 N$。</li>\n<li><strong>分组</strong>，简单来说就是当遇到下标或者上标不是单字符时会用到，例如 $x_{a1}^2$, 用式子<code>x_a1^2</code>会得出错误的公式$x_a1^2$。由于这时<code>a</code>和<code>1</code>属于同一组，所以需要声明它们是一起的。$\\LaTeX$中使用大括号<code>{}</code>将同一组的符号括到一起。刚才的式子正确表示是<code>x_{a1}^2</code>。</li>\n<li><strong>括号</strong>，如果式子中本来就有括号<code>()[]{}</code>，那么使用时<code>()[]</code>正常使用即可，而<code>{}</code>在括号之前需要加转义符<code>\\</code>。例如$(2 + 3)[4 + 4]{5 + 6}$ : <code>(2 + 3)[4 + 4]\\{5 + 6\\}</code>。</li>\n<li><strong>分数</strong>，分数通过<code>\\frac{}{}</code>实现。例如 $\\frac{3}{5}$ : <code>\\frac{3}{5}</code>。稍微复杂的分数也能表示</li>\n</ol>\n<p>$$\\frac{\\log_2 N + N^3}{\\ln N - 2N^2}$$ 式子是<code>\\frac{\\log_2 N + N^3}{\\ln N - 2N^2}</code>。</p>\n<p>在Markdown中可以使用<code>$formula$</code>或<code>$$formula$$</code>插入公式，也可以使用<code>\\\\(formula\\\\)</code>插入，但是由于Hexo使用的markdown解析引擎的问题，后一种时有出错，推荐使用第一种方式。</p>\n<h1 id=\"4-附录\"><a href=\"#4-附录\" class=\"headerlink\" title=\"4. 附录\"></a>4. 附录</h1><p> <strong>常见函数</strong>表达方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数名称</th>\n<th align=\"center\">函数符号</th>\n<th align=\"center\">表达方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">根号</td>\n<td align=\"center\">$\\sqrt3$</td>\n<td align=\"center\"><code>\\sqrt3</code></td>\n</tr>\n<tr>\n<td align=\"center\">求和</td>\n<td align=\"center\">$\\sum_{i=0}^N i$</td>\n<td align=\"center\"><code>\\sum_{i=0}^N i</code></td>\n</tr>\n<tr>\n<td align=\"center\">求积</td>\n<td align=\"center\">$\\prod_{0}^5 a$</td>\n<td align=\"center\"><code>\\prod_{0}^5 a</code></td>\n</tr>\n<tr>\n<td align=\"center\">积分</td>\n<td align=\"center\">$\\int_{0}^\\infty x^3$</td>\n<td align=\"center\"><code>\\int_{0}^\\infty x^3</code></td>\n</tr>\n<tr>\n<td align=\"center\">多次开方</td>\n<td align=\"center\">$\\sqrt[3]{\\frac xy}$</td>\n<td align=\"center\"><code>\\sqrt[3]{\\frac xy}</code></td>\n</tr>\n<tr>\n<td align=\"center\">三角函数</td>\n<td align=\"center\">$\\sin$, $\\cos$, $\\tan$</td>\n<td align=\"center\"><code>\\sin</code>, <code>\\cos</code>, <code>\\tan</code></td>\n</tr>\n<tr>\n<td align=\"center\">极限</td>\n<td align=\"center\">$\\lim_{x\\to0}$</td>\n<td align=\"center\"><code>\\lim_{x\\to0}</code></td>\n</tr>\n<tr>\n<td align=\"center\">对数函数</td>\n<td align=\"center\">$\\log_5 x$, $\\ln y$</td>\n<td align=\"center\"><code>\\log_5 x</code>, <code>\\ln y</code></td>\n</tr>\n</tbody></table>\n<p> <strong>常见符号</strong>表示方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号名称</th>\n<th align=\"center\">符号</th>\n<th align=\"center\">表达方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">希腊字母</td>\n<td align=\"center\">$ \\alpha$, $\\beta$, …, $\\omega$</td>\n<td align=\"center\">\\alpha, \\beta, …, \\omega</td>\n</tr>\n<tr>\n<td align=\"center\">希腊字母大写</td>\n<td align=\"center\">$\\Gamma$, $\\Delta$, …, $\\Omega$</td>\n<td align=\"center\">\\Gamma, \\Delta, …, \\Omega</td>\n</tr>\n<tr>\n<td align=\"center\">比较符</td>\n<td align=\"center\">$\\lt$ $\\gt$ $\\le$ $\\ge$ $\\neq$</td>\n<td align=\"center\">\\lt \\gt \\le \\ge \\neq</td>\n</tr>\n<tr>\n<td align=\"center\">运算符</td>\n<td align=\"center\">$\\times$ $\\div$ $\\pm$ $\\mp$</td>\n<td align=\"center\">\\times \\div \\pm \\mp</td>\n</tr>\n<tr>\n<td align=\"center\">常见数学符号1</td>\n<td align=\"center\">$\\cup$ $\\cap$ $\\setminus$ $\\subset$ $\\subseteq$ $\\subsetneq$ $\\supset$ $\\in$ $\\notin$ $\\emptyset$ $\\varnothing$</td>\n<td align=\"center\">\\cup \\cap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing</td>\n</tr>\n<tr>\n<td align=\"center\">常见数学符号2</td>\n<td align=\"center\">$\\land$ $\\lor$ $\\lnot$ $\\forall$ $\\exists$ $\\top$ $\\bot$ $\\vdash$ $\\vDash$</td>\n<td align=\"center\">\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash</td>\n</tr>\n<tr>\n<td align=\"center\">箭头</td>\n<td align=\"center\">$\\to$ $\\rightarrow$ $\\leftarrow$ $\\Rightarrow$ $\\Leftarrow$ $\\mapsto$</td>\n<td align=\"center\">\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto</td>\n</tr>\n</tbody></table>\n<p>在<a href=\"http://docs.mathjax.org/en/latest/tex.html#supported-latex-commands\" target=\"_blank\" rel=\"noopener\"> list of currently supported LATEXLATEX commands</a>中有更多$\\LaTeX$ 支持的语法。</p>\n<h1 id=\"5-遇到的问题\"><a href=\"#5-遇到的问题\" class=\"headerlink\" title=\"5. 遇到的问题\"></a>5. 遇到的问题</h1><p>刚开始使用的时候，经常发现页面中的公式解析出错，例如<code>_</code>在Hexo中会生成<em>斜体的字符</em>，在$\\LaTeX$中生成的$是_{下标}$。这就导致了矛盾。<br>可行的解决方法有两个：</p>\n<ul>\n<li>更换Hexo的markdown引擎。Hexo自带的引擎是 <code>hexo-renderer-marked</code>，可以换成功能更强大的Pandoc。   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save   &#x2F;&#x2F; 卸载旧的引擎</span><br><span class=\"line\">npm install hexo-renderer-pandoc --save     &#x2F;&#x2F; 安装pandoc</span><br></pre></td></tr></table></figure></li>\n<li>手动修改Hexo渲染源码</li>\n</ul>\n<p>修改hexo的渲染源码: 打开<code>nodes_modules/marked/lib/marked.js</code>:<br>第一步: 去掉\\的额外转义。 先备份一下，然后修改第449行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: &#x2F;^\\\\([\\\\&#96;*&#123;&#125;\\[\\]()# +\\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure>\n<p>改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: &#x2F;^\\\\([&#96;*&#123;&#125;\\[\\]()# +\\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure>\n<p>这样就会去掉\\的转义了。<br>第二步:将<code>em</code>标签对应的符号中，去掉<code>_</code>。第459行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: &#x2F;^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;,</span><br></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em:&#x2F;^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)&#x2F;,</span><br></pre></td></tr></table></figure>\n<p>因为markdown中有<code>*</code>可以表示斜体，<code>_</code>就去掉了,这样问题就解决了。</p>\n<p>这部分参考天空的城的<a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/#\" target=\"_blank\" rel=\"noopener\">Hexo下mathjax的转义问题</a>。</p>\n<h1 id=\"参考网站\"><a href=\"#参考网站\" class=\"headerlink\" title=\"参考网站\"></a>参考网站</h1><p>[1] <a href=\"https://www.mathjax.org/\" target=\"_blank\" rel=\"noopener\">mathjax官网</a><br>[2] <a href=\"https://zh.wikipedia.org/wiki/TeX\" target=\"_blank\" rel=\"noopener\">TeX维基百科</a><br>[3] <a href=\"https://zh.wikipedia.org/wiki/LaTeX\" target=\"_blank\" rel=\"noopener\">LaTeX维基百科</a><br>[3] <a href=\"https://github.com/hexojs/hexo/issues/524\" target=\"_blank\" rel=\"noopener\">Github上的issue</a><br>[4] <a href=\"https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax basic tutorial and quick reference</a><br>[5] <a href=\"https://www.zhihu.com/question/31298277/answer/275151599\" target=\"_blank\" rel=\"noopener\">知乎上的公式是怎么打出来的？</a><br>[6] <a href=\"https://segmentfault.com/q/1010000003987383\" target=\"_blank\" rel=\"noopener\">hexo 如何解决markdown下划线要加反斜杠，以及如何使用其他markdown的渲染引擎？</a><br>[7] <a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/#\" target=\"_blank\" rel=\"noopener\">Hexo下mathjax的转义问题</a><br>[8] <a href=\"http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/\" target=\"_blank\" rel=\"noopener\">如何处理Hexo和MathJax的兼容问题</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/11/04/LaTeX%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%9C%A8Mardown%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/","tags":[{"name":"工具","slug":"工具","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://stevehuge.gitee.io/blog/tags/LaTeX/"},{"name":"markdown","slug":"markdown","permalink":"https://stevehuge.gitee.io/blog/tags/markdown/"}]},{"title":"算法4（Algorithms4） - Part 2 快速排序（Quick Sort）","date":"2017-10-29T07:50:50.000Z","path":"2017/10/29/算法4（Algorithms4）- Part 2 快速排序（QuickSort）/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/top.jpg?raw=true\" alt=\"\"></p>\n<h1 id=\"1-快速排序\"><a href=\"#1-快速排序\" class=\"headerlink\" title=\"1. 快速排序\"></a>1. 快速排序</h1><p>快速排序的基本思路是：</p>\n<ul>\n<li><strong>随机打乱（Shuffle）</strong>数组</li>\n<li><strong>分割（Partition）</strong>数组<ul>\n<li>第<code>j</code>个元素处于正确的位置</li>\n<li>在第<code>j</code>个元素的左边的所有元素都比第<code>j</code>个元素小</li>\n<li>在第<code>j</code>个元素的右边的所有元素都比第<code>j</code>个元素大</li>\n</ul>\n</li>\n<li>对由第<code>j</code>个元素分割成的两部分<strong>递归执行（Sort recursively）</strong>上述部分，直到数组有序</li>\n</ul>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/1.JPG?raw=true\" alt=\"\"></p>\n<p>分割操作的代码如下，其执行过程和上述说明一致。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/2.JPG?raw=true\" alt=\"\"></p>\n<p>下面是快速排序的代码。其中对数组<code>partition</code>之后的两部分递归执行了<code>sort</code>方法，当子数组长度为1时，递归停止。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/3.JPG?raw=true\" alt=\"\"></p>\n<p>下面是快速排序的轨迹，可以看到，当子数组长度为1时，没有执行<code>partition</code>操作。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/4.JPG?raw=true\" alt=\"\"></p>\n<h1 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2. 分析\"></a>2. 分析</h1><p>已知</p>\n<ul>\n<li>个人电脑每秒能执行 \\(10^8\\) 次比较</li>\n<li>超级电脑每秒能执行 \\(10^{12}\\) 次比较、</li>\n</ul>\n<p>根据简单的测试和计算，可以得出比较插入排序，归并排序和快速排序的运行时间。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/5.JPG?raw=true\" alt=\"\"></p>\n<p>最好的情况是比较次数为~\\(N \\lg N\\)。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/6.JPG?raw=true\" alt=\"\"></p>\n<p>最差的情况是比较次数为~\\(\\frac{1}{2} N ^ 2\\)。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/7.JPG?raw=true\" alt=\"\"></p>\n<h2 id=\"平均情况分析\"><a href=\"#平均情况分析\" class=\"headerlink\" title=\"平均情况分析\"></a>平均情况分析</h2><p>结论：对于任意长度为<code>N</code>，且无重复元素的数组， <code>Quicksort</code> 的平均比较次数\\(C_N\\)为<del>\\(2N \\ln N\\)，交换次数为</del>\\(\\frac{1}{3}N \\ln N\\)。<br>证明过程如下：</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/8.JPG?raw=true\" alt=\"\"></p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/quicksort/9.JPG?raw=true\" alt=\"\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1] <a href=\"http://algs4.cs.princeton.edu/\" target=\"_blank\" rel=\"noopener\">Algorithms, 4th Edition</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/29/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%202%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88QuickSort%EF%BC%89/","tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://stevehuge.gitee.io/blog/tags/Sorting/"},{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法4","slug":"算法4","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%954/"},{"name":"分治法","slug":"分治法","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"算法4（Algorithms4） - Part 2 归并排序（Merge Sort）","date":"2017-10-25T07:58:59.000Z","path":"2017/10/25/算法4（Algorithms4）- Part 2 归并排序（MergeSort）/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortTop.jpg?raw=true\" alt=\"\"></p>\n<hr>\n<h1 id=\"1-经典归并排序\"><a href=\"#1-经典归并排序\" class=\"headerlink\" title=\"1. 经典归并排序\"></a>1. 经典归并排序</h1><p>首先我们解释一下这里归并（merge）的意思：</p>\n<ul>\n<li>两个<strong>有序</strong>的数组<code>a1</code>和<code>a2</code>，长度分别为<code>h1</code>和<code>h2</code>。</li>\n<li>新建一个长度为<code>h1 + h2</code> 的空数组。</li>\n<li>将<code>a1</code>和<code>a2</code>中的所有元素按照升序排列到数组<code>a</code>中。</li>\n</ul>\n<p>这个操作称为<code>a1</code>和<code>a2</code>的归并。merge也有合并、融合的意思。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/merge.jpg?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>归并排序的思路：</p>\n<ol>\n<li>将要排序的数组分为两等分。</li>\n<li>对得到的子数组递归执行第一步，直到不能再等分。</li>\n<li>对第二步得到的两部分进行<strong>归并</strong>，完成递归。</li>\n</ol>\n<p>我们看详细步骤。</p>\n<h2 id=\"1-merge\"><a href=\"#1-merge\" class=\"headerlink\" title=\"1. merge\"></a>1. merge</h2><video src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/22DemoMerge.mov?raw=true\" controls=\"controls\" style=\"max-width: 100%; display: block; margin-left: auto; margin-right: auto;\">\nyour browser does not support the video tag\n</video>\n\n<p>上面是归并操作的一个小视频，说明了归并完成的过程，实际相当简单，我们直接上代码<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/merge-code.jpg?raw=true\" alt=\"\"></p>\n<p>在方法<code>merge</code>方法中传入两个数组，<code>a</code>是要排序的，另外一个<code>aux</code>（auxiliary）作为辅助数组。其余三个参数<code>lo</code>，<code>mid</code>，<code>hi</code>分别代表要处理的数组部分的左边界，中点以及右边界。<br>代码中用了Java中的<code>assert</code>，也就是断言判定<code>merge</code>的两部分是否有序，如果不满足<code>assert</code>的条件，代码执行时会抛出异常。运行时通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -ea XX.java</span><br></pre></td></tr></table></figure>\n<p>开启断言（默认关闭）。</p>\n<h2 id=\"2-sort\"><a href=\"#2-sort\" class=\"headerlink\" title=\"2. sort\"></a>2. sort</h2><p><code>MergeSort</code>中的<code>sort</code>方法递归将数组分为两个更小的数组片段，直到不能再分，之后对这两个片段执行<code>merge</code>操作，最终完成排序操作。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortjava.jpg?raw=true\" alt=\"\"></p>\n<p>以下是<code>MergeSort</code>的运行过程，我们可以看到，递归执行的过程是从左到右依次进行。最终得到一个排好序的数组。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesorttrace.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"3-分析\"><a href=\"#3-分析\" class=\"headerlink\" title=\"3. 分析\"></a>3. 分析</h2><p>已知</p>\n<ul>\n<li>个人电脑每秒能执行 \\(10^8\\) 次比较</li>\n<li>超级电脑每秒能执行 \\(10^{12}\\) 次比较、</li>\n</ul>\n<p>根据简单的测试和计算，可以得出比较插入排序和归并排序的运行时间。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesort-insertionsort.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"归并排序：比较次数和数组访问次数\"><a href=\"#归并排序：比较次数和数组访问次数\" class=\"headerlink\" title=\"归并排序：比较次数和数组访问次数\"></a>归并排序：比较次数和数组访问次数</h3><p>结论：对于任意长度为<code>N</code>的数组， <code>Mergesort</code> 最多有 \\(N\\lg N\\) 次比较和 6 \\(N\\lg N\\) 数组访问。</p>\n<p>证明： 比较次数为\\(C(N)\\)，数组访问次数为\\(A(N)\\)，则\\(C(N)\\)和\\(A(N)\\)满足：<br>\\(N\\) &gt; 1时，\\(C(N)\\) ≤ $C (⎡N / 2⎤)$ + $C (⎣N / 2⎦)$ +  \\(N\\)，  其中初始条件为 \\(C(1)\\) = 0.<br> \\(N\\) &gt; 1时，\\(A(N)\\) ≤ $A (⎡N / 2⎤)$ + $A (⎣N / 2⎦)$ + 6 \\(N\\) ，其中初始条件 \\(A(1)\\) = 0.</p>\n<p>现在需要解决的问题是针对一个递归数列，假设N为2的幂。<br>满足条件<br>\\(N\\) &gt; 1时，\\(D(N)\\) = \\(D({N/2})\\) + \\(N\\), 初始条件为\\(D(1)\\) = 0<br>可以通过分析得出结论：\\(D(N)\\) = \\(N \\lg N\\)<br>通过图示表示为：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/proofofmergersortnlogn.jpg?raw=true\" alt=\"\"><br>通过不断带入也能得出相同结论:<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/proofofmergersortnlogn2.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"归并排序的内存使用\"><a href=\"#归并排序的内存使用\" class=\"headerlink\" title=\"归并排序的内存使用\"></a>归并排序的内存使用</h3><p>结论：<code>MergeSort</code>使用的空间和数组长度<code>N</code>成正比。<br>证明：显然，<code>aux</code>数组长度必须为<code>N</code>，以确保最后一次归并成功。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortmemoryanalysis.jpg?raw=true\" alt=\"\"></p>\n<p>这里涉及到一个概念：原地排序（in-place sort）。如果排序算法占用空间 ≤ \\(c \\log N\\)，则称它是一个原地排序算法。常见的例子有：插入排序，选择排序和希尔排序。</p>\n<p>归并排序是稳定的排序。</p>\n<h2 id=\"4-改进\"><a href=\"#4-改进\" class=\"headerlink\" title=\"4. 改进\"></a>4. 改进</h2><h3 id=\"小数组时，使用插入排序代替归并排序\"><a href=\"#小数组时，使用插入排序代替归并排序\" class=\"headerlink\" title=\"小数组时，使用插入排序代替归并排序\"></a>小数组时，使用插入排序代替归并排序</h3><ul>\n<li>数组长度较小时，归并排序的开支过大。</li>\n<li>当数组长度小于<code>7</code>时，会使用插入排序</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortImprovement.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"如果数组已经排好序，则跳过排序\"><a href=\"#如果数组已经排好序，则跳过排序\" class=\"headerlink\" title=\"如果数组已经排好序，则跳过排序\"></a>如果数组已经排好序，则跳过排序</h3><ul>\n<li>先进行判断：第一部分的最大值是否小于第二部分的最小值?</li>\n<li>针对部分有序的数组<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortImprovement2.jpg?raw=true\" alt=\"\"></li>\n</ul>\n<h3 id=\"优化数组复制\"><a href=\"#优化数组复制\" class=\"headerlink\" title=\"优化数组复制\"></a>优化数组复制</h3><p>在替换输入数组和辅助数组后，可以节约一定的时间，但是空间占用不会有变。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortImprovement3.jpg?raw=true\" alt=\"\"></p>\n<h1 id=\"2-自底向上的归并排序（非递归）\"><a href=\"#2-自底向上的归并排序（非递归）\" class=\"headerlink\" title=\"2. 自底向上的归并排序（非递归）\"></a>2. 自底向上的归并排序（非递归）</h1><p>排序过程如图所示。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortBUtrace.jpg?raw=true\" alt=\"\"></p>\n<p>代码<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergesortBUJava.jpg?raw=true\" alt=\"\"><br>相比递归式的<code>MergeSort</code>，实现相对简单，但是性能在典型系统中大约下降了<code>10%</code>。<br>通过下图可以看出：<br>自底向上和自顶向下的<code>MergeSort</code>的排序顺序不同，传统的递归方式是先将数组分为两部分，选择数组的前一部分，并不断递归，直到前面的子数组不能再分，然后在开始排序；<br>而非递归式的则是现对所有的最小子数组进行排序，再相邻的两两归并，最后完成排序。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/mergersortBUVisualization.jpg?raw=true\" alt=\"\"></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/25/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%202%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88MergeSort%EF%BC%89/","tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://stevehuge.gitee.io/blog/tags/Sorting/"},{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法4","slug":"算法4","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%954/"},{"name":"分治法","slug":"分治法","permalink":"https://stevehuge.gitee.io/blog/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"算法4（Algorithms4） - Part 2 初级排序（Elementary Sorts）2","date":"2017-10-22T14:57:09.000Z","path":"2017/10/22/算法4（Algorithms4）- Part 2 初级排序（Elementary Sorts）2/","content":"<h1 id=\"3-插入排序（Insertion-Sort）\"><a href=\"#3-插入排序（Insertion-Sort）\" class=\"headerlink\" title=\"3. 插入排序（Insertion Sort）\"></a>3. 插入排序（Insertion Sort）</h1><h2 id=\"3-1-步骤\"><a href=\"#3-1-步骤\" class=\"headerlink\" title=\"3.1 步骤\"></a>3.1 步骤</h2><p>插入排序的步骤：</p>\n<ul>\n<li>设定一个变量<code>i</code>，默认<code>i</code>下标之前的元素全部是已经排好序的，<code>i</code>从<code>0</code>开始</li>\n<li>从<code>i - 1</code>开始，<code>a[i]</code>不断向前比较，如果下标<code>i - 1</code>的数比它大，则<code>a[i]</code>和它交换</li>\n<li>之后不断向前比较，如果前面的元素比<code>a[i]</code>大，则<code>a[i]</code>和它交换。 <code>i - 2, i - 3, ..., i - k</code>。直到<code>i - k == 0</code>或者下标为<code>i - k</code>的元素比<code>a[i]</code>小，此时停止交换</li>\n<li><code>i</code>自增，直到遍历数组所有下标<a id=\"more\"></a>\n\n</li>\n</ul>\n<p>可以看下图，下图满足的条件是：</p>\n<ul>\n<li>在箭头<code>↑</code> 左边的元素（包括箭头<code>↑</code> ）是有序而且递增</li>\n<li>所有在箭头<code>↑</code> 右边的元素都还没有被检验，处于无序状态</li>\n</ul>\n<p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion</a> 1.jpg?raw=true)</p>\n<h2 id=\"3-2-内部循环\"><a href=\"#3-2-内部循环\" class=\"headerlink\" title=\"3.2 内部循环\"></a>3.2 内部循环</h2><p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion</a> - sort inner loop.jpg?raw=true)<br>图中是内部循环，分两步</p>\n<ol>\n<li>将指针往右移动一步</li>\n<li>不断和指针前面的元素比较，如果比指针所指元素大就交换</li>\n</ol>\n<h2 id=\"3-3-Java实现\"><a href=\"#3-3-Java实现\" class=\"headerlink\" title=\"3.3 Java实现\"></a>3.3 Java实现</h2><p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion</a> sort - java impl.jpg?raw=true)</p>\n<h2 id=\"3-4-数学分析\"><a href=\"#3-4-数学分析\" class=\"headerlink\" title=\"3.4 数学分析\"></a>3.4 数学分析</h2><p>通过上面的分析和代码，我们发现 </p>\n<ul>\n<li>对一个随机分布而且没有重复的数组来说，插入排序比较次数为<del>\\(\\frac{N ^ 2}{4}\\)， 交换次数为</del>\\(\\frac{N ^ 2}{4}\\)<br>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion</a> sort - analysis.jpg?raw=true)<br>简单证明：如果数组随机分布，那么每次平均要比较和交换的次数都应该是前面所有数个数的一半。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/insertion%20sort%20analysis2.jpg?raw=true\" alt=\"\"><h2 id=\"3-5-最优情况和最劣情况\"><a href=\"#3-5-最优情况和最劣情况\" class=\"headerlink\" title=\"3.5 最优情况和最劣情况\"></a>3.5 最优情况和最劣情况</h2></li>\n</ul>\n<p>最优： 如果数组已经排好序了，插入排序比较次数为 <code>N - 1</code>， 交换次数为<code>0</code>（这是一个十分惊人的成绩）</p>\n<p>最劣： 如果数组逆序排列，而且没有重复的话，插入排序比较次数为 <del>\\(\\frac{N ^ 2}{2}\\)， 交换次数为</del>\\(\\frac{N ^ 2}{2}\\)</p>\n<h2 id=\"3-6-部分有序（partially-sorted）的数组\"><a href=\"#3-6-部分有序（partially-sorted）的数组\" class=\"headerlink\" title=\"3.6 部分有序（partially - sorted）的数组\"></a>3.6 部分有序（partially - sorted）的数组</h2><p>定义： 逆序对（inversion）, 即为序列中没有按顺序排列的数据对，如图所示其中有6个逆序对。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/inversion.jpg?raw=true\" alt=\"\"></p>\n<p>定义： 一个数组，如果它内部的逆序对数为<code>c N</code> ，则它是部分有序的。</p>\n<p>命题： 对于部分有序的数组来说，插入排序运行时间是线性的。</p>\n<p>简单证明：事实上，交换次数就是逆序对的次数。（比较次数为交换次数 + (N - 1)）</p>\n<h1 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4. 小结\"></a>4. 小结</h1><p>选择排序和插入排序相比：</p>\n<ul>\n<li>如果按照比较次数来计算性能（数组访问次数），插入排序的性能平均为选择排序的2倍</li>\n<li>如果要排序的数组部分有序，插入排序能达到线性时间的性能</li>\n<li>如果要排序的数组倒序，插入排序的性能会很差，而选择排序不受影响</li>\n</ul>\n<h1 id=\"5-希尔排序（Shell-Sort）\"><a href=\"#5-希尔排序（Shell-Sort）\" class=\"headerlink\" title=\"5. 希尔排序（Shell Sort）\"></a>5. 希尔排序（Shell Sort）</h1><p>插入排序中，有时候我们知道当前元素要比较的次数可能不止一个，但是它仍然会和之前所有比它大的元素进行比较，性能上其实是有提升空间的，我们希望它可以每次“跳着比”，每次和前面隔几个元素的元素进行比较，但是如何保证正确性呢？有人也想到了这个问题，这就是有名的 <code>h - sorting</code> 。<br>每次当前元素和之前相隔<code>h</code>距离的元素进行比较，并进行“插入排序”，如图所示。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/h-sorting1.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"5-1-希尔排序\"><a href=\"#5-1-希尔排序\" class=\"headerlink\" title=\"5.1 希尔排序\"></a>5.1 希尔排序</h2><p>希尔排序（<code>Shell - Sort</code>），由希尔（Shell）在1959年发现。它的基本思想是：对数组进行<code>h - sort</code>，并逐渐减小<code>h</code>的值，这样就能保证排序的正确性。</p>\n<p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell</a> sort1.jpg?raw=true)</p>\n<h2 id=\"5-2-h-sorting\"><a href=\"#5-2-h-sorting\" class=\"headerlink\" title=\"5.2 h -sorting\"></a>5.2 h -sorting</h2><p><code>h-sort</code>，就是插入排序的改进版，只不过跨度为<code>h</code>，如图为<code>3 - sort</code> 。<br>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/3\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/3</a> - sorting.jpg?raw=true)<br>为什么使用插入排序？</p>\n<ul>\n<li><strong>大跨度的话 =&gt; 子数组很小，每次排序的次数很少</strong></li>\n<li>*<em>小跨度的话 =&gt; 数组经过大跨度排序，已经基本有序 *</em></li>\n</ul>\n<p>下图是一个Shell Sort增量分别为7，3，1的例子<br>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell</a> sort increments7 3 1.jpg?raw=true)</p>\n<p>命题： 一个<code>g- sort</code>之后的数组，在经历过<code>h -sort</code>之后，仍然是<code>g - sort</code>的。<br>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/h\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/h</a> sorting g sorting.jpg?raw=true)</p>\n<h2 id=\"5-3-跨度选择\"><a href=\"#5-3-跨度选择\" class=\"headerlink\" title=\"5.3 跨度选择\"></a>5.3 跨度选择</h2><p>选择有很多种</p>\n<ul>\n<li><p><code>2的幂</code>：1， 2， 4， 8，16，32…<br>不好，因为它会导致奇数项和偶数项得不到充分交换，实际操作中性能不高</p>\n</li>\n<li><p><code>3x + 1</code>: 1, 4, 13, 40, 121, 364…<br>可以使用。计算很简单，这也是高德纳（Donald Knuth）使用的方式</p>\n</li>\n<li><p><code>Sedgewick</code>: 1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905, …<br>$(9 * 4i) – (9 * 2i) + 1$ 与$4i – (3 * 2i) + 1$的合并，性能很好，在实证研究中很难被超越</p>\n</li>\n</ul>\n<h2 id=\"5-4-Java实现\"><a href=\"#5-4-Java实现\" class=\"headerlink\" title=\"5.4 Java实现\"></a>5.4 Java实现</h2><p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell</a> sort java impl.jpg?raw=true)</p>\n<h2 id=\"5-4-分析\"><a href=\"#5-4-分析\" class=\"headerlink\" title=\"5.4 分析\"></a>5.4 分析</h2><p>命题： 最差情况中，跨度为<code>3x + 1</code> 的希尔排序的比较次数为 \\(O (N ^ \\frac{3}{2})\\)。</p>\n<p>如图是经过大量实践得出的近似表格。可以看出希尔排序的性能近似于\\(N ^ {1.289}\\)或者\\(2.5 N \\log N\\)。</p>\n<p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/shell</a> sort analysis.jpg?raw=true)</p>\n<p>最后要说明的一点是：到现在还没有精确的数组模型描述希尔排序！</p>\n<h2 id=\"5-5-小结\"><a href=\"#5-5-小结\" class=\"headerlink\" title=\"5.5 小结\"></a>5.5 小结</h2><p>希尔排序证明了，简单的想法也能实现困难的问题。</p>\n<p>希尔排序在实践中十分常用</p>\n<ul>\n<li>如果数组不大，则非常快（常用于子数组，使用在linux内核中）</li>\n<li>很简洁，代码逻辑也相对简单（常用于嵌入式系统中）</li>\n<li>硬件中排序的原型</li>\n</ul>\n<p>希尔排序中还有很多疑问：</p>\n<ul>\n<li>渐进式的增长率</li>\n<li>最好的跨度？</li>\n<li>平均性能？</li>\n</ul>\n<p>从希尔排序中我们可以看出，有许多好的算法还等待我们去发现。</p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/22/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%202%20%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%EF%BC%88Elementary%20Sorts%EF%BC%892/","tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://stevehuge.gitee.io/blog/tags/Sorting/"},{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法4（Algorithms4） - Part 2 初级排序（Elementary Sorts）1","date":"2017-10-22T13:57:09.000Z","path":"2017/10/22/算法4（Algorithms4）- Part 2 初级排序（Elementary Sorts）1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/top2.jpg?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h1 id=\"1-游戏规则\"><a href=\"#1-游戏规则\" class=\"headerlink\" title=\"1. 游戏规则\"></a>1. 游戏规则</h1><h2 id=\"1-1-排序问题\"><a href=\"#1-1-排序问题\" class=\"headerlink\" title=\"1.1 排序问题\"></a>1.1 排序问题</h2><p>举例： 大学中学生的信息<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF.JPG?raw=true\" alt=\"\"></p>\n<p><strong>排序</strong>： 对N个数组中的记录重新组合，让其按递增顺序排列。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF-%E6%8E%92%E5%BA%8F%E5%90%8E.jpg?raw=true\" alt=\"\"></p>\n<p>我们的目标： 能对<strong>任意类型</strong>的数据排序。</p>\n<p>下图是分别对<code>Double</code>， <code>String</code>和<code>File</code>类型的数组进行排序。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/sorttype1.jpg?raw=true\" alt=\"\"><br>图 <code>Double</code>数组排序<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/sorttype2.jpg?raw=true\" alt=\"\"><br>图 <code>String</code>数组排序<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/sorttype3.jpg?raw=true\" alt=\"\"><br>图 <code>File</code>类型排序</p>\n<h2 id=\"1-2-函数回调（Callback）\"><a href=\"#1-2-函数回调（Callback）\" class=\"headerlink\" title=\"1.2 函数回调（Callback）\"></a>1.2 函数回调（Callback）</h2><p>问题来了：我们并不知道这三种类型的具体内容，sort()为什么可以进行排序？</p>\n<p>这里需要引入一个概念：函数回调（Callback）。<br>函数回调就是可执行代码的一个引用，什么意思呢？</p>\n<ul>\n<li>客户端将数组作为参数传给<code>sort()</code>方法</li>\n<li><code>sort()</code>方法在需要时，回调数组的元素类<code>compareTo()</code>方法</li>\n</ul>\n<p>这就是回调的意思。</p>\n<p>下面是回调的过程<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/callback.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"1-3-全序关系（Total-Order）\"><a href=\"#1-3-全序关系（Total-Order）\" class=\"headerlink\" title=\"1.3 全序关系（Total Order）\"></a>1.3 全序关系（Total Order）</h2><p>全序关系就是 二元关系，满足以下条件：</p>\n<ul>\n<li>反对称性（Antisymmetry）: 如果 <code>v ≤ w</code> 且 <code>w ≤ v</code>, 那么 <code>v = w</code></li>\n<li>传递性（Transitivity）: 如果 <code>v ≤ w</code> 且 <code>w ≤ x</code>, 那么 <code>v ≤ x</code></li>\n<li>总体性（Totality）: 要么 <code>v ≤ w</code> 成立， 要么 <code>w ≤ v</code> 成立， 要么二者都成立（即<code>v = w</code>）</li>\n</ul>\n<p>满足全序关系的例子有很多，例如：</p>\n<ul>\n<li>自然数或者实数的顺序</li>\n<li>时间或者日期按照发生先后排序</li>\n<li><code>string</code>按照字母表排序</li>\n<li>…</li>\n</ul>\n<p>当然，不满足全序关系的例子也存在：</p>\n<ul>\n<li>猜拳（违反了传递性）</li>\n<li>&lt;= 对<code>Double</code>类型不是全序关系（违反了总体性， <code>Double.NaN &lt;= Double.NaN</code> 为<code>false</code>）</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/scissors.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"1-4-Comparable接口\"><a href=\"#1-4-Comparable接口\" class=\"headerlink\" title=\"1.4 Comparable接口\"></a>1.4 Comparable接口</h2><p>参见<a href=\"https://stephenhuge.github.io/2017/10/19/Java%E4%B8%AD%E7%9A%84Comparable%E6%8E%A5%E5%8F%A3%E5%92%8CComparator%E6%8E%A5%E5%8F%A3/#Comparable\" target=\"_blank\" rel=\"noopener\">Java中的Comparable<T>接口和Comparator<T>接口</a> 。</p>\n<h1 id=\"2-选择排序（Selection-Sort）\"><a href=\"#2-选择排序（Selection-Sort）\" class=\"headerlink\" title=\"2. 选择排序（Selection Sort）\"></a>2. 选择排序（Selection Sort）</h1><h2 id=\"2-1-步骤\"><a href=\"#2-1-步骤\" class=\"headerlink\" title=\"2.1 步骤\"></a>2.1 步骤</h2><p>选择排序的步骤：</p>\n<ul>\n<li>设定一个变量<code>i</code>，然后对数组下标为 <code>i + 1</code> 到 <code>N - 1</code>的元素进行寻找，找到其中最小值的下标<code>min</code></li>\n<li>交换<code>a[i]</code>和<code>a[min]</code></li>\n<li><code>i</code>增加<code>1</code>，重复上述过程，直到 <code>i == N - 1</code></li>\n</ul>\n<p>可以看下图，下图满足的条件是：</p>\n<ul>\n<li>在箭头<code>↑</code> 左边的元素（包括箭头<code>↑</code> ）是有序而且递增</li>\n<li>所有在箭头<code>↑</code> 右边的元素都比在箭头<code>↑</code> 的元素小</li>\n</ul>\n<p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection</a> - sort1.jpg?raw=true)</p>\n<h2 id=\"2-2-内部循环\"><a href=\"#2-2-内部循环\" class=\"headerlink\" title=\"2.2 内部循环\"></a>2.2 内部循环</h2><p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection</a> - inner loop.jpg?raw=true)<br>图中是内部循环，分三步</p>\n<ol>\n<li>将指针往右移动一步</li>\n<li>找出指针右面最小元素的下标</li>\n<li>指针所指的元素和最小元素交换</li>\n</ol>\n<h2 id=\"2-3-Java实现\"><a href=\"#2-3-Java实现\" class=\"headerlink\" title=\"2.3 Java实现\"></a>2.3 Java实现</h2><p>![](<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection</a> - java impl.jpg?raw=true)</p>\n<h2 id=\"2-4-数学分析\"><a href=\"#2-4-数学分析\" class=\"headerlink\" title=\"2.4 数学分析\"></a>2.4 数学分析</h2><p>通过上面的分析和代码，我们发现 </p>\n<ul>\n<li>选择排序的比较次数为 <code>(N – 1) + (N – 2) + ... + 1 + 0</code>~ \\(\\frac{N ^ 2}{2}\\)  ，交换次数为<code>N</code>。</li>\n<li>对输入不敏感：运行时间为平方级（Quadratic），即使数组是已经经过排序的</li>\n<li>交换次数是最少的：只需要交换<code>N</code>次<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part2/selection%20-%20analysis.jpg?raw=true\" alt=\"\"></li>\n</ul>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/22/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%202%20%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%EF%BC%88Elementary%20Sorts%EF%BC%891/","tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://stevehuge.gitee.io/blog/tags/Sorting/"},{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java中的Comparable接口和Comparator接口","date":"2017-10-19T14:00:53.000Z","path":"2017/10/19/Java中的Comparable接口和Comparator接口/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/JDK%E6%BA%90%E7%A0%81/Comparable&Comparator/top.jpg?raw=true\" alt=\"\"></p>\n<p>最近Algorithms 4 课上提到了排序。趁着这个机会，梳理一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><p><code>Comparable&lt;T&gt;</code>接口和<code>Comparator&lt;T&gt;</code>接口都是JDK中提供的和比较相关的接口。使用它们可以对<strong>对象进行比较大小，排序</strong>等操作。这算是之后排序的先导知识吧。<br><code>Comparable</code>， 字面意思是“可以比较的”，所以实现它的类的多个实例应该可以相互比较“大小”或者“高低”等等。<br><code>Comparator</code>， 字面意思是“比较仪，比较器”， 它应该是专门用来比较用的“工具”。</p>\n<h1 id=\"2-Comparable\"><a href=\"#2-Comparable\" class=\"headerlink\" title=\"2. Comparable\"></a>2. Comparable</h1><p><code>Comparable&lt;T&gt;</code>接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(T o)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先看看JDK中怎么说的：</p>\n<blockquote>\n<p> This interface imposes a total ordering on the objects of each class that implements it.  This ordering is referred to as the class’s <i>natural ordering</i>, and the class’s <tt>compareTo</tt> method is referred to as its <i>natural comparison method</i>.<p></p>\n</blockquote>\n<p>大意是: 任何实现这个接口的类，其多个实例能以固定的次序进行排列。次序具体由接口中的方法<code>compareTo</code>方法决定。  </p>\n<blockquote>\n<p>Lists (and arrays) of objects that implement this interface can be sorted automatically by {@link Collections#sort(List) Collections.sort} (and {@link Arrays#sort(Object[]) Arrays.sort}).  </p>\n</blockquote>\n<p>如果某个类实现了这个接口，则它的<code>List</code>或数组都能使用<code>Collections.sort()</code>或<code>Arrays.sort()</code>进行排序。<br>常见的类如<code>Integer</code>, <code>Double</code>, <code>String</code>都实现了此类。一会儿会结合源码进行分析。</p>\n<h2 id=\"2-1-Integer类中Comparable接口的实现\"><a href=\"#2-1-Integer类中Comparable接口的实现\" class=\"headerlink\" title=\"2.1 Integer类中Comparable接口的实现\"></a>2.1 Integer类中Comparable接口的实现</h2><p>我们先来看<code>Integer</code>中的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Integer anotherInteger)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compare(<span class=\"keyword\">this</span>.value, anotherInteger.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (x &lt; y) ? -<span class=\"number\">1</span> : ((x == y) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareUnsigned</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compare(x + MIN_VALUE, y + MIN_VALUE);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们只贴出了和比较相关的方法。<br>可以看到，<code>compareTo</code>方法其中调用了<code>compare</code>方法，这是JDK1.7增加的方法。在<code>Integer</code>中新增这个方法是为了减少不必要的自动装箱拆箱。传入<code>compare</code>方法的是两个<code>Integer</code>的值<code>x</code>和<code>y</code>。<br>如果<code>x &lt; y</code>， 返回<code>-1</code>；如果<code>x = y</code>， 返回<code>0</code>；如果<code>x &gt; y</code>， 返回<code>1</code>。<br>顺便一说，JDK中的实现非常简洁，只有一行代码， 当判断情况有三种时，使用这种嵌套的判断 <code>x ? a : b</code> 可以简洁不少，这是该学习的。</p>\n<p>后面的<code>compareUnsigned</code>是JDK1.8新加入的方法, 用来比较无符号数。这里的无符号数意思是默认二进制最高位不再作为符号位，而是计入数的大小。<br>其实现是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareUnsigned</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> compare(x + MIN_VALUE, y + MIN_VALUE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接为每个值加了<code>Integer</code>的最小值 -2<sup>31</sup>。我们知道Java中<code>int</code>类型为4个字节，共32位。符号位占用一位的话，则其范围为-2<sup>31</sup> 到2<sup>31</sup> - 1。<br>使用此方法时，所有正数都比负数小。最大值为 <code>-1</code>，因为 <code>-1</code>的二进制所有位均为 1。<br>也就是<code>1111 1111 1111 1111 1111 1111 1111 1111</code> &gt; 其它任何32位数。</p>\n<p>关于编码可参考此篇博文<a href=\"https://stephenhuge.github.io/2017/10/18/计算机编码简介/\" target=\"_blank\" rel=\"noopener\">计算机编码简介</a></p>\n<h2 id=\"2-2-String类型的compareTo方法\"><a href=\"#2-2-String类型的compareTo方法\" class=\"headerlink\" title=\"2.2 String类型的compareTo方法\"></a>2.2 String类型的compareTo方法</h2><p>看完<code>Integer</code>后，我们再来看<code>String</code>中<code>compareTo</code>的实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];     <span class=\"comment\">// String的值</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len2 = anotherString.value.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lim = Math.min(len1, len2);     <span class=\"comment\">// limit， 表示两个String中长度较小的String长度</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c1 = v1[k];</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c2 = v2[k];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> c1 - c2;     <span class=\"comment\">// 如果char不相同，则取其差值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;    <span class=\"comment\">// 如果char值相同，则继续往后比较</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len1 - len2;     <span class=\"comment\">// 如果所有0 ~ (lim - 1)的char均相同，则比较两个String的长短</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 字面意思是对大小写不敏感的比较器</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class=\"line\">                                         = <span class=\"keyword\">new</span> CaseInsensitiveComparator();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaseInsensitiveComparator</span></span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8575799808933029326L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> n1 = s1.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n2 = s2.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = Math.min(n1, n2);     <span class=\"comment\">// 和上面类似，均是取两个String间的最短长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; min; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c1 = s1.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c2 = s2.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">                    c1 = Character.toUpperCase(c1); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    c2 = Character.toUpperCase(c2); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 大写如果不相等则再换为小写试试</span></span><br><span class=\"line\">                        c1 = Character.toLowerCase(c1);</span><br><span class=\"line\">                        c2 = Character.toLowerCase(c2);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 到此处则确定不相等</span></span><br><span class=\"line\">                            <span class=\"comment\">// No overflow because of numeric promotion</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1 - n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** Replaces the de-serialized object. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// String的方法，可以直接使用这个方法和其它String进行比较，</span></span><br><span class=\"line\">    <span class=\"comment\">// 内部实现是调用内部比较器的compare方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareToIgnoreCase</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER.compare(<span class=\"keyword\">this</span>, str);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>String</code>中的关于<code>compare</code>的方法相对复杂一点，但还是比较简单。我们先不看其他的代码，只重点关注<code>compareTo</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len1 = value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len2 = anotherString.value.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lim = Math.min(len1, len2);     <span class=\"comment\">// limit， 表示两个String中长度较小的String长度</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; lim) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c1 = v1[k];</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c2 = v2[k];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c1 - c2;     <span class=\"comment\">// 如果char不相同，则取其差值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k++;    <span class=\"comment\">// 如果char值相同，则继续往后比较</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len1 - len2;     <span class=\"comment\">// 如果所有0 ~ (lim - 1)的char均相同，则比较两个String的长短</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内容很简洁，就是取两个<code>String</code>的长度中较小的，作为限定值(<code>lim</code>)。之后对数组下标为从<code>0</code>到<code>lim - 1</code>的<code>char</code>变量进行遍历比较，如果遇到不相同的值，返回其差值。一般我们只用其正负性，如果返回负数则说明第一个对象比第二个对象“小”。<br>例如比较 <code>&quot;abc&quot;</code>和<code>&quot;bcd&quot;</code>，当对各自第一个字符<code>&#39;a&#39;</code>和 <code>&#39;b&#39;</code>进行比较时，发现 <code>&#39;a&#39; != &#39;b&#39;</code>，则返回 <code>&#39;a&#39; - &#39;b&#39;</code> ，这个值是负数， <code>char</code>类型的<code>-1</code>，Java会自动将其类型强转为<code>int</code>型。最后得出结论<code>&quot;abc&quot;</code>比<code>&quot;bcd&quot;</code>小。</p>\n<h1 id=\"3-Comparator\"><a href=\"#3-Comparator\" class=\"headerlink\" title=\"3. Comparator\"></a>3. Comparator</h1><p><code>Comparator&lt;T&gt;</code>接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个外部排序接口，它的功能是规定“比较大小”的方式。实现它的类可以作为参数传入<code>Collections.sort()</code>或<code>Arrays.sort()</code>，使用它的比较方式进行排序。<br><strong>它可以为没有实现<code>Comparable</code>接口的类提供排序方式。</strong><br><code>String</code>类中以及<code>Array</code>类等都有实现此接口的内部类。</p>\n<p>在上面<code>String</code>的源码中就有一个内部的自定义<code>Comparator</code>类<code>CaseInsensitiveComparator</code>， 我们看看它的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class=\"line\">                                         = <span class=\"keyword\">new</span> CaseInsensitiveComparator();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaseInsensitiveComparator</span></span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8575799808933029326L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> n1 = s1.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n2 = s2.length();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = Math.min(n1, n2);     <span class=\"comment\">// 和上面类似，均是取两个String间的最短长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; min; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c1 = s1.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">char</span> c2 = s2.charAt(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c1 != c2) &#123;</span><br><span class=\"line\">                    c1 = Character.toUpperCase(c1); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    c2 = Character.toUpperCase(c2); <span class=\"comment\">// 统一换成大写</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 大写如果不相等则再换为小写试试</span></span><br><span class=\"line\">                        c1 = Character.toLowerCase(c1);</span><br><span class=\"line\">                        c2 = Character.toLowerCase(c2);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (c1 != c2) &#123;     <span class=\"comment\">// 到此处则确定不相等</span></span><br><span class=\"line\">                            <span class=\"comment\">// No overflow because of numeric promotion</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> c1 - c2;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1 - n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** Replaces the de-serialized object. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// String的方法，可以直接使用这个方法和其它String进行比较，</span></span><br><span class=\"line\">    <span class=\"comment\">// 内部实现是调用内部比较器的compare方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareToIgnoreCase</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CASE_INSENSITIVE_ORDER.compare(<span class=\"keyword\">this</span>, str);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>CaseInsensitiveComparator</code>, 字面意思是对大小写不敏感的比较器。<br>我们观察它的<code>compare</code>方法，可以发现，它和上面的<code>compareTo</code>方法实现类似，都是取两个<code>String</code>中长度较小的，作为限定值<code>min</code>，之后对数组下标为从<code>0</code>到<code>min - 1</code>的<code>char</code>变量进行遍历比较。和上面稍有不同的是，此处先将<code>char</code>字符统一换成大写（upper case）， 如果仍然不相等，再将其换为小写（lower case）比较。一个字母只有大写或者小写两种情形，如果这两种情况都不想等则确定不相等，返回其差值。如果限定值内所有的<code>char</code>都相等的话，再去比较两个<code>String</code>类型的长度。</p>\n<p>例如比较 <code>&quot;abC&quot;</code>和<code>&quot;ABc&quot;</code>，<code>compareTo</code>会直接返回 <code>&#39;a&#39; - &#39;A&#39;</code>，而<code>compareToIgnoreCase</code>方法由于使用了<code>CaseInsensitiveComparator</code>，比较结果最终会返回<code>true</code>。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p> 【1】<a href=\"http://blog.csdn.net/Yvonne8_5/article/details/50957079\" target=\"_blank\" rel=\"noopener\">Java源码学习之Integer类（二）——1.8新增的几个函数和变量</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/19/Java%E4%B8%AD%E7%9A%84Comparable%E6%8E%A5%E5%8F%A3%E5%92%8CComparator%E6%8E%A5%E5%8F%A3/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"Sorting","slug":"Sorting","permalink":"https://stevehuge.gitee.io/blog/tags/Sorting/"},{"name":"Comparable","slug":"Comparable","permalink":"https://stevehuge.gitee.io/blog/tags/Comparable/"},{"name":"Comparator","slug":"Comparator","permalink":"https://stevehuge.gitee.io/blog/tags/Comparator/"}]},{"title":"计算机编码简介","date":"2017-10-18T14:00:53.000Z","path":"2017/10/18/计算机编码简介/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81_top.jpg?raw=true\" alt=\"\"></p>\n<h1 id=\"计算机编码\"><a href=\"#计算机编码\" class=\"headerlink\" title=\"计算机编码\"></a>计算机编码</h1><h2 id=\"1-原码、反码和补码\"><a href=\"#1-原码、反码和补码\" class=\"headerlink\" title=\"1. 原码、反码和补码\"></a>1. 原码、反码和补码</h2><p>首先我们知道，在计算机中，所有数都是以二进制存在，也就是<code>0</code>和<code>1</code>的组合。  </p>\n<p>但是通过研究二进制，人们发现了二进制并不能很好的和十进制对应起来。首先十进制中有正数和负数，而二进制中的负号<code>-</code>该如何表示呢？有人想到用二进制的最高位表示，此位为<code>0</code>则表示正数，<code>1</code>表示这个数为负数。</p>\n<p>举个例子：</p>\n<p><code>1</code>的二进制为<code>0001</code>，那么<code>-1</code>的二进制就是<code>1001</code>。</p>\n<p>但是直接这么表示就会出现刚才提到的对应问题。</p>\n<p>例如如果<code>1</code>和<code>-1</code>直接相加，则<code>1 + （-1） = 0</code>，十进制是没有问题的。而二进制表示为<code>0001 + 1001 = 1010 != 0</code>，所以不能直接使用这种方式做运算。而这种直接用最高位表示符号位，其他位表示数字的编码形式称为<strong>原码</strong>。</p>\n<p>原码不能解决这个问题，于是又出现了<strong>反码</strong>，反码是当这个数为负数时，原码除符号位外其他位取反。<code>1001（-1）</code>（原码）取反后为<code>1110</code>。</p>\n<p>继续进行刚才的计算，这次使用反码： （反码）<code>0001 （1） + 1110 （-1） = 1111</code> 。由于<code>1111</code>最高位为1，是负数，所以再次取反之后才是其真实值，取反后为<code>1000</code>，也就是<code>-0</code>。</p>\n<p>这能满足条件了，但是美中不足的是，<code>0</code>带了负号。唯一的问题其实就出现在<code>0</code>这个特殊的数值上。 虽然人们理解上<code>+0</code>和<code>-0</code>是一样的， 但是0带符号是没有任何意义的。 而且会有<code>0000</code>原和<code>1000</code>原两个编码表示<code>0</code>。怎么办呢？</p>\n<p>人们又想出了补码，它的定义是反码加<code>1</code>。<code>-1</code>的补码是 <code>1111</code>，以上的运算用补码表示就是<code>0001 （1） + 1111 （-1） = 0000 = 0</code>。神奇的发现，这个式子完美契合了十进制加法！<br>同时我们留出了<code>1000</code>，可以用它表示<code>-8</code></p>\n<p><code>(-1) + (-7) = (补码) 1111 + 1001 = 1000 = -8</code>。注意，由于此处的<code>-8</code>使用了之前<code>-0</code>的补码来表示，所以<code>-8</code>没有没有原码和反码表示（针对的四位，如果是八位，则没有原码和反码的是<code>-128</code>，依次类推）。</p>\n<p>使用补码, 不仅仅修复了<code>0</code>的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么4位二进制, 使用原码或反码表示的范围为<code>[-7, +7]</code>, 而使用补码表示的范围为<code>[-8, 7]</code>.</p>\n<p>推广到<code>k</code>位：在处理k位的有符号数时，用二进制补码的形式表示负整数<code>-n</code>(1 $\\le$ n $\\le$ $2^k - 1$)， 则补码的二进制值为$2^k - n$ 。非负整数<code>p</code>(0 $\\le$ p $\\le$ $2^{k - 1} - 1$)，只是简单的用k位二进制数表示<code>p</code>的值。因此对于给定的<code>k</code>位，我们可以通过二进制补码表示$-2^{k - 1}$到$2^{k - 1} - 1$的值。</p>\n<p><strong>总结</strong></p>\n<p>为了使数字在计算机中运算不出错，出现了原码，反码和补码。原码就是一个数的二进制表示，其中最高位为符号位，表示其正负。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/JDK%E6%BA%90%E7%A0%81/Comparable&Comparator/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81.jpg?raw=true\" alt=\"\"></p>\n<p>原码，反码和补码运算对比。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/JDK%E6%BA%90%E7%A0%81/Comparable&Comparator/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95.jpg?raw=true\" alt=\"\"></p>\n<p>这就是简单的要用反码和补码的原因。</p>\n<h2 id=\"2-大数溢出问题\"><a href=\"#2-大数溢出问题\" class=\"headerlink\" title=\"2. 大数溢出问题\"></a>2. 大数溢出问题</h2><p><code>int</code>类型在32位系统中占4个字节、32bit，补码表示的的数据范围为：</p>\n<p>[10000000 00000000 00000000 00000000] ~ [01111111 11111111 11111111 11111111]</p>\n<p>[−2<sup>31</sup>,2<sup>31</sup>−1]<br>[-2147483648, 2147483647]</p>\n<p>在java中表示为：</p>\n<p>[Integer.MIN_VALUE, Integer.MAX_VALUE]</p>\n<p>与<code>byte</code>类型的表示一样，由于负数比正数多表示了一个数字。对下限取相反数后的数值会超过上限值，溢出到下限，因此下限的相反数与下限相等；对上限去相反数的数值为负值，该负值比下限的负值大1，在可以表示的范围内，因此上限的相反数是上限直接取负值。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>【1】<a href=\"http://blog.csdn.net/u011080472/article/details/51280919\" target=\"_blank\" rel=\"noopener\">计算机原码、反码、补码详解</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E7%AE%80%E4%BB%8B/","tags":[{"name":"编码","slug":"编码","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"算法4（Algorithms4）- Part 1  算法分析（Analysis Of Algorithms）2","date":"2017-10-16T14:38:24.000Z","path":"2017/10/16/算法4（Algorithms4）- Part 1  算法分析（Analysis Of Algorithms）2/","content":"<h1 id=\"4-增长级数分类（order-of-growth-classifications）\"><a href=\"#4-增长级数分类（order-of-growth-classifications）\" class=\"headerlink\" title=\"4. 增长级数分类（order-of-growth classifications）\"></a>4. 增长级数分类（order-of-growth classifications）</h1><h3 id=\"4-1-常见的增长级数分类\"><a href=\"#4-1-常见的增长级数分类\" class=\"headerlink\" title=\"4.1 常见的增长级数分类\"></a>4.1 常见的增长级数分类</h3><p>常见的函数： \\(1\\)， \\(\\log_2 N\\)， N， \\(N \\log_2 N\\)， \\(N^2\\), \\(N^3\\) 和 \\(2^N\\)<br>这些函数已经能足以描述常见算法的增长级数。（系数在此暂不做考虑）</p>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Typical%20orders%20of%20growth.jpg?raw=true\" alt=\"\"></p>\n<p>下图是以上函数对应的常见算法。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Common%20order-of-growth%20classifications.jpg?raw=true\" alt=\"\"></p>\n<p>实践中的增长级数</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Practical%20implications%20of%20order-of-growth.jpg?raw=true\" alt=\"\"></p>\n<p>极限： 为了能摩尔定律（Moore’s law）保持同步，我们需要线性（linear）或者线性对数级别（linearithmic）的算法。</p>\n<h3 id=\"4-2-二分查找\"><a href=\"#4-2-二分查找\" class=\"headerlink\" title=\"4.2 二分查找\"></a>4.2 二分查找</h3><h4 id=\"1-目标\"><a href=\"#1-目标\" class=\"headerlink\" title=\"1. 目标\"></a>1. 目标</h4><p>给定一个有序数组和其中的一个数，在数组中找到这个数的下标。</p>\n<h4 id=\"2-二分查找\"><a href=\"#2-二分查找\" class=\"headerlink\" title=\"2. 二分查找\"></a>2. 二分查找</h4><p>将此数和数组下标中点的数比较</p>\n<ul>\n<li>给定的数太小，查找左边</li>\n<li>给定的数太大，查找右边</li>\n<li>相等的话，找到了</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/binary%20search.jpg?raw=true\" alt=\"\"></p>\n<h4 id=\"3-Java实现\"><a href=\"#3-Java实现\" class=\"headerlink\" title=\"3. Java实现\"></a>3. Java实现</h4><p>这个问题的实现简单吗？<br>事实上</p>\n<ul>\n<li>第一个二分查找算法于1946年发表；第一个没有bug的二分查找于1962年发表</li>\n<li>Java中的<code>Arrays.binarySearch()</code>实现在2006年被发现有bug</li>\n</ul>\n<p>提这些只是为了说明，正确的二分查找<strong>并没有想象中的简单</strong>..</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Binary%20search%20Java%20implementation.jpg?raw=true\" alt=\"\"></p>\n<p>如果<code>key</code>在数组<code>a[]</code>中，那么必有 <code>a[lo] &lt;= key &lt;= a[hi]</code>。</p>\n<h4 id=\"4-数学分析\"><a href=\"#4-数学分析\" class=\"headerlink\" title=\"4. 数学分析\"></a>4. 数学分析</h4><p>命题： 在长度为N的有序数组中进行二分查找，最多比较1 + lg N次。<br>证明：设T(N)为在长度为N的有序数组中进行二分查找时比较的次数。<br>易得T(1) = 1<br>N &gt; 1时， T(N) = T(N / 2) + 1  （其中的1次是在和中点的数进行比较，T(N / 2)是之后左半部分或者右半部分进行比较）。<br>证明过程： </p>\n<pre><code>T (N) ≤ T (N / 2) + 1               // 小于等于是可能第一次比较就等于\n    ≤ T (N / 4) + 1 + 1\n    ≤ T (N / 8) + 1 + 1 + 1\n    . . .\n    ≤ T (N / N) + 1 + 1 + … + 1     // 停止， 此时T(1) = 1\n    = 1 + lg N</code></pre><h3 id=\"4-3-3-SUM算法的一个-N-2-log-N-实现\"><a href=\"#4-3-3-SUM算法的一个-N-2-log-N-实现\" class=\"headerlink\" title=\"4.3 3 - SUM算法的一个\\(N ^ 2 \\log N\\) 实现\"></a>4.3 3 - SUM算法的一个\\(N ^ 2 \\log N\\) 实现</h3><p>基于排序的算法</p>\n<ul>\n<li>步骤一： 对N个不同的数进行排序</li>\n<li>步骤二： 对于每对<code>a[i]</code>和<code>a[j]</code>, 在数组中二分查找 <code>-(a[i] + a[j])</code></li>\n<li><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/An%20N2%20log%20N%20algorithm%20for%203-SUM.jpg?raw=true\" alt=\"\"></li>\n</ul>\n<p>分析： 增长级为 \\(N ^ 2 \\log N\\)。</p>\n<ul>\n<li>步骤一： 插入排序（insertion sort） – \\(N ^ 2\\)</li>\n<li>步骤二： 二分查找（binary search） – \\(N ^ 2 \\log N\\)</li>\n</ul>\n<h3 id=\"4-4-算法比较\"><a href=\"#4-4-算法比较\" class=\"headerlink\" title=\"4.4 算法比较\"></a>4.4 算法比较</h3><p>假设： 对于3-SUM 问题的两个实现</p>\n<ul>\n<li>基于排序的增长级为\\(N ^ 2 \\log N\\) 的算法</li>\n<li>暴力算法\\(N ^ 3\\) 算法<br>前者比后者要快。</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/3-sum%20Comparing%20programs.jpg?raw=true\" alt=\"\"></p>\n<p>事实证明， 增长级更好 =&gt; 速度更快</p>\n<h3 id=\"4-5-算法理论中常用的符号表示\"><a href=\"#4-5-算法理论中常用的符号表示\" class=\"headerlink\" title=\"4.5 算法理论中常用的符号表示\"></a>4.5 算法理论中常用的符号表示</h3><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Commonly-used%20notations%20in%20the%20theory%20of%20algorithms.jpg?raw=true\" alt=\"\"></p>\n<p>其中有三种符号： \\(\\Theta (N^2)\\)， \\(O (N^2)\\)和\\(\\Omega (N^2)\\)。</p>\n<p>\\(O \\)是用于描述函数渐近行为的数学符号。更确切地说，它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。</p>\n<p>\\(\\Omega \\)的定义与\\(O \\)的定义类似，但主要区别是，\\(O \\)表示函数在增长到一定程度时总小于一个特定函数的常数倍，\\(\\Omega \\)则表示总大于，来描述一个函数数量级的渐近下界。<br>\\(\\Theta \\)是\\(O \\)和\\(\\Omega \\)的结合，是用来定义一个函数的数量级。</p>\n<p>常见错误时：使用\\(O \\)表示近似时间模型。</p>\n<p>本文使用波浪线~ (tlide notation)用来表示算法的近似时间模型。</p>\n<h1 id=\"5-内存\"><a href=\"#5-内存\" class=\"headerlink\" title=\"5. 内存\"></a>5. 内存</h1><h3 id=\"5-1-基础\"><a href=\"#5-1-基础\" class=\"headerlink\" title=\"5.1 基础\"></a>5.1 基础</h3><ul>\n<li>比特（Bit）： 0 或 1</li>\n<li>字节（Byte）： 8个比特</li>\n<li>兆（MB， Megabyte）： 10 ^ 6或者2 ^ 20个比特</li>\n<li>吉（GB， Gigabyte）： 10 ^ 9或者2 ^ 30个比特</li>\n</ul>\n<p>64-bit计算机：其中指针长度为8bytes</p>\n<ul>\n<li>可以为更大的内存提供地址</li>\n<li>指针消耗内存更多（一些JVM会“压缩”对象指针到4字节以节省内存）</li>\n</ul>\n<h3 id=\"5-2-基本数据类型和数组的内存占用\"><a href=\"#5-2-基本数据类型和数组的内存占用\" class=\"headerlink\" title=\"5.2 基本数据类型和数组的内存占用\"></a>5.2 基本数据类型和数组的内存占用</h3><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Typical%20memory%20usage%20for%20primitive%20types%20and%20arrays.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"5-3-Java中对象的内存占用\"><a href=\"#5-3-Java中对象的内存占用\" class=\"headerlink\" title=\"5.3 Java中对象的内存占用\"></a>5.3 Java中对象的内存占用</h3><ul>\n<li>对象头（Object overhead）： 16bytes</li>\n<li>引用（Reference）： 8bytes</li>\n<li>对齐填充（Padding）： 每个对象使用内存均为8bytes的整数倍</li>\n</ul>\n<p>例1： 一个Date对象使用32bytes的内存<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/date%20object%20memory%20usage.jpg?raw=true\" alt=\"\"><br>例2：一个长度为N的String类使用N ~ 2N bytes的内存<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/String%20object%20usage.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"5-4-总结\"><a href=\"#5-4-总结\" class=\"headerlink\" title=\"5.4 总结\"></a>5.4 总结</h3><p>各种数据类型的内存使用</p>\n<ul>\n<li>基本数据类型（primitive type）： int型 4bytes， double型 8bytes</li>\n<li>对象引用（object reference）： 8bytes</li>\n<li>数组（array）： 24bytes + 每个数组成员的内存 + 8bytes（如果有内部类的话， 指向内部类的指针）</li>\n<li>对齐（padding）： 为了让对象长度为8bytes的整数倍</li>\n</ul>\n<p>浅层次内存的计算： 不计算引用对象<br>深层次内存的计算： 如果数组成员是一个对象引用， 需要将引用的对象内存也计算在内</p>\n<p>举例： 一个<code>WeightedQuickUnionUF</code>对象，其中数据长度为N， 计算其对象大小<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/WeightedQuickUnionUF%20memory%20usage.jpg?raw=true\" alt=\"\"></p>\n<p>其大小为 \\(8 N + 88\\) ~ \\(8 N\\) bytes。</p>\n<h1 id=\"参考网址\"><a href=\"#参考网址\" class=\"headerlink\" title=\"参考网址\"></a>参考网址</h1><p>[1] <a href=\"http://algs4.cs.princeton.edu/11model/\" target=\"_blank\" rel=\"noopener\">Algorithms4</a><br>[2] <a href=\"http://blog.csdn.net/zuochao_2013/article/details/53428837\" target=\"_blank\" rel=\"noopener\">大O符号/大Ω符号/大Θ符号/小o符号/小w符号等各种算法复杂度记法含义</a><br>[3] <a href=\"http://blog.csdn.net/xiahouzuoxin/article/details/26478179\" target=\"_blank\" rel=\"noopener\">Markdown中插入数学公式的方法</a><br>[4] <a href=\"https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax basic tutorial and quick reference</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/16/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%201%20%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88Analysis%20Of%20Algorithms%EF%BC%892/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法分析","slug":"算法分析","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"算法4（Algorithms4）- Part 1  算法分析（Analysis Of Algorithms）1","date":"2017-10-16T13:38:24.000Z","path":"2017/10/16/算法4（Algorithms4）- Part 1  算法分析（Analysis Of Algorithms）1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/top.jpg?raw=true\" alt=\"\"></p>\n<p>本文分为5节，分别是：</p>\n<ol>\n<li>介绍（introduction）： 介绍算法分析的必要性和重要性</li>\n<li>观察（observations）： 通过分析一个经典问题 3 - SUM问题，逐渐引出算法分析的方法论</li>\n<li>数学模型（mathematical models）： 如何具体分析比较算法的优劣呢？我们需要对算法的运行时间进行分析并建立数学模型</li>\n<li>增长级（order-of-growth classifications）： 对算法运行时间进行分类</li>\n<li>内存（memory）： 算法使用了多大的内存？</li>\n</ol>\n<a id=\"more\"></a>\n\n<p>本文贯穿始终的是3 - SUM 算法，其中也提到了二分查找（binary search）算法。</p>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><h2 id=\"1-1-人物介绍\"><a href=\"#1-1-人物介绍\" class=\"headerlink\" title=\"1.1 人物介绍\"></a>1.1 人物介绍</h2><p>在算法开发过程中，有这么几个角色</p>\n<ul>\n<li>程序员（Programmer） ： 需要开发出能解决问题的算法</li>\n<li>用户（Client） ： 想要高效的解决问题</li>\n<li>理论家（Theoretician） ： 想要搞清算法的原理</li>\n<li>*学生（Student） ： 可能要扮演上述任一个角色</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/casts.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"1-2-运行时间\"><a href=\"#1-2-运行时间\" class=\"headerlink\" title=\"1.2 运行时间\"></a>1.2 运行时间</h2><h2 id=\"1-3-为什么要分析算法？\"><a href=\"#1-3-为什么要分析算法？\" class=\"headerlink\" title=\"1.3 为什么要分析算法？\"></a>1.3 为什么要分析算法？</h2><ul>\n<li>可以对已知算法的性能进行预测</li>\n<li>可以比较多个算法的优劣</li>\n<li>可以对已知算法提供性能保证</li>\n<li>可以理解基本的算法相关理论</li>\n</ul>\n<p>本课会涉及前三点，后面的两点则是算法理论研究相关的方向。  </p>\n<p>基于实用性的原因：避免性能上的bug。<br>用户可能因为程序员不了解性能特性而获得很差性能的代码。</p>\n<h2 id=\"1-4-一些成功的算法\"><a href=\"#1-4-一些成功的算法\" class=\"headerlink\" title=\"1.4 一些成功的算法\"></a>1.4 一些成功的算法</h2><h3 id=\"1-离散傅里叶变换（Discrete-Fourier-transform）\"><a href=\"#1-离散傅里叶变换（Discrete-Fourier-transform）\" class=\"headerlink\" title=\"1. 离散傅里叶变换（Discrete Fourier transform）\"></a>1. 离散傅里叶变换（Discrete Fourier transform）</h3><ul>\n<li>将N个图样的波形分解成周期分量</li>\n<li>应用 ： DVD， JPEG， MRI（Magnetic Resonance Imaging， 核磁共振成像）， 天体物理学…</li>\n<li>暴力破解 ： \\(N ^ 2\\)步</li>\n<li>FFT 算法 ： \\(N * \\log N\\) 步， 使新技术成为可能</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/DFT.JPG?raw=true\" alt=\"\"></p>\n<h3 id=\"2-N体模拟（N-body-simulation）\"><a href=\"#2-N体模拟（N-body-simulation）\" class=\"headerlink\" title=\"2. N体模拟（N - body simulation）\"></a>2. N体模拟（N - body simulation）</h3><ul>\n<li>模拟N个物体间的引力相互作用</li>\n<li>暴力破解 ： \\(N ^ 2\\)</li>\n<li>Barnes-Hut算法（Barnes-Hut algorithm） ： \\(N * \\log N\\) 步， 使新研究成为可能</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/N-body.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"1-5-我们面临的挑战\"><a href=\"#1-5-我们面临的挑战\" class=\"headerlink\" title=\"1.5 我们面临的挑战\"></a>1.5 我们面临的挑战</h2><p>问题 ： 我的算法能够解决大量的输入数据吗？</p>\n<ul>\n<li>算法可能很慢</li>\n<li>算法使用内存可能超标</li>\n</ul>\n<p>如何对算法进行分析呢？</p>\n<p>高德纳（Donald Knuth）在20世纪70年代提出： 使用 <strong>科学的方法（scientific methods）</strong> 来分析算法性能。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Donald%20Knuth.jpg?raw=true\" alt=\"\"></p>\n<h4 id=\"1-应用于算法分析的科学方法\"><a href=\"#1-应用于算法分析的科学方法\" class=\"headerlink\" title=\"1. 应用于算法分析的科学方法\"></a>1. 应用于算法分析的科学方法</h4><p>我们需要一个体系，满足以下两个条件： </p>\n<ul>\n<li>可以预测算法的性能</li>\n<li>能比较不同算法的优劣</li>\n</ul>\n<h4 id=\"2-科学的方法\"><a href=\"#2-科学的方法\" class=\"headerlink\" title=\"2. 科学的方法\"></a>2. 科学的方法</h4><ul>\n<li>观察（Observe） ： 观察自然界的特性</li>\n<li>假设（Hypothesize） ： 假设一个和观察结果一致的模型</li>\n<li>预测（Predict） ： 根据假设进行预测未发生的情况</li>\n<li>验证（Verify） ： 进行更多的观察，以此验证我们的预测</li>\n<li>确认（Validate） ： 不断重复上述过程，直到观察和假设能完全一致</li>\n</ul>\n<h4 id=\"3-需要遵守的原则\"><a href=\"#3-需要遵守的原则\" class=\"headerlink\" title=\"3. 需要遵守的原则\"></a>3. 需要遵守的原则</h4><ul>\n<li>实验必须可重复（reproducible）</li>\n<li>假设必须可被明确检验对或者不对（falsifiable）</li>\n</ul>\n<h1 id=\"2-观察\"><a href=\"#2-观察\" class=\"headerlink\" title=\"2. 观察\"></a>2. 观察</h1><p>我们来看一个例子：3 - SUM问题。</p>\n<h2 id=\"2-1-3-SUM问题\"><a href=\"#2-1-3-SUM问题\" class=\"headerlink\" title=\"2.1 3 - SUM问题\"></a>2.1 3 - SUM问题</h2><p>给出N个不同的整数，随机挑三个数构成一个组合，使这个组合中的三数之和为0， 这样的组合一共有多少个？<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/3-sum%20problem.jpg?raw=true\" alt=\"\"></p>\n<h2 id=\"2-2-暴力破解\"><a href=\"#2-2-暴力破解\" class=\"headerlink\" title=\"2.2 暴力破解\"></a>2.2 暴力破解</h2><p>最容易想到的解法就是使用暴力算法，三个循环，遍历获取。代码如下：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/3-sum%20brute%20force%20algorithm.jpg?raw=true\" alt=\"\"><br>如何判定这个实现好不好呢？我们需要计算它的运行时间。</p>\n<h3 id=\"1-运行时间\"><a href=\"#1-运行时间\" class=\"headerlink\" title=\"1. 运行时间\"></a>1. 运行时间</h3><p>如何获得运行时间呢？</p>\n<ul>\n<li>使用秒表手动计时</li>\n<li>使用<code>algs.jar</code>中的<code>Stopwatch</code>类。</li>\n</ul>\n<p>使用方法如下：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Stopwatch.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"2-数据分析\"><a href=\"#2-数据分析\" class=\"headerlink\" title=\"2. 数据分析\"></a>2. 数据分析</h3><p>按照数据量从小到大排列，运行得出的时间：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/3-sum%20brute%20force%20running%20time.jpg?raw=true\" alt=\"\"></p>\n<p>使用标准坐标，将其坐标描点，用平滑曲线连接，如图所示。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/3-sum%20brute%20force%20standred%20plot.jpg?raw=true\" alt=\"\"></p>\n<p>使用纯对数坐标（Log-log图）。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/log-log%20plot.jpg?raw=true\" alt=\"\"></p>\n<p>通过对对数坐标的图进行观察，我们发现这条线近似直线。设其斜率为b，常数项为c。<br>得出方程：</p>\n<pre><code>lg(T (N)) = b lg N + c</code></pre><p>解得常数项为：</p>\n<pre><code>b = 2.999\nc = -33.2103</code></pre><p>得出结论：</p>\n<pre><code>T (N) = a * N ^ b，其中 a = 2 c</code></pre><p>假设 ： 运行时间计算公式为（单位为s）： </p>\n<pre><code>T(N) = 1.006 * 10 ^ 10 * N ^ 2.999 </code></pre><h3 id=\"3-预测和验证\"><a href=\"#3-预测和验证\" class=\"headerlink\" title=\"3. 预测和验证\"></a>3. 预测和验证</h3><p>根据上面假设的公式进行预测： </p>\n<ul>\n<li>N = 8000时， 时间为51s</li>\n<li>N = 16000时， 时间为408.1s</li>\n</ul>\n<p>验证：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/observations%20results.jpg?raw=true\" alt=\"\"><br>证实了假设是对的！</p>\n<p>我们通过进一步观察发现，每当数据量翻倍时，其运行时间也呈规律性的变化。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Doubling%20hypothesis1.jpg?raw=true\" alt=\"\"></p>\n<p>每次运行时间与上次运行时间的比率ratio，其对2取对数，即 lg ratio 趋近于3。<br>根据这点，更进一步假设 ：</p>\n<pre><code>T(N) = a * N ^ b, 其中 b = lg ratio</code></pre><p>现在假设 b = 3， 从而求出a的值。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Doubling%20hypothesis2.jpg?raw=true\" alt=\"\"></p>\n<p>最终得出</p>\n<pre><code>T(N) = 0.998 × 10 ^ –10 × N ^ 3</code></pre><p>事实上，这个公式和根据线性回归（linear regression）计算得出的公式相当相近了。</p>\n<h3 id=\"4-在实践中影响算法表现的因素\"><a href=\"#4-在实践中影响算法表现的因素\" class=\"headerlink\" title=\"4. 在实践中影响算法表现的因素\"></a>4. 在实践中影响算法表现的因素</h3><p>不受外部系统影响的部分</p>\n<ul>\n<li>算法</li>\n<li>输入数据</li>\n</ul>\n<p>受外部系统影响的部分</p>\n<ul>\n<li>硬件（Hardware） ： CPU， 内存， 缓存，…</li>\n<li>软件（Software） ： 编译器， 解释器， 垃圾回收（GC），…</li>\n<li>系统（System） ： 操作系统（OS）， 网络， 其它应用，…</li>\n</ul>\n<p>通过这节我们对3-SUM算法的暴力实现算法进行了分析，得出了一些简单的结论。能够根据公式，输入一定数量的数据，得出运行时间。  </p>\n<p>如何对其它更广泛的算法进行计算呢？我们需要对算法内部的代码进行更细致的分析。</p>\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>\n<h1 id=\"3-数学模型\"><a href=\"#3-数学模型\" class=\"headerlink\" title=\"3. 数学模型\"></a>3. 数学模型</h1><h2 id=\"3-1-运行时间的数学模型\"><a href=\"#3-1-运行时间的数学模型\" class=\"headerlink\" title=\"3.1 运行时间的数学模型\"></a>3.1 运行时间的数学模型</h2><p>给定一个算法，其总的运行时间 \\(T\\) = 算法中每个具体操作耗费的时间 \\(T_i\\) \\(*\\) 该操作出现的次数 \\(n_i\\) 之和。<br>使用公式表示为：  </p>\n<p>$$ T = \\sum_{i=0}^n T_i n_i $$</p>\n<p>我们需要知道以下几点：</p>\n<ul>\n<li>需要对程序进行分析，以确认操作的次数</li>\n<li>耗费时间取决于硬件和编译器</li>\n<li>操作的次数取决于算法和输入的数据</li>\n</ul>\n<p>大体上说， 精确的数学模型是十分有价值的。</p>\n<h3 id=\"1-基本操作的时间\"><a href=\"#1-基本操作的时间\" class=\"headerlink\" title=\"1. 基本操作的时间\"></a>1. 基本操作的时间</h3><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Cost%20of%20basic%20operations1.jpg?raw=true\" alt=\"\"></p>\n<p>以上是常见数学计算的耗时。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Cost%20of%20basic%20operations2.jpg?raw=true\" alt=\"\"></p>\n<p>以上是计算机语言中常见操作的耗时，\\(c_i\\)表示常数时间， \\(N\\)表示输入的数据量。</p>\n<p>新手错误 ： 滥用字符串连接（string concatenation），因为这和输入数据量成正比，我们应该追求更高效的做法。</p>\n<p>接下来，我们看几个由3-SUM简化出的问题，逐步分析。</p>\n<h3 id=\"2-例子：-1-SUM问题\"><a href=\"#2-例子：-1-SUM问题\" class=\"headerlink\" title=\"2. 例子： 1 - SUM问题\"></a>2. 例子： 1 - SUM问题</h3><p>问题： 当输入的数据有N个时，需要操作多少步？<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/1-sum%20time.jpg?raw=true\" alt=\"\"></p>\n<p>图中给出了各种必要的操作及其次数。</p>\n<h3 id=\"3-例子：-2-SUM问题\"><a href=\"#3-例子：-2-SUM问题\" class=\"headerlink\" title=\"3. 例子： 2 - SUM问题\"></a>3. 例子： 2 - SUM问题</h3><p>问题： 当输入的数据有N个时，需要操作多少步？<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/2-sum%20time.jpg?raw=true\" alt=\"\"></p>\n<p>图中给出了各种必要的操作及其次数。<br>相比1 - SUM中的操作，2 - SUM中操作次数计算开始变得繁琐和难以计算。</p>\n<h2 id=\"3-2-简化计算\"><a href=\"#3-2-简化计算\" class=\"headerlink\" title=\"3.2 简化计算\"></a>3.2 简化计算</h2><h3 id=\"1-耗费模型的简化\"><a href=\"#1-耗费模型的简化\" class=\"headerlink\" title=\"1. 耗费模型的简化\"></a>1. 耗费模型的简化</h3><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Alan%20Turing.jpg?raw=true\" alt=\"\"></p>\n<blockquote>\n<p>“ It is convenient to have a measure of the amount of work involved<br>in a computing process, even though it be a very crude one. We may<br>count up the number of times that various elementary operations are<br>applied in the whole process and then given them various weights.<br>We might, for instance, count the number of additions, subtractions,<br>multiplications, divisions, recording of numbers, and extractions<br>of figures from tables. In the case of computing with matrices most<br>of the work consists of multiplications and writing down numbers,<br>and we shall therefore only attempt to count the number of<br>multiplications and recordings. ” — Alan Turing</p>\n</blockquote>\n<p>这是艾伦 图灵（Alan Turing）说过的一段话，大意是：<br>“测量计算过程中涉及的工作量是很方便的，尽管可能结果很粗糙。我们可以计算在整个过程中各种基本操作应用的次数，然后赋予它们各种权重。<br>例如，我们可以计算加法、减法、乘法、除法、记录数字和从表中提取数据的次数。在矩阵中计算的情况下，操作主要是由乘法和记录数字组成，因此我们只尝试计算乘法和记录的次数。”</p>\n<p>其中最后一句话提到“只尝试计算乘法和记录的次数”，这为简化算法耗费时间的计算提供了思路。</p>\n<p>例如刚才2-SUM问题中，我们<strong>只对关键操作的时间进行记录</strong>，而忽略其它操作的时间。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/simlification1%20-%20cost%20model.jpg?raw=true\" alt=\"\"></p>\n<p>我们只记录访问数组的时间，其次数\\(N (N - 1)\\)。</p>\n<h3 id=\"2-波浪线表示法\"><a href=\"#2-波浪线表示法\" class=\"headerlink\" title=\"2. 波浪线表示法\"></a>2. 波浪线表示法</h3><ul>\n<li>当输出个数为N时，估计函数的运行时间</li>\n<li>忽略低阶项<ul>\n<li>当N很大时，低阶项微不足道</li>\n<li>当N较小时，我们无需在意</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">式子</th>\n<th align=\"center\">等价</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">⅙ \\(N^3\\) + 20 \\(N\\) + 16</td>\n<td align=\"center\">~ ⅙ \\(N^3\\)</td>\n</tr>\n<tr>\n<td align=\"center\">⅙ \\(N^3\\) + 100 \\(N^{4/3}\\) + 56</td>\n<td align=\"center\">~ ⅙ \\(N^3\\)</td>\n</tr>\n<tr>\n<td align=\"center\">⅙ \\(N^3\\) - ½ \\(N^2\\) + ⅓ \\(N\\)</td>\n<td align=\"center\">~ ⅙ \\(N^3\\)</td>\n</tr>\n</tbody></table>\n<p>对于第三项来说，当\\(N\\) = 1000时， ½ \\(N^2\\) + ⅓ \\(N\\)大概是500000（十万量级）， 而⅙ \\(N^3\\)为166000000（亿量级），相比来说，忽略低阶项完全是说通的。</p>\n<p>以下是2-SUM各项操作波浪线表示法得出的等价：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/simlification2%20-%20tlide%20notation.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"3-例子：-2-SUM问题-1\"><a href=\"#3-例子：-2-SUM问题-1\" class=\"headerlink\" title=\"3. 例子： 2 - SUM问题\"></a>3. 例子： 2 - SUM问题</h3><p>根据上面的方法进行简化，计算出时间。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/2-sum%20simply.jpg?raw=true\" alt=\"\"></p>\n<p>得出结论：2-SUM问题的算法时间复杂度为 ~\\(  N^2\\)。</p>\n<h3 id=\"4-例子：-3-SUM问题\"><a href=\"#4-例子：-3-SUM问题\" class=\"headerlink\" title=\"4. 例子： 3 - SUM问题\"></a>4. 例子： 3 - SUM问题</h3><p>根据上面的方法进行简化，计算出时间。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/3-sum%20simply.jpg?raw=true\" alt=\"\"></p>\n<p>得出结论：3-SUM问题的算法时间复杂度为 ~\\( {1/2} N^3\\)。</p>\n<h3 id=\"5-估计离散求和\"><a href=\"#5-估计离散求和\" class=\"headerlink\" title=\"5. 估计离散求和\"></a>5. 估计离散求和</h3><p>问题：如何对离散值求和？</p>\n<ul>\n<li>学习离散数学</li>\n<li>使用微积分</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Estimating%20a%20discrete%20sum.jpg?raw=true\" alt=\"\"></p>\n<p>理论中，精确的数学模型十分重要。<br>现实中，</p>\n<ul>\n<li>方程可能很复杂</li>\n<li>可能需要高等数学的知识</li>\n<li>具体的数学模型还是留给专家吧！</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms%20Analysis/Mathematical%20models%20for%20running%20time.jpg?raw=true\" alt=\"\"></p>\n<p>我们需要的是一个大概的模型，例如： \\(T(N) \\) ~ \\(c N^3\\)</p>\n<p>未完待续。。。</p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/16/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%201%20%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88Analysis%20Of%20Algorithms%EF%BC%891/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法分析","slug":"算法分析","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"算法4（Algorithms4）- Part 1  动态连通性（Dynamic Connectivity）2","date":"2017-10-13T14:23:19.000Z","path":"2017/10/13/算法4（Algorithms4）- Part 1  动态连通性（Dynamic Connectivity）2/","content":"<h1 id=\"8-应用场景\"><a href=\"#8-应用场景\" class=\"headerlink\" title=\"8. 应用场景\"></a>8. 应用场景</h1><ul>\n<li>渗析模型（Perocolation）</li>\n<li>围棋</li>\n<li>动态连通性</li>\n<li>最近祖先寻找问题</li>\n<li>有限状态机的等效问题</li>\n<li>Matlab中处理图像的bwlabel()函数<br>…<a id=\"more\"></a>\n<h1 id=\"9-渗析模型（Percolation）\"><a href=\"#9-渗析模型（Percolation）\" class=\"headerlink\" title=\"9. 渗析模型（Percolation）\"></a>9. 渗析模型（Percolation）</h1><h3 id=\"9-1-什么是渗析模型（Percolation）\"><a href=\"#9-1-什么是渗析模型（Percolation）\" class=\"headerlink\" title=\"9.1 什么是渗析模型（Percolation）\"></a>9.1 什么是渗析模型（Percolation）</h3>一个在许多物理系统中都有应用的模型。</li>\n<li>N * N 个方格构成的正方形</li>\n<li>每个方格有 <em>p</em> 的概率是开放的（open）（或者有 <em>1-p</em> 的概率是闭合的（blocked））</li>\n<li>当且仅当顶部和底部被开放的方格连起来的时候，系统是<strong>连通</strong>的（percolates）</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/StephenHuge/Markdown_Pic/beef06bad339269d20c85c8eebb7865e55d105c2/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Percolates.jpg\" alt=\"Percolates\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">模型</th>\n<th align=\"center\">系统化</th>\n<th align=\"center\">开放的格子</th>\n<th align=\"center\">闭合的格子</th>\n<th align=\"center\">连通</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">电学</td>\n<td align=\"center\">电学材料</td>\n<td align=\"center\">导体</td>\n<td align=\"center\">绝缘体</td>\n<td align=\"center\">导电</td>\n</tr>\n<tr>\n<td align=\"center\">液体流通</td>\n<td align=\"center\">材料</td>\n<td align=\"center\">无液体</td>\n<td align=\"center\">有液体</td>\n<td align=\"center\">渗漏</td>\n</tr>\n<tr>\n<td align=\"center\">社交关系</td>\n<td align=\"center\">人群</td>\n<td align=\"center\">人</td>\n<td align=\"center\">空</td>\n<td align=\"center\">有共同好友</td>\n</tr>\n<tr>\n<td align=\"center\">### 9.2 连通的概率</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">取决于方格为空的概率 <em>p</em>。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/PercolatesOrNot.jpg?raw=true\" alt=\"PercolatesOrNot\"></p>\n<p>当N很大时，理论证实存在一个陡峭的临界点p*。</p>\n<ul>\n<li>p &gt; p*: 基本确信连通</li>\n<li>p &lt; p*: 基本确信不连通</li>\n</ul>\n<p>问题： p的值是多少？</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/PercolationProbablity.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"9-3-蒙特卡罗模拟（Monte-Carlo-simulation）\"><a href=\"#9-3-蒙特卡罗模拟（Monte-Carlo-simulation）\" class=\"headerlink\" title=\"9.3 蒙特卡罗模拟（Monte Carlo simulation）\"></a>9.3 蒙特卡罗模拟（Monte Carlo simulation）</h3><ul>\n<li>初始化一个有N * N个方格的正方形，其中所有方格均是闭合的（blocked）</li>\n<li>不断随机选取方格，让其开放（open），直到顶部和底部连通停止</li>\n<li>通过开放的方格数估计p*</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Monte%20Carlo%20simulation.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"9-4-通过动态连通性（Dynamic-Connectivity）方法估计连通阈值（percolation-threshold）\"><a href=\"#9-4-通过动态连通性（Dynamic-Connectivity）方法估计连通阈值（percolation-threshold）\" class=\"headerlink\" title=\"9.4 通过动态连通性（Dynamic Connectivity）方法估计连通阈值（percolation threshold）\"></a>9.4 通过动态连通性（Dynamic Connectivity）方法估计连通阈值（percolation threshold）</h3><p>怎么检测一个 N * N的系统是连通的呢？</p>\n<ul>\n<li>为每个方格创建一个实例节点，编号从0到N-1</li>\n<li>如果开放的方格之间有“通路”，说明它们处于同一个分量（Component）（此处参见<a href=\"https://stephenhuge.github.io/2017/10/02/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%201%20%20%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%EF%BC%88Dynamic%20Connectivity%EF%BC%891/\" target=\"_blank\" rel=\"noopener\">上一篇文章</a>）</li>\n<li>当且仅当顶部方格和底部方格支架有通路时，系统连通（暴力算法调用N ^ 2次connected()方法）</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/DCofPercolation.jpg?raw=true\" alt=\"\"></p>\n<p>一个小技巧：创建两个虚拟的节点，分别连接顶部所有节点和底部所有节点。</p>\n<ul>\n<li>当虚拟顶部节点和底部节点连通时，整个系统连通（这种情况只需要调用1次connected()方法）<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/CleverTrick.jpg?raw=true\" alt=\"\"></li>\n</ul>\n<p>怎么模拟开放一个新节点？</p>\n<p>改变此节点的状态；该节点和相邻的节点中（共4个）开放的节点相连</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/ModelANewSite.jpg?raw=true\" alt=\"\"></p>\n<p>连通阈值（percolation threshold）<br>连通阈值p* 是多少？<br>根据大量的仿真实验得出p* 大约为0.592746。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/PercolationProbablity.jpg?raw=true\" alt=\"\"><br>好的算法是** 可以 ** 对科学问题得出较为精确的答案。</p>\n<h3 id=\"9-5-编程作业（Programming-Assignment-Percolation）\"><a href=\"#9-5-编程作业（Programming-Assignment-Percolation）\" class=\"headerlink\" title=\"9.5 编程作业（Programming Assignment - Percolation）\"></a>9.5 编程作业（Programming Assignment - Percolation）</h3><p>其中要求实现<code>Percolation.java</code> 和 <code>PercolationStats.java</code> 两个文件。<br>实现这两个文件之后，打包提交到系统中，系统会对两个文件进行详尽的测试，之后给出分数。</p>\n<p><code>Percolation.java</code> 的 API<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Percolation.java.jpg?raw=true\" alt=\"\"><br>具体方法的作用</p>\n<table>\n<thead>\n<tr>\n<th>public class Percolation</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public Percolation(int n)</td>\n<td align=\"center\">创建一个有 n * n 个节点的阵列，每个节点都是封闭的</td>\n</tr>\n<tr>\n<td>public    void open(int row, int col)</td>\n<td align=\"center\">如果节点(row, col)未打开，将其打开</td>\n</tr>\n<tr>\n<td>public boolean isFull(int row, int col)</td>\n<td align=\"center\">判断节点(row, col)是否是满的（即与顶部连通）</td>\n</tr>\n<tr>\n<td>public     int numberOfOpenSites()</td>\n<td align=\"center\">已经打开的节点数量</td>\n</tr>\n<tr>\n<td>public boolean percolates()</td>\n<td align=\"center\">整个系统是否连通</td>\n</tr>\n</tbody></table>\n<p><code>PercolationStats.java</code> 的 API<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/PercolationStats.java.jpg?raw=true\" alt=\"\">  </p>\n<p>具体方法的作用</p>\n<table>\n<thead>\n<tr>\n<th>public class PercolationStats</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public PercolationStats(int n, int trials)</td>\n<td align=\"center\">在 n * n 个节点的阵列上进行trial次独立重复实验</td>\n</tr>\n<tr>\n<td>public double mean()</td>\n<td align=\"center\">测试用例连通阈值（percolation threshold）的平均值</td>\n</tr>\n<tr>\n<td>public double stddev()</td>\n<td align=\"center\">连通阈值的平均差</td>\n</tr>\n<tr>\n<td>public double confidenceLo()</td>\n<td align=\"center\">计算结果95%置信区间的左边界</td>\n</tr>\n<tr>\n<td>public double confidenceHi()</td>\n<td align=\"center\">计算结果95%置信区间的右边界</td>\n</tr>\n<tr>\n<td>通过这些方法能解决的问题</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>- 方格为空的概率p的值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>- 渗析模型（Percolation）中连通阈值（percolation threshold）95%置信区间的范围</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>- 测试结果的平均差从而得知计算的稳定性</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td>…</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>关于作业，此处不再详述，因为后面会给出代码，代码中有详细的注释。</p>\n<p>可参见参考网址中课程作业的地址，其中有详细要求，作业代码的实现也一并在参考网址中给出。</p>\n<h1 id=\"10-本节课的言外之意\"><a href=\"#10-本节课的言外之意\" class=\"headerlink\" title=\"10. 本节课的言外之意\"></a>10. 本节课的言外之意</h1><p>逐渐实现一个可用的算法步骤：  </p>\n<ul>\n<li>对问题建模</li>\n<li>找出一个能解决它的算法</li>\n<li>这个算法足够快吗？内存占用如何？</li>\n<li>如果答案是否的话，找出原因</li>\n<li>找到解决方法</li>\n<li>不断迭代上述步骤，直到满足要求</li>\n</ul>\n<h1 id=\"参考网址\"><a href=\"#参考网址\" class=\"headerlink\" title=\"参考网址\"></a>参考网址</h1><p>[1] <a href=\"https://www.coursera.org/learn/algorithms-part1/programming/Lhp5z/percolation\" target=\"_blank\" rel=\"noopener\">课程作业 （Assignment - Percolation）</a><br>[2] <a href=\"https://github.com/StephenHuge/Algorithms01\" target=\"_blank\" rel=\"noopener\">作业的一个实现</a><br>[3] <a href=\"https://github.com/StephenHuge/Algorithms01/tree/master/ppt\" target=\"_blank\" rel=\"noopener\">课件下载（Lecture Slides）</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/13/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%201%20%20%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%EF%BC%88Dynamic%20Connectivity%EF%BC%892/","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法4（Algorithms4）- Part 1  动态连通性（Dynamic Connectivity）1","date":"2017-10-02T08:42:40.000Z","path":"2017/10/02/算法4（Algorithms4）- Part 1  动态连通性（Dynamic Connectivity）1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Algorithms4-top.jpg?raw=true\" alt=\"Algorithms4-TOP\"></p>\n<p>本系列文章记录学习的过程。</p>\n<a id=\"more\"></a>\n<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0. 前言\"></a>0. 前言</h1><p>由于课程授课和课件（Lecture Slides）均为英文，所以文中许多专有名词会标注英文，中文翻译参考《Algorithms Fourth Edition》中文版。课件以及其它资料下载链接会在文末给出。</p>\n<h1 id=\"1-动态连通性（Dynamic-Connectivity）\"><a href=\"#1-动态连通性（Dynamic-Connectivity）\" class=\"headerlink\" title=\"1. 动态连通性（Dynamic Connectivity）\"></a>1. 动态连通性（Dynamic Connectivity）</h1><h3 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h3><p>什么是动态连通性？  </p>\n<blockquote>\n<p>Given a set of N objects.<br>・Union command: connect two objects.<br>・Find/connected query: is there a path connecting the two objects?  </p>\n</blockquote>\n<p>给定几个数的集合  </p>\n<ul>\n<li>Union操作： 在两个数之间加一条连接。  </li>\n<li>Find/connected查询： 判断两个数之间是否有连接。  </li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/Union-Find.jpg?raw=true\" alt=\"Union-Find\"></p>\n<h3 id=\"1-2-建立模型\"><a href=\"#1-2-建立模型\" class=\"headerlink\" title=\"1.2 建立模型\"></a>1.2 建立模型</h3><p>如何选择具体的数据结构模型呢？<br>动态连通性的应用十分广泛：</p>\n<ul>\n<li>照片的像素</li>\n<li>网络中的电脑</li>\n<li>社交网络中的两个人</li>\n<li>电路芯片中的晶体管</li>\n<li>数学集合中的元素<br>…  </li>\n</ul>\n<p>比较容易实现的选择：<strong>使用数组，让数组的每个下标代表每个数</strong>。</p>\n<p>我们继续假设： “<code>相连</code>（is connected to）” 是两个数之间的一种关系，且这种关系满足以下条件：  </p>\n<ul>\n<li>自反性（Reflexive）： p和p是相连的；  </li>\n<li>对称性（Symmetric）： 如果p和q是相连的，那么q和p也是相连的；  </li>\n<li>传递性（Transitive）： 如果p和q相连且q和r相连，那么p和r相连。  </li>\n</ul>\n<p>当两个数相连时，它们属于同一个<code>等价类</code>（Connected Components）。<br><code>等价类</code>，就是所有相连的数的集合，这个集合必须包含所有相连的数。  <center><br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/ConnectedComponents.jpg?raw=true\" alt=\"ConnectedComponents\"></p>\n</center>\n具体的操作，给定两个数：  \n- Find操作： 查看两个数是否属于同一个等价类。  \n- Union操作： 将两个数连接起来，这个操作其实就是将两个数所在的等价类联合成一个等价类。  \n\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/UnionFindOperation.jpg?raw=true\" alt=\"UnionFindOperation\"></p>\n<p>在这里约定一下使用的术语：</p>\n<center>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">英文</th>\n<th align=\"center\">汉语术语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Connected Components</td>\n<td align=\"center\">等价类 / 分量</td>\n</tr>\n<tr>\n<td align=\"center\">node</td>\n<td align=\"center\">节点</td>\n</tr>\n</tbody></table>\n</center>\n### 1.3 Union-Find数据类型（Union-Find data type）\n由1.2 我们得出了简单的数据模型，现在需要设计具体的数据类型，我们的目标是：\n- 为Union-Find操作设计出一个高效的数据类型\n- 每个数据类型包含N个数，N可能会很大\n- 操作的次数M可能很大\n- Find操作和Union操作可能会交叉进行\n\n<p>以下是API：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">public class UF</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">UF(int N)</td>\n<td align=\"center\">用整数N(0到N-1)初始化N个点</td>\n</tr>\n<tr>\n<td align=\"center\">void union(int p, int q)</td>\n<td align=\"center\">为点p和点q之间添加一条连接</td>\n</tr>\n<tr>\n<td align=\"center\">boolean connected(int p, int q)</td>\n<td align=\"center\">判断点p和点q是否属于同一个分量</td>\n</tr>\n<tr>\n<td align=\"center\">int find(int p)</td>\n<td align=\"center\">p所在分量的标识符（0到N-1）</td>\n</tr>\n<tr>\n<td align=\"center\">int count()</td>\n<td align=\"center\">分量的数量</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-Quick-Find算法\"><a href=\"#2-Quick-Find算法\" class=\"headerlink\" title=\"2. Quick Find算法\"></a>2. Quick Find算法</h1><h3 id=\"2-1-数据结构\"><a href=\"#2-1-数据结构\" class=\"headerlink\" title=\"2.1 数据结构\"></a>2.1 数据结构</h3><ul>\n<li>整数型数组id[]，长度为N。</li>\n<li>p和q是相连的等价于数组中p下标和q下标的数相同。</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/QuickFind.jpg?raw=true\" alt=\"QuickFind\"></p>\n<h3 id=\"2-2-Java实现\"><a href=\"#2-2-Java实现\" class=\"headerlink\" title=\"2.2 Java实现\"></a>2.2 Java实现</h3><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/QuickFind-Java.jpg?raw=true\" alt=\"QFJava\"></p>\n<h3 id=\"2-3-算法分析\"><a href=\"#2-3-算法分析\" class=\"headerlink\" title=\"2.3 算法分析\"></a>2.3 算法分析</h3><p>QuickFind算法太慢了。<br>下表是最坏情况下QuickFind算法对一组点操作使用的时间消耗。</p>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th align=\"center\">初始化</th>\n<th align=\"center\">union操作</th>\n<th align=\"center\">find操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>QuickFind</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>Union操作过于缓慢：如果要对N对点进行union操作，最多需要对数组访问N^2次。</p>\n<h1 id=\"3-Quick-Union算法\"><a href=\"#3-Quick-Union算法\" class=\"headerlink\" title=\"3. Quick Union算法\"></a>3. Quick Union算法</h1><h3 id=\"3-1-数据结构\"><a href=\"#3-1-数据结构\" class=\"headerlink\" title=\"3.1 数据结构\"></a>3.1 数据结构</h3><ul>\n<li>整数型数组id[]，长度为N。</li>\n<li>id[i]中存储i的父节点（ 也就是形成一个链接，直到其父节点就是它自己，说明到头了）</li>\n<li>i的根节点（root）是id[id[id[id[…id[i]…]]]]</li>\n</ul>\n<p>具体操作：</p>\n<ul>\n<li>Find操作：检查p和q是否拥有同一个根节点 。</li>\n<li>Union操作： 为了合并p和q各自所在的分量，将p的根节点改为q的根节点。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/QuickUnion.jpg?raw=true\" alt=\"QuickUnion\"><h3 id=\"3-2-Java实现\"><a href=\"#3-2-Java实现\" class=\"headerlink\" title=\"3.2 Java实现\"></a>3.2 Java实现</h3><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/QuickUnion-Java.jpg?raw=true\" alt=\"QuickUnionJava\"><h3 id=\"3-3-算法分析\"><a href=\"#3-3-算法分析\" class=\"headerlink\" title=\"3.3 算法分析\"></a>3.3 算法分析</h3>对一对点进行操作需要访问数组的次数，图中是最坏情况。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th align=\"center\">初始化</th>\n<th align=\"center\">union操作</th>\n<th align=\"center\">find操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>QuickFind</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td>QuickUnion</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N*</td>\n<td align=\"center\">N</td>\n</tr>\n</tbody></table>\n<p>*：包括了寻找根节点的操作。</p>\n<p>QuickFind的缺点</p>\n<ul>\n<li>Union操作太慢了，最差为N</li>\n<li>树是平的，但是维护这个状态时间耗费太大了</li>\n</ul>\n<p>QuickUnion的缺点</p>\n<ul>\n<li>树可能会很高</li>\n<li>Find操作太慢了，最差为N</li>\n</ul>\n<h1 id=\"4-改进1-加权（weighting）\"><a href=\"#4-改进1-加权（weighting）\" class=\"headerlink\" title=\"4. 改进1 - 加权（weighting）\"></a>4. 改进1 - 加权（weighting）</h1><h3 id=\"4-1-数据结构\"><a href=\"#4-1-数据结构\" class=\"headerlink\" title=\"4.1 数据结构\"></a>4.1 数据结构</h3><p>加权QuickUnion（Weighted QuickUnion）  </p>\n<ul>\n<li>改进QuickUnion，避免太高的树</li>\n<li>对每个树的大小（包含点的数量）进行记录</li>\n<li>union操作时，比较两个点所在树的大小，小数的根节点连接到大树的根节点之上</li>\n</ul>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/WeightedQuickUnion.jpg?raw=true\" alt=\"\"></p>\n<p>数据结构其实和QuickUnion相同，但是需要再维护一个额外的数组sz[i]，用来记录以i节点为根节点的分量的大小（及分量中数的多少）</p>\n<h3 id=\"4-2-Java实现\"><a href=\"#4-2-Java实现\" class=\"headerlink\" title=\"4.2 Java实现\"></a>4.2 Java实现</h3><p>Find操作：和QuickUnion相同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return root(p) &#x3D;&#x3D; root(q);</span><br></pre></td></tr></table></figure>\n<p>Union操作：改进的QuickUnion</p>\n<ul>\n<li>将较小的树的根节点连接到大的树的根节点上</li>\n<li>不断更新sz[]数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i &#x3D; root(p);</span><br><span class=\"line\">int j &#x3D; root (q);</span><br><span class=\"line\">        </span><br><span class=\"line\">if(i &#x3D;&#x3D; j)  return;</span><br><span class=\"line\">if(sz[i] &lt; sz[j])   &#123; id[i] &#x3D; j;    sz[j] +&#x3D; sz[i];&#125;</span><br><span class=\"line\">else                &#123; id[j] &#x3D; i;    sz[i] +&#x3D; sz[j];&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-算法分析\"><a href=\"#4-3-算法分析\" class=\"headerlink\" title=\"4.3 算法分析\"></a>4.3 算法分析</h3><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/quickunion-weightedTrees.jpg?raw=true\" alt=\"quickunion-weightedTrees\"><br>运行时间  </p>\n<ul>\n<li>Find操作： 时间和p以及q的深度成正比  </li>\n<li>Union操作： 给定根节点，时间为常数  </li>\n</ul>\n<p><strong>命题</strong>： 任意节点x，其深度最大为lg N 。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/weighted-depth.jpg?raw=true\" alt=\"\">  </p>\n<p><strong>证明</strong>:<br>什么时候x的深度会增大呢？  </p>\n<p>当树T2比树T1大，即|T2| &gt;= |T1|时，包含x的树T1成为另一个树T2的子树时，x的深度会加1。由此推出：  </p>\n<ul>\n<li>T1和T2合起来的新树，其大小至少是之前T1的2倍。（也就是x所在的树大小增大1倍，x的深度加1）</li>\n<li>包含x的树最多可以翻倍lg N 次。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/WeightedQuickUnionAnalysis.jpg?raw=true\" alt=\"WeightedQuickUnionAnalysis\"></li>\n</ul>\n<p>算法分析</p>\n<center>\n\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th align=\"center\">初始化</th>\n<th align=\"center\">union操作</th>\n<th align=\"center\">find操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>QuickFind</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td>QuickUnion</td>\n<td align=\"center\">N</td>\n<td align=\"center\">N*</td>\n<td align=\"center\">N</td>\n</tr>\n<tr>\n<td>weighted QU</td>\n<td align=\"center\">N</td>\n<td align=\"center\">(lg N)*</td>\n<td align=\"center\">lg N</td>\n</tr>\n</tbody></table>\n</center>\n*：包括了寻找根节点的操作。\n\n<p>还可以优化吗？答案是肯定的。</p>\n<h1 id=\"5-改进2-路径压缩（Path-Compression）\"><a href=\"#5-改进2-路径压缩（Path-Compression）\" class=\"headerlink\" title=\"5. 改进2 - 路径压缩（Path Compression）\"></a>5. 改进2 - 路径压缩（Path Compression）</h1><h3 id=\"5-1-数据结构\"><a href=\"#5-1-数据结构\" class=\"headerlink\" title=\"5.1 数据结构\"></a>5.1 数据结构</h3><p>在计算点p的根节点root之后，每个经过的节点，如果其根节点不为root的话，让其根节点变成root，如图是带路径压缩的QuickUnion算法（Quick Union with Path Compression），下图是具体的过程。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/PathCompression.jpg?raw=true\" alt=\"\"></p>\n<h3 id=\"5-2-Java实现\"><a href=\"#5-2-Java实现\" class=\"headerlink\" title=\"5.2 Java实现\"></a>5.2 Java实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int root(int i) &#123;</span><br><span class=\"line\">    int temp;   &#x2F;&#x2F; 临时节点</span><br><span class=\"line\">    </span><br><span class=\"line\">    while(i !&#x3D; id[i]) &#123;</span><br><span class=\"line\">        temp &#x3D; id[i];   &#x2F;&#x2F; 用临时节点记录i节点的父节点</span><br><span class=\"line\">        id[i] &#x3D; find(i);&#x2F;&#x2F; 将i节点的父节点置为根节点</span><br><span class=\"line\">        i &#x3D; temp;       &#x2F;&#x2F; 对i节点之前的父节点进行重复性判断</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-算法分析\"><a href=\"#5-3-算法分析\" class=\"headerlink\" title=\"5.3 算法分析\"></a>5.3 算法分析</h3><p>使用带路径压缩的加权Quick Union算法，对于N个数，M次操作时，访问数组次数最多为c (N + M lg* N)。<br>（c为常数， lg* N是lg(lg(lg(…lg()…)))。）  </p>\n<p>对于N个数，M次操作时，有没有线性访问数组次数的算法呢？</p>\n<ul>\n<li>理论上， WQUPC（Weighted Quick Union &amp; Path Compression）不是线性的</li>\n<li>实际中，WQUPC基本是线性的</li>\n</ul>\n<p>现已证明，没有完全的线性算法存在。</p>\n<h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h1><p>使用带路径压缩的加权Quick Union算法，使得之前不可能被解决的问题现在可以被解决。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/Part%201/all%20algorithms.jpg?raw=true\" alt=\"\"></p>\n<p>对于10^9次union操作和10^9次find操作：</p>\n<ul>\n<li>WQUPC让时间从30年变成了6s</li>\n<li>超级计算机并不能帮助太多，但是好的算法可以让问题得到充分解决</li>\n</ul>\n<h1 id=\"参考网址\"><a href=\"#参考网址\" class=\"headerlink\" title=\"参考网址\"></a>参考网址</h1><p>[1] <a href=\"https://www.coursera.org/learn/algorithms-part1/home/welcome\" target=\"_blank\" rel=\"noopener\" title=\"课程首页\">课程首页（Course Page）</a><br>[2] <a href=\"http://algs4.cs.princeton.edu/11model/\" target=\"_blank\" rel=\"noopener\" title=\"课程首页\">Algorithms 4th</a><br>[3] <a href=\"https://github.com/StephenHuge/Algorithms01/tree/master/ppt\" target=\"_blank\" rel=\"noopener\">课件下载（Lecture Slides）</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/10/02/%E7%AE%97%E6%B3%954%EF%BC%88Algorithms4%EF%BC%89-%20Part%201%20%20%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7%EF%BC%88Dynamic%20Connectivity%EF%BC%891/","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"学分绩计算器","date":"2017-09-24T13:02:36.000Z","path":"2017/09/24/学分绩计算器/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/%E9%9D%A2%E8%AF%95/GPA_top.jpg?raw=true\" alt=\"GPA\"></p>\n<h1 id=\"学分绩计算器\"><a href=\"#学分绩计算器\" class=\"headerlink\" title=\"学分绩计算器\"></a>学分绩计算器</h1><p>最近到了求职季，各种填简历，各种笔试，无论结果如何，的确是学习到了很多。本文是自己写的一个学分绩的计算器，代码十分简单。</p>\n<a id=\"more\"></a>\n<h2 id=\"Java中不定行数的输入\"><a href=\"#Java中不定行数的输入\" class=\"headerlink\" title=\"Java中不定行数的输入\"></a>Java中不定行数的输入</h2><p>笔试题中常常出现一些多行输入，然后处理这些输入得到结果的编程题，如果先给出元素的行数，比较好处理，但是一些不定长的输入就比较麻烦，因为不太好判定具体哪行截止，我用的方法是这样的：</p>\n<pre><code>Scanner in = new Scanner(System.in);\nwhile(true) {\n    String nextLine = in.nextLine();\n    // 如果输入行为空则跳出循环\n    if (nextLine == null || nextLine.trim().length() == 0)  break;\n    // manage the data\n}\n// other logics</code></pre><p>其实就是先将该行输入用变量<code>nextLine</code>存储起来，之后判断它是否为空，为空则直接跳出循环，表示输入完毕；不为空再进行对这个<code>String</code>变量处理。如果直接用<code>in.hasNextLine()</code>判断的话，这个输入已经被用来判定了，就无法再去使用它了。</p>\n<h2 id=\"学分绩计算器-1\"><a href=\"#学分绩计算器-1\" class=\"headerlink\" title=\"学分绩计算器\"></a>学分绩计算器</h2><p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/%E9%9D%A2%E8%AF%95/%E5%AD%A6%E5%88%86%E7%BB%A9%E8%AE%A1%E7%AE%97%E5%99%A8%E9%85%8D%E5%9B%BE.jpg?raw=true\" alt=\"GPA对应图\"></p>\n<p>上图是某公司使用的学分绩对应表，我发现其中有许多计算方式。网上有很多GPA计算器，但都计算方法各异，没有找到上图对应的计算器，所以自己写了一个。其实逻辑相当简单，可以用一下伪代码表示：</p>\n<pre><code>// store the data\nstore(input);\n//manage the data\ncalculate();\n// output the answer\nprint(answer);</code></pre><p>就是简单的对数据进行存储，处理和输出。如果长段的在文章中粘代码十分影响阅读效率和心情，因为冗长的代码容易让阅读者陷入代码的具体逻辑不能自拔，并且许多时候阅读界面的代码格式并不友好。所以每个方法会逐个实现，在文章最后贴出完整代码。<br>我们的要求是输入多门课程所占学分以及对应考试分数，输入完后输出课程的数量，课程的总学分和计算得出的GPA。<br>要求明确了，我们分析一下代码的结构。代码分三步走：</p>\n<ol>\n<li>存储输入代码。<br> 格式为 <code>课程所占学分 考试分数</code> ，中间用空格隔开。</li>\n<li>计算GPA<br> 输入完毕后，逐个计算对应的分数，得出GPA</li>\n<li>输出GPA<br> 打印输出计算结果</li>\n</ol>\n<p>样例输入：  </p>\n<pre><code>3.0 82  \n2.0 91  \n2.0 88  </code></pre><p>样例输出：  </p>\n<pre><code>credits: 7.0\ncourses: 3\nGPA: 3.62</code></pre><p>以下是每个具体的方法：<br>1.存储输入代码。<br>    由于是输入完毕才有输出，所以必须要考虑如何存储输入的数据，输入了一个数据对，貌似可以使用<code>HashMap</code>来存储。但是由于课程所占学分可能重复，而成绩也有可能重复，两个数都不适合来作为<code>key</code>，所以<code>HashMap</code>不合适。<br>    最终决定使用一个<code>ArrayList</code>来存储，其中泛型使用一个内部类<code>Grade</code>，<code>Grade</code>表示成绩，其中有两个成员变量：<code>double</code>类型的课程学分和<code>int</code>类型的成绩。</p>\n<pre><code>ArrayList&lt;Grade&gt; grades = new ArrayList&lt;&gt;();\n...\nstatic class Grade {\n    double credit;   // 课程所占学分\n    int score;      // 最终考试分数\n}</code></pre><p>完整的存储方法<code>store()</code>如下：</p>\n<pre><code>String nextLine = in.nextLine();\nGrade g = null;    //声明一个Grade变量g，用来不断存储输入成绩\n\nprivate static void store(String input, Grade g, ArrayList&lt;Grade&gt; grades) {\n    String[] nextLines = input.split(&quot; &quot;);  //将输入的两个数提取出来\n    g = new Grade();\n    g.credit = Double.parseDouble(nextLines[0]);    // 每门课的学分\n    g.score = Integer.parseInt(nextLines[1]);   // 每门课的成绩\n    grades.add(g);\n}</code></pre><p>2.计算GPA<br>    由于GPA计算时，需要最后除以总的学分数，所以我们需要一个单独的方法 <code>calculateCredit</code> 计算所有的学分数，可以在存储的时候直接计算，但是由于一般处理数据数量不太大，所以单独遍历<code>ArrayList</code>获取也是可以的：</p>\n<pre><code>private static double calculateCredit(ArrayList&lt;Grade&gt; grades) {\n    double ans = 0;\n    for(Grade g: grades) {\n        ans += g.credit;\n    }\n    return ans;\n}</code></pre><p>之后计算GPA：遍历<code>ArrayList</code>，对应每个分数段会有不同的计算方式，这是最长的一个方法。</p>\n<pre><code>private static double calculatePoint(ArrayList&lt;Grade&gt; grades) throws Exception {\n    // 绩点\n    double[] points = {    \n            4.33, 4.00, 3.67, 3.33,\n            3.00, 2.67, 2.33, 2.00,\n            1.67, 1.33, 1.00, 0.00\n    };\n    // 结果\n    double ans = 0;\n    Grade g;\n    for(Grade grade : grades) {\n        g = grade;\n        int s = g.score;\n\n        //compute\n        if(s &lt; 0 || s &gt; 100)    throw new Exception(&quot;Illegal Input!!&quot;);\n        if(s &gt;= 95) {\n            ans += g.credit * points[0];\n        } else if(s &gt;= 90) {\n            ans += g.credit * points[1];\n        }  else if(s &gt;= 85) {\n            ans += g.credit * points[2];\n        }  else if(s &gt;= 82) {\n            ans += g.credit * points[3];\n        }  else if(s &gt;= 78) {\n            ans += g.credit * points[4];\n        }  else if(s &gt;= 75) {\n            ans += g.credit * points[6];\n        } else if(s &gt;= 72) {\n            ans += g.credit * points[7];\n        } else if(s &gt;= 68) {\n            ans += g.credit * points[8];\n        } else if(s &gt;= 64) {\n            ans += g.credit * points[9];\n        }  else if(s &gt;= 61) {\n            ans += g.credit * points[10];\n        }  else if(s == 60) {\n            ans += g.credit * points[11];\n        } else \n            continue;\n    }\n    double credits = calculateCredit(grades);   //获取总学分\n    ans = ans / credits;\n    return ans;\n}</code></pre><p>代码很长，但逻辑十分简单，就是对每个输入的成绩进行判定，乘以相应的绩点，然后加到总的结果上，最终除以总学分数就得出结果了。<br>3.输出GPA<br>    输出便很简单了，我们将完整的<code>main</code>方法贴出来：</p>\n<pre><code>public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    ArrayList&lt;Grade&gt; grades = new ArrayList&lt;&gt;();\n    Grade g = null;\n    // store\n    while(true) {\n        String nextLine = in.nextLine();\n        if (nextLine == null || nextLine.trim().length() == 0)  break;\n        store(nextLine, g, grades);\n    }\n    //calculate\n    double ans = -1;\n    try {\n        ans = calculatePoint(grades);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        in.close();\n    }\n    //print\n    System.out.println(&quot;credits:&quot; + calculateCredit(grades));\n    System.out.println(&quot;courses: &quot; + grades.size());\n    System.out.println(&quot;GPA: &quot; + String.format(&quot;%.2f&quot;, ans));\n}</code></pre><p>代码结构比较明显，先对输入进行存储，之后计算得出结果<code>ans</code>，最后打印题目需要的结果。</p>\n<h2 id=\"这便是一个简答的学分绩计算器的实现啦\"><a href=\"#这便是一个简答的学分绩计算器的实现啦\" class=\"headerlink\" title=\"这便是一个简答的学分绩计算器的实现啦~\"></a>这便是一个简答的学分绩计算器的实现啦~</h2><p>完整代码：<a href=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Java/%E9%9D%A2%E8%AF%95/MyGradeCalculator.java\" target=\"_blank\" rel=\"noopener\">MyGradeCalculator.java</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/09/24/%E5%AD%A6%E5%88%86%E7%BB%A9%E8%AE%A1%E7%AE%97%E5%99%A8/","tags":[{"name":"Java","slug":"Java","permalink":"https://stevehuge.gitee.io/blog/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://stevehuge.gitee.io/blog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"动态代理2","date":"2017-08-20T16:21:27.000Z","path":"2017/08/21/动态代理2/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/proxy_top.jpg?raw=true\" alt=\"代理模式\"></p>\n<h1 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h1><p>我们在上篇文章中提到通过调用<code>Proxy</code>类的<code>newProxyInstance()</code>方法生成了一个临时实例，这个实例就是我们需要的代理类。我们的代理类被动态的创建，省去了我们针对业务方法而手动实现如日志记录等功能。<br>我们继续深入，来详细看一下这个过程：</p>\n<a id=\"more\"></a>\n\n<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, \n                                            InvocationHandler h) {\n        ...        \n        //1. 获取传入的之前被代理类实现的接口\n        final Class&lt;?&gt;[] intfs = interfaces.clone();    \n        ...\n         //2. 生成设计好的代理类的Class对象\n        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);   \n        ...\n        //3. 获取生成好代理类的带参构造方法，其中参数就是InvocationHandler接口的实例\n        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);   \n\n        final InvocationHandler ih = h; \n        ...\n        //4. 通过构造方法生成代理类实例\n        return cons.newInstance(new Object[]{h});   \n        ...\n}</code></pre><p>这就是<code>Proxy</code>类<code>newProxyInstance</code>方法的核心逻辑，其中去除了一些判断和异常处理代码，这些都跟我们目前的讨论没有太大关系。<br>可以看出来，这里最重要的就是这一句：</p>\n<pre><code>//2. 生成设计好的代理类的Class对象\nClass&lt;?&gt; cl = getProxyClass0(loader, intfs);    </code></pre><p>生成了设计好的临时代理类的<code>Class</code>对象之后，我们可以使用反射获取它的构造方法进而生成它的实例，这个<code>Class</code>对象的具体生成方法是什么呢？<br>我们继续探究它的实现方式：</p>\n<pre><code>/**\n * 生成代理类的Class对象\n */\n private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,\n                                           Class&lt;?&gt;... interfaces) {\n        ...\n        // If the proxy class defined by the given loader implementing\n        // the given interfaces exists, this will simply return the cached copy;\n        // otherwise, it will create the proxy class via the ProxyClassFactory\n\n        //使用缓存获取之前生成的Class对象，如果之前未生成，则使用ProxyClassFactory生成\n        return proxyClassCache.get(loader, interfaces);\n    }</code></pre><p>这里使用到了缓存技术，如果之前生成过该类的Class对象，直接通过缓存返回它。我们这是第一次生成，看注释中提到：</p>\n<pre><code>If the proxy class defined by the given loader implementing \nthe given interfaces exists, this will simply return the cached copy;\notherwise, it will create the proxy class via the ProxyClassFactory</code></pre><p>意思是之前已经创建过这个代理类，那么直接使用缓存，未建立的话使用<code>ProxyClassFactory</code>类建立代理类，通过缓存类的代码，我们发现其中调用了<code>ProxyClassFactory</code>的<code>apply</code>方法。我们现在做的就是研究代理类的生成机理，所以来看看<code>ProxyClassFactory</code>。<br>我使用的是<code>eclipse</code>，使用快捷键：<code>Ctrl+Shift+T</code>打开搜索界面，输入<code>ProxyClassFactory</code>，找到这个类。这个类其实是<code>Proxy</code>类 的一个内部类，我们通过<code>eclipse</code>发现其中只有一个方法<code>apply</code>，看来就是它了，它的代码是：</p>\n<pre><code>public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {\n    ...\n    //1. 生成指定的代理类的二进制数组\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n    proxyName, interfaces, accessFlags);    \n    ...\n    //2. 通过生成的二进制数组proxyClassFile生成一个Class&lt;?&gt;类型的实例，这是一个native方法\n    return defineClass0(loader, proxyName,\n                    proxyClassFile, 0, proxyClassFile.length); \n}</code></pre><p>和之前一样，略去了一些判断语句和生成细节等代码。<br>我们发现直接通过<code>ProxyGenerator</code>类的<code>generateProxyClass</code>方法得到了一个二进制文件，这个也就是我们平时说的<code>.class</code>文件。到此处已经比较清楚代理类的生成过程了，之后二进制文件的具体生成步骤不再跟进，有兴趣的读者可以继续深入研究。<br>最后根据这个<code>.class</code>文件通过虚拟机加载，解析，初始化生成代理类的<code>Class</code>类对象，最终，使用反射获取其构造方法后生成代理类的对象。  </p>\n<p>我们通过下面的图看可能会清晰一点：  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/Proxy%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE.jpg?raw=true\" alt=\"Proxy函数调用图\"></p>\n<p>其实用户接触的只有一个<code>newProxyInstance</code>方法，其余的方法都是层层调用被使用的。其实就具体就干了两件事：生成代理类<code>Class</code>对象和生成代理类对象，后者依赖于前者。<br>按照图中标注的顺序而且根据方法具体的行为来说：<br>a. 外部测试代码调用<code>Proxy</code>类的<code>newProxyInstance</code>方法<br>b. <code>newProxyInstance</code>方法中调用了<code>Proxy</code>类的<code>getProxyClass0</code>方法<br>c. <code>getProxyClass0</code>方法中调用<code>Proxy</code>类的内部类<code>ProxyClassFactory</code>类的<code>apply</code>方法<br>d. <code>ProxyClassFactory</code>类的<code>apply</code>方法中调用<code>ProxyGenerator</code>类的<code>generateProxyClass</code>方法，这步生成了一个二进制数组<br>e. <code>generateProxyClass</code>方法把二进制数组返回给<code>apply</code>方法<br>f. 之后<code>apply</code>方法继续调用<code>native</code>方法<code>defineClass0</code>，然后生成了一个<code>Class</code>类对象<br>g. <code>Class</code>对象返回给<code>apply</code>方法<br>h. <code>Class</code>对象返回给<code>getProxyClass0</code>方法<br>i. <code>Class</code>对象返回给<code>newProxyInstance</code>方法<br>j. <code>newProxyInstance</code>方法中使用返回的<code>Class</code>对象，通过反射获取其带参构造方法，之后生成一个代理类的对象，返回给测试类  </p>\n<p>具体行为对应的方法：<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95%E4%BD%9C%E7%94%A8.jpg?raw=true\" alt=\"动态代理具体方法作用\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>[1] <a href=\"http://blog.csdn.net/luanlouis/article/details/24589193#t2\" target=\"_blank\" rel=\"noopener\">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a>  </p>\n<p>[2] <a href=\"http://blog.csdn.net/zhangerqing/article/details/42504281\" target=\"_blank\" rel=\"noopener\">Java之美[从菜鸟到高手演练]之JDK动态代理的实现及原理）</a>  </p>\n<p>[3] <a href=\"https://mp.weixin.qq.com/s/t5pU_aHiqQt3yUJKgs4hqQ\" target=\"_blank\" rel=\"noopener\">JAVA 动态代理</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/08/21/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%862/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://stevehuge.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"https://stevehuge.gitee.io/blog/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://stevehuge.gitee.io/blog/tags/AOP/"},{"name":"Proxy","slug":"Proxy","permalink":"https://stevehuge.gitee.io/blog/tags/Proxy/"}]},{"title":"动态代理1","date":"2017-08-20T12:40:27.000Z","path":"2017/08/20/动态代理1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/proxy_top.jpg?raw=true\" alt=\"代理模式\"></p>\n<h1 id=\"0-代理模式\"><a href=\"#0-代理模式\" class=\"headerlink\" title=\"0. 代理模式\"></a>0. 代理模式</h1><p>代理模式是一个很常见的设计模式，简单来说就是代理类<code>Proxy</code>替被代理类做一些东西。其中具体又有静态代理和动态代理两种。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. 静态代理</h2><p>现在移动支付在中国各个大中小城市都已经非常普及了，平时我们出去吃饭购物都可以使用支付宝或者微信支付轻松完成交易，而不再使用现金。我们现在就以这个作为例子来说明一下代理模式。<br>有两个角色：微信支付（<code>WeChatPay</code>）和银行（<code>Bank</code>），微信支付本质上就是银行的一个代理。每当你使用微信支付付款时，事实上是微信支付“代理”你和银行进行交互，最终完成了支付。两个类的代码如下：</p>\n<p>Bank.java</p>\n<pre><code>public class Bank {\n    ...\n    public void pay() { //付款功能\n        ...\n    }\n    public void gathering() {   //收款功能\n        ...\n    }\n    ...\n}</code></pre><p>WeChatPay.java</p>\n<pre><code>public class WeChatPay {\n    ...\n    public void pay() { //付款功能\n        ...\n    }\n    public void gathering() {   //收款功能\n        ...\n    }\n    ...\n}</code></pre><p>我们发现两个类的方法都是一样的，两个类的本质功能一致，都是对我们的财产进行管理，所以给它们抽象出一个共同的接口：<br>WealthManagement.java</p>\n<pre><code>public interface WealthManagement {\n    public void pay();\n\n    public void gathering();\n}</code></pre><p>然后让两个类均实现这个接口。同时由于微信支付是代理了银行的功能，事实上工作的实体是银行,所以一般它需要绑定一个银行类，我们改变后的代码是：<br>WeChatPay.java</p>\n<pre><code>public class WeChatPay implements WealthManagement {\n    ...\n    private Bank bank = new Bank();\n\n    public void pay() { //付款功能\n        bank.pay();\n    }\n    public void gathering() {   //收款功能\n        bank.gathering();\n    }\n    ...\n}</code></pre><p>一个最简单的微信支付模型出来了，它其中有一个银行类的成员变量，每当需要进行付款或者收款操作时，它都会调用银行的收款和付款方法。<br>看起来还不错，但是仍然有需要改进之处：<br>(1) 我们不希望在微信支付中固定某个银行，而是希望用户能在使用微信时手动的添加；<br>(2) 微信支付调用了银行的功能，我们希望给用户一些提示，告知他们正在使用微信支付代理而非原版的银行功能。<br>加上之后这两个请求之后，完整的微信支付功能如下：<br>WeChatPay.java</p>\n<pre><code>public class WeChatPay implements WealthManagement {\n    //...\n    private Bank bank;\n\n    public WeChatPay(Bank bank) {\n        this.bank = bank;\n    }\n\n    public void pay() { //付款功能\n        System.out.println(&quot;您正在使用微信支付...&quot;);\n        bank.pay();\n        System.out.println(&quot;微信支付使用完毕...&quot;);\n    }\n    public void gathering() {   //收款功能\n        System.out.println(&quot;您正在使用微信支付...&quot;);\n        bank.gathering();\n        System.out.println(&quot;微信支付使用完毕...&quot;);\n    }\n    //...\n}</code></pre><p>我们使用构造方法传入一个银行类变量<code>bank</code>，进行指定具体的银行，并且在微信支付的每个方法中都加入了提醒功能。<br>完整的银行代码：<br>Bank.java</p>\n<pre><code>public class Bank implements WealthManagement {\n    //...\n    public void pay() { //付款功能\n        System.out.println(&quot;使用银行的付款功能&quot;);\n    }\n    public void gathering() {   //收款功能\n        System.out.println(&quot;使用银行的收款功能&quot;);\n    }\n    //...\n}</code></pre><p>现在貌似可以使用了，我们写一个测试类<code>Test</code>测试一下：<br>Test.java</p>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        Bank construction = new Bank();\n\n        WeChatPay wePay = new WeChatPay(construction);\n\n        wePay.pay();\n        System.out.println(&quot;----------&quot;);\n        wePay.gathering();\n    }\n}</code></pre><p>打印结果:</p>\n<pre><code>您正在使用微信支付...\n使用银行的付款功能\n微信支付使用完毕...\n----------\n您正在使用微信支付...\n使用银行的收款功能\n微信支付使用完毕...</code></pre><p>这其实就是一个简单的代理模式的例子。被代理类（<code>Bank</code>类）和代理类（<code>WeChatPay</code>类）实现同一个接口，然后代理类（<code>WeChatPay</code>类）持有一个被代理类（<code>Bank</code>类）的成员变量。这样做两个类实现了同样的方法，代理类（<code>WeChatPay</code>类）中的方法会调用自己持有的被代理类（<code>Bank</code>类）对象的方法，相当于是“包装”了一下被代理类的方法。代理类（<code>WeChatPay</code>）做的就是在被代理类（<code>Bank</code>）的基础上加一点工作，它是为被代理类服务的。    </p>\n<p>这个例子中就是：微信支付<code>WeChatPay</code>代理银行<code>Bank</code>让用户进行财产管理操作，在我们使用微信支付的付款<code>pay</code>方法时，事实上调用的是<code>Bank</code>的<code>pay</code>方法，只不过这个过程在微信<code>WeChatPay</code>的<code>pay</code>方法的“代理”下完成，微信支付的<code>pay</code>方法对银行的<code>pay</code>方法进行了一下“包装”，在其前后添加了两个提醒的功能。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/%E9%93%B6%E8%A1%8C_%E5%BE%AE%E4%BF%A1%E4%BB%A3%E7%90%86.jpg?raw=true\" alt=\"银行_微信代理\"></p>\n<p>这就是一个静态代理的简单的例子。想说明的一点就是：代理模式就是通过一个代理类来替一个正常工作的类完成额外的一些操作，这些操作对于被代理类来说可以完全不用知道，由代理类完成即可。<br>例如简单的日志打印模块，我们需要在业务操作之前之后打印相关数据的日志，输入为一个业务操作相关的实例。<br>我们用代理模式完成，只需要在代理类（日志打印模块）中传入这个实例（业务操作），通过业务操作实例的一些get方法获取一些数据，然后用代理类（日志打印模块）的打印方法打印出这些数据，之后再去调用正常的业务方法即可。  </p>\n<h3 id=\"原理分析以及静态代理的问题\"><a href=\"#原理分析以及静态代理的问题\" class=\"headerlink\" title=\"原理分析以及静态代理的问题\"></a><strong>原理分析以及静态代理的问题</strong></h3><p>静态代理是AOP（Aspect Oriented Programming， 面向切面编程）最简单的实现，想在多个相同实例的方法之前之后都加上点权限管理或者类似的功能，那么使用代理类就可以轻松完成而不用修改代码。  </p>\n<p>我们针对上面的例子深入分析：<br>当在代码阶段规定好了代理关系（微信支付代理银行支付，我们需要支付操作时，直接使用微信支付即可）后，微信支付类<code>WeChatPay</code>类通过编译器编译成<code>class</code>文件，当系统运行时，此<code>class</code>已经存在了。这种静态的代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；<br>并且由于<code>WeChatPay</code>和<code>Bank</code>的功能 本质上是相同的，<code>WeChatPay</code>只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。<br>让我们把这个例子补充的更完整一点：对应到现实生活中就是除了使用微信支付进行付款和收款操作之外，我们有时可能还需要进行退款（<code>refund</code>）操作，如果继续使用之前的方法，操作就是：<br>（1） 在<code>WealthManagement</code>接口中添加<code>refund</code>方法；<br>（2） 在<code>Bank</code>类中实现<code>refund</code>方法；<br>（3） 在<code>WeChatPay</code>类中实现<code>refund</code>方法。  </p>\n<p>实现<code>refund</code>方法的WeChatPay.java</p>\n<pre><code>public class WeChatPay implements WealthManagement {\n    //...\n\n    public void refund() { //退款功能\n        System.out.println(&quot;您正在使用微信支付...&quot;);\n        bank.refund();\n        System.out.println(&quot;微信支付使用完毕...&quot;);\n    }\n    //...\n}</code></pre><p>如果以后要再实现其它新的方法时，也要重复上述三个步骤。  </p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/%E5%BE%AE%E4%BF%A1_%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%B1%80%E9%99%90.jpg?raw=true\" alt=\"微信_静态代理局限\"></p>\n<p>我们发现，第（3）步中事实上只是继续在“包装”<code>Bank</code>的<code>refund</code>方法前后继续添加提醒功能。其内容和<code>pay</code>以及<code>gathering</code>方法几乎一样，这样做其实导致业务代码中夹杂了大量的重复的提醒代码，做了大量不必要的重复性工作，同时系统的冗余大量增加。</p>\n<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%A0%81.jpg?raw=true\" alt=\"静态代理代码\"></p>\n<p>提醒代码事实上只有一份就足够了。如何实现呢？<br>我们希望可以一次性实现这个功能，之后我们不再需要对每个具体的被代理方法实现对应的代理方法。这叫做<strong>针对某一类功能实现</strong>：例如说提示功能，不需要每个业务方法都有一个对应的带提醒的“包装”方法，而是最好由一个类或者一个方法直接实现所有的提醒功能，类似可以实现的功能还有日志打印。<br>这时不得不提一个很厉害的工具——<strong>动态代理</strong>。</p>\n<p>动态代理正是为了解决代理类中代码爆炸的问题而出现的。具体实现为：在运行状态中，需要代理的地方，根据代理接口和被代理类，动态地创建一个代理类，用完之后，就会销毁，无需我们手动去创建代理类，这样就可以避免了代理类角色的<code>class</code>在系统中代码冗杂的问题了。  </p>\n<h2 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. 动态代理</h2><p>上述的问题使用动态代理该怎么做呢？我们看代码：<br>动态代理类NewWeChatPay.java</p>\n<pre><code>public class NewWeChatPay implements InvocationHandler {\n\n    private Object obj;\n\n    public NewWeChatPay(Object obj) {\n        this.obj = obj;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(&quot;您正在使用微信支付...&quot;);\n\n        Object result = method.invoke(obj, args);\n\n        System.out.println(&quot;微信支付使用完毕...&quot;);\n\n        return result;\n    }\n}</code></pre><p>在这里<code>NewWeChatPay</code> 是一个新的微信支付类，它实现了<code>InvocationHandler</code>接口。这个接口是个调用处理器，每当我们生成的代理类执行方法时，都会调用这个接口实现类的方法。我们先不着急了解它的原理，因为在下一篇文章中会详细阐述。   </p>\n<p>测试类 DynamicTest.java</p>\n<pre><code>import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class DynamicTest {\n    public static void main(String[] args) throws Throwable {\n\n        Bank construction = new Bank();  //这是一个银行实例\n\n        InvocationHandler handle = new NewWeChatPay(construction); //新建一个微信支付调用处理器\n\n        ClassLoader loader = handle.getClass().getClassLoader(); //获取加载handle的类加载器\n\n        Class[] interfaces = construction.getClass().getInterfaces();  //获取银行实现的接口\n\n\n        InvocationHandler h = handle;\n\n        Object proxy = Proxy.newProxyInstance(loader, interfaces, h);     //这一句生成了代理银行的微信支付类\n\n        WealthManagement myProxy = (WealthManagement) proxy;\n\n        myProxy.pay();    //微信支付代理类执行pay方法\n\n    }\n}</code></pre><p>打印结果：</p>\n<pre><code>您正在使用微信支付...\n使用银行的付款功能\n微信支付使用完毕...</code></pre><p>看着很长，但是大家不要怕，其实主要就一句：</p>\n<pre><code>Object proxy = Proxy.newProxyInstance(loader, interfaces, h);     //这一句生成了代理银行的微信支付类</code></pre><p>调用<code>Proxy</code>类的<code>newProxyInstance()</code>方法生成了一个代理类实例，这个实例就是我们需要的代理类。<br>我们发现，在使用动态代理之后，的确减少了代码量。之前<code>Bank</code>类的每个方法都需要代理类实现对应的方法，而现在，只需要<code>NewWeChatPay</code>类中的一个<code>invoke</code>方法就可以完成多个方法的代理。<br>在动态代理中生成的代理类是一个临时的类，我们的代理类需要实现<code>Bank</code>类所实现的接口，所以传入了<code>Bank</code>实现的接口，传入其类加载器是为了确认这些接口的Class类对象和动态代理类的Class对象都是被同一个类加载器加载的，最后的<code>InvocationHandler</code>接口的实例就是我们之前创建好的调用处理器。<br><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/Reflection%20&%20Proxy/%E5%BE%AE%E4%BF%A1_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%85%B3%E7%B3%BB.jpg?raw=true\" alt=\"动态代理关系\"></p>\n<p>在接下来的一篇文章中，我们会详细探讨<code>Proxy</code>类的<code>newProxyInstance()</code>方法生成临时代理类的过程。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>[1] <a href=\"http://blog.csdn.net/luanlouis/article/details/24589193#t2\" target=\"_blank\" rel=\"noopener\">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a>  </p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/08/20/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%861/","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://stevehuge.gitee.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring","slug":"Spring","permalink":"https://stevehuge.gitee.io/blog/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://stevehuge.gitee.io/blog/tags/AOP/"},{"name":"Proxy","slug":"Proxy","permalink":"https://stevehuge.gitee.io/blog/tags/Proxy/"}]},{"title":"JDBC的学习过程","date":"2017-08-06T10:56:27.000Z","path":"2017/08/06/JDBC的学习过程/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/JDBC/top.jpg?raw=true\" alt=\"JDBC top\">  </p>\n<h2 id=\"一些不相关的题外话\"><a href=\"#一些不相关的题外话\" class=\"headerlink\" title=\"一些不相关的题外话  \"></a><strong>一些不相关的题外话</strong>  </h2><p>将近两个月没有更新博客了。<br>六月之后，师兄师姐们忙着毕业，各种项目上的事都接踵而至。而我在这两个月里做的事，更多的是忙着交接项目和送别。每到毕业季便都是友人送别的场景，整个实验室的气氛也是有点郁郁寡欢。<br>但这样的日子并不能长久，因为毕业季一过，便就是求职季了。所以，每日奔走于实验室、寝室和食堂之间。虽说三点一线，颇为单调，但也在这平凡的日子里，慢慢感受到，真正学到一点知识的快乐。</p>\n<a id=\"more\"></a>\n<h1 id=\"记录JDBC的学习过程\"><a href=\"#记录JDBC的学习过程\" class=\"headerlink\" title=\"记录JDBC的学习过程\"></a>记录JDBC的学习过程</h1><h2 id=\"学习心得\"><a href=\"#学习心得\" class=\"headerlink\" title=\"学习心得\"></a>学习心得</h2><p>　　最近两周学习了一下JDBC的大致原理和一些API的使用，学完再去看之前那些曾经一头雾水的SQL语句，各种曾经觉得奇怪的代码，曾经百思不得其解的Hibernate的各种配置，都变得逐渐清晰起来。除此以外，一些调用方法的方式，写代码的格式，甚至思考的方式也学习到很多。总而言之，基础知识就那么多，各种框架都是对基础知识的层层封装、组合和改进。所以，继续巩固基础应该是正确的道路。  </p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>　　整体来说，JDBC是一组公共接口，用来确定如何让应用程序和数据库打交道，而各个数据库厂商会针对JDBC公共接口提供自己的实现类。<br>　　因为前边提到过，这只是一个初学者在学习JDBC的过程中做的一些基础知识的总结，总体上会有很多不足，而且不会像书一样事无巨细的记录所有知识细节。但抱着记录所学的想法，我还是决定认真的做一下，将各个知识点具体实现为一个叫<code>MyJDBCRewrite</code> 的项目。  </p>\n<p>项目在GitHub上的地址：<a href=\"https://github.com/StephenHuge/MyJDBCReWrite\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/MyJDBCReWrite</a><br>其中分为6个包：<br><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/common\" target=\"_blank\" rel=\"noopener\">com.jdbc.common</a>：存储一些JDBC的基础知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/extensions\" target=\"_blank\" rel=\"noopener\">com.jdbc.extensions</a>： 存储一些初基础之外接近扩展工具的知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/transaction\" target=\"_blank\" rel=\"noopener\">com.jdbc.transaction</a>： 存储JDBC中关于数据库事务的知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/connectionpool\" target=\"_blank\" rel=\"noopener\">com.jdbc.connectionpool</a>： 存储JDBC中关于数据库连接池的知识</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/dbutilstest\" target=\"_blank\" rel=\"noopener\">com.jdbc.dbutilstest</a>： 存储对Apache开发的一个工具类DBUtils的简单测试</strong>  </p>\n<p><strong><a href=\"https://github.com/StephenHuge/MyJDBCReWrite/tree/master/src/com/jdbc/mytools\" target=\"_blank\" rel=\"noopener\">com.jdbc.mytools</a>： 工具包，存储自己抽取出来的一些工具代码</strong>  </p>\n<p>顺序是按照学习先后顺序和知识结构层层递进，因为在项目中有详细的注释，所以这篇文章仅作为记录和引导，不涉及具体知识点的陈述，请见谅。<br>这个项目仍然只是一个简陋的不成形的代码的集合。由于博客主题问题，无法直接评论，如果有任何错误或者疑问，可以在项目issue中提出或者给我发邮件，邮箱在博客主页中的<code>关于</code> 选项 下面给出。</p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/08/06/JDBC%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/","tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://stevehuge.gitee.io/blog/tags/JDBC/"},{"name":"数据库","slug":"数据库","permalink":"https://stevehuge.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://stevehuge.gitee.io/blog/tags/Hibernate/"}]},{"title":"JSON学习2-用JavaScript读取JSON","date":"2017-06-07T11:26:57.000Z","path":"2017/06/07/JSON学习2-用JavaScript读取JSON/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/JSON/json_top_2.jpg?raw=true\" alt=\"JSON\">  </p>\n<h1 id=\"使用JavaScript读取JSON\"><a href=\"#使用JavaScript读取JSON\" class=\"headerlink\" title=\"使用JavaScript读取JSON\"></a>使用JavaScript读取JSON</h1><p>使用JavaScript读取JSON中的内容。  </p>\n<a id=\"more\"></a>\n<h2 id=\"访问对象值\"><a href=\"#访问对象值\" class=\"headerlink\" title=\"访问对象值\"></a>访问对象值</h2><p>　　可以使用点号（.）来访问对象的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myself, myAge;</span><br><span class=\"line\">myself &#x3D; &#123; &quot;name&quot; : &quot;hjs&quot;, &quot;age&quot; : 20 &#125;;</span><br><span class=\"line\">myAge &#x3D; myself.age;</span><br></pre></td></tr></table></figure>\n<p>　　完整的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;我的测试-使用点号（.）来访问 JSON 对象的值&lt;&#x2F;title&gt;</span><br><span class=\"line\">\t&lt;&#x2F;head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t&lt;p&gt;可以使用点号（.）来访问 JSON 对象的值：&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;p id&#x3D;&quot;age&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;script&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\tvar myself, myAge;</span><br><span class=\"line\">\t\t\tmyself &#x3D; &#123; &quot;name&quot; : &quot;hjs&quot;, &quot;age&quot; : 20 &#125;;</span><br><span class=\"line\">\t\t\tmyAge &#x3D; myself.age;</span><br><span class=\"line\">\t\t\tdocument.getElementById(&quot;age&quot;).innerHTML &#x3D; myAge;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;&#x2F;script&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>　　也可以使用中括号（[]）来访问对象的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myself, myAge;</span><br><span class=\"line\">myself &#x3D; &#123; &quot;name&quot; : &quot;hjs&quot;, &quot;age&quot; : 20 &#125;;</span><br><span class=\"line\">myAge &#x3D; myself[&quot;age&quot;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环对象\"><a href=\"#循环对象\" class=\"headerlink\" title=\"循环对象\"></a>循环对象</h2><p>　　可以使用 for-in 来循环对象的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myself &#x3D; &#123; &quot;name&quot; : &quot;hjs&quot;, &quot;age&quot; : 20, &quot;phone&quot; : &quot;123-456&quot; &#125;;</span><br><span class=\"line\">for (ele in myself) &#123;</span><br><span class=\"line\">\tdocument.getElementById(&quot;element&quot;).innerHTML +&#x3D; ele + &quot;&lt;br &#x2F;&gt;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　完整代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;我的测试-使用 for-in 来循环对象的属性&lt;&#x2F;title&gt;</span><br><span class=\"line\">\t&lt;&#x2F;head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t&lt;p&gt;使用 for-in 来循环对象的属性:&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;p id&#x3D;&quot;element&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;script&gt;</span><br><span class=\"line\">\t\t\tvar myself &#x3D; &#123; &quot;name&quot; : &quot;hjs&quot;, &quot;age&quot; : 20, &quot;phone&quot; : &quot;123-456&quot; &#125;;</span><br><span class=\"line\">\t\t\tfor (ele in myself) &#123;</span><br><span class=\"line\">\t\t\t\tdocument.getElementById(&quot;element&quot;).innerHTML +&#x3D; ele + &quot;&lt;br &#x2F;&gt;&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&lt;&#x2F;script&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>　　在 for-in 循环对象的属性时，使用中括号（[]）来访问属性的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myself &#x3D; &#123; &quot;name&quot; : &quot;hjs&quot;, &quot;age&quot; : 20, &quot;phone&quot; : &quot;123-456&quot; &#125;;</span><br><span class=\"line\">for (ele in myself) &#123;</span><br><span class=\"line\">\tdocument.getElementById(&quot;element&quot;).innerHTML +&#x3D; myself[ele] + &quot;&lt;br &#x2F;&gt;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"嵌套JSON对象\"><a href=\"#嵌套JSON对象\" class=\"headerlink\" title=\"嵌套JSON对象\"></a>嵌套JSON对象</h2><p>　　JSON 对象中可以包含另外一个 JSON 对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myself &#x3D; &#123;</span><br><span class=\"line\">\t\t&quot;name&quot; :　&quot;hjs&quot;,</span><br><span class=\"line\">\t\t&quot;age&quot; : 20,</span><br><span class=\"line\">\t\t&quot;phone&quot; : &#123;</span><br><span class=\"line\">\t\t\t&quot;cellphone1&quot; : &quot;123-456&quot;</span><br><span class=\"line\">\t\t\t&quot;cellphone2&quot; : &quot;789-000&quot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>　　可以使用点号(.)或者中括号([])来访问嵌套的 JSON 对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">phone1 &#x3D; myself.phone.cellphone1;</span><br><span class=\"line\">&#x2F;&#x2F;或者</span><br><span class=\"line\">phone1 &#x3D; myself.phone[&quot;cellphone1&quot;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改值\"><a href=\"#修改值\" class=\"headerlink\" title=\"修改值\"></a>修改值</h2><p>　　可以使用点号(.)或者中括号([])来修改 JSON 对象的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myself.phone.cellphone1 &#x3D; &quot;110-110&quot;;</span><br><span class=\"line\">&#x2F;&#x2F;或者</span><br><span class=\"line\">myself.phone[&quot;cellphone1&quot;] &#x3D; &quot;110-110&quot;;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除对象属性\"><a href=\"#删除对象属性\" class=\"headerlink\" title=\"删除对象属性\"></a>删除对象属性</h2><p>　　可以使用 <code>delete</code> 关键字通过点号(.)或者中括号([])来删除 JSON 对象的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete myself.phone.cellphone1;</span><br><span class=\"line\">&#x2F;&#x2F;或者</span><br><span class=\"line\">delete myself.phone[&quot;cellphone1&quot;];</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSON数组\"><a href=\"#JSON数组\" class=\"headerlink\" title=\"JSON数组\"></a>JSON数组</h1><p>　　上篇说到了JSON中的数组，其实数组也可以作为JSON对象。<br>　　JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。<br>　　JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。  </p>\n<h2 id=\"JSON-对象中的数组\"><a href=\"#JSON-对象中的数组\" class=\"headerlink\" title=\"JSON 对象中的数组\"></a>JSON 对象中的数组</h2><p>　　对象属性的值可以是一个数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot;:&quot;hjs&quot;,</span><br><span class=\"line\">\t&quot;age&quot; : 20,</span><br><span class=\"line\">\t&quot;phone&quot; : [&quot;123-456&quot;, &quot;789-000&quot;, &quot;110-110&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　我们可以使用索引值来访问数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPhone0 &#x3D; myself.phone[0];\t&#x2F;&#x2F;&quot;123-456&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环数组\"><a href=\"#循环数组\" class=\"headerlink\" title=\"循环数组\"></a>循环数组</h2><p>　　可以使用 for-in 来访问数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (i in myself.phone) &#123;</span><br><span class=\"line\">    myPhone +&#x3D; myself.phone[i] + &quot;&lt;br&gt;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　也可以使用 for 循环：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (i &#x3D; 0; i &lt; myself.phone.length; i++) &#123;</span><br><span class=\"line\">    myPhone +&#x3D; myself.phone[i] + &quot;&lt;br&gt;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　完整代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;我的测试-使用 for-in 来循环对象的属性&lt;&#x2F;title&gt;</span><br><span class=\"line\">\t&lt;&#x2F;head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;p&gt;使用 for-in 来循环对象的属性:&lt;&#x2F;p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;p id&#x3D;&quot;element&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;script&gt;</span><br><span class=\"line\">\t\t\tvar myself &#x3D; &#123;\t&quot;name&quot;:&quot;hjs&quot;, &quot;age&quot; : 20, </span><br><span class=\"line\">\t\t\t\t&quot;phone&quot; : [&quot;123-456&quot;, &quot;789-000&quot;, &quot;110-110&quot;] &#125;;</span><br><span class=\"line\">\t\t\tvar myPhone &#x3D; &quot;&quot;;</span><br><span class=\"line\">\t\t\tfor (i in myself.phone) &#123;</span><br><span class=\"line\">\t\t\tmyPhone +&#x3D; myself.phone[i] + &quot;&lt;br&gt;&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdocument.getElementById(&quot;element&quot;).innerHTML &#x3D; myPhone;</span><br><span class=\"line\">\t\t&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"嵌套-JSON-对象中的数组\"><a href=\"#嵌套-JSON-对象中的数组\" class=\"headerlink\" title=\"嵌套 JSON 对象中的数组\"></a>嵌套 JSON 对象中的数组</h2><p>　　JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myself &#x3D; &#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;网站&quot;,</span><br><span class=\"line\">    &quot;num&quot;:3,</span><br><span class=\"line\">    &quot;phone&quot;: [</span><br><span class=\"line\">        &#123; &quot;number&quot;:&quot;123-456&quot;, &quot;info&quot;:[ &quot;123&quot;, &quot;-&quot;, &quot;456&quot; ] &#125;,</span><br><span class=\"line\">        &#123; &quot;number&quot;:&quot;789-000&quot;, &quot;info&quot;:[ &quot;789&quot;, &quot;-&quot;, &quot;000&quot; ] &#125;,</span><br><span class=\"line\">        &#123; &quot;number&quot;:&quot;110&quot;, &quot;info&quot;:[ &quot;110&quot;, &quot;-&quot; ] &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　我们可以使用 for-in 来循环访问每个数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (i in myself.phone) &#123;</span><br><span class=\"line\">    myPhone +&#x3D; &quot;&lt;h1&gt;&quot; + myself.phone[i].name + &quot;&lt;&#x2F;h1&gt;&quot;;</span><br><span class=\"line\">    for (j in myself.phone[i].info) &#123;</span><br><span class=\"line\">        myPhone +&#x3D; myself.phone[i].info[j] + &quot;&lt;br&gt;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　完整代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;我的测试-使用 for-in 来循环对象的属性&lt;&#x2F;title&gt;</span><br><span class=\"line\">\t&lt;&#x2F;head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;p&gt;使用 for-in 来循环对象的属性:&lt;&#x2F;p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;p id&#x3D;&quot;element&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;script&gt;</span><br><span class=\"line\">\t\t\tvar myself &#x3D; &#123;</span><br><span class=\"line\">\t\t\t\t&quot;name&quot;:&quot;网站&quot;,</span><br><span class=\"line\">\t\t\t\t&quot;num&quot;:3,</span><br><span class=\"line\">\t\t\t\t&quot;phone&quot;: [</span><br><span class=\"line\">\t\t\t\t\t&#123; &quot;number&quot;:&quot;123-456&quot;, &quot;info&quot;:[ &quot;123&quot;, &quot;-&quot;, &quot;456&quot; ] &#125;,</span><br><span class=\"line\">\t\t\t\t\t&#123; &quot;number&quot;:&quot;789-000&quot;, &quot;info&quot;:[ &quot;789&quot;, &quot;-&quot;, &quot;000&quot; ] &#125;,</span><br><span class=\"line\">\t\t\t\t\t&#123; &quot;number&quot;:&quot;110&quot;, &quot;info&quot;:[ &quot;110&quot;, &quot;-&quot; ] &#125;</span><br><span class=\"line\">\t\t\t\t\t]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tvar myPhone &#x3D; &quot;&quot;;</span><br><span class=\"line\">\t\t\tfor (i in myself.phone) &#123;</span><br><span class=\"line\">\t\t\t\tmyPhone +&#x3D; &quot;&lt;h1&gt;&quot; + myself.phone[i].number + &quot;&lt;&#x2F;h1&gt;&quot;;</span><br><span class=\"line\">\t\t\t\tfor (j in myself.phone[i].info) &#123;</span><br><span class=\"line\">\t\t\t\t\tmyPhone +&#x3D; myself.phone[i].info[j] + &quot;&lt;br&gt;&quot;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t\tdocument.getElementById(&quot;element&quot;).innerHTML &#x3D; myPhone;</span><br><span class=\"line\">\t\t&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改数组值\"><a href=\"#修改数组值\" class=\"headerlink\" title=\"修改数组值\"></a>修改数组值</h2><p>　　可以使用索引值来修改数组值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myself.phone[1] &#x3D; &quot;120-120&quot;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除数组元素\"><a href=\"#删除数组元素\" class=\"headerlink\" title=\"删除数组元素\"></a>删除数组元素</h2><p>　　我们可以使用 delete 关键字来删除数组元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete myself.phone[1];</span><br></pre></td></tr></table></figure>\n\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/06/07/JSON%E5%AD%A6%E4%B9%A02-%E7%94%A8JavaScript%E8%AF%BB%E5%8F%96JSON/","tags":[{"name":"JSON","slug":"JSON","permalink":"https://stevehuge.gitee.io/blog/tags/JSON/"}]},{"title":"JSON学习1-什么是JSON","date":"2017-06-06T12:44:41.000Z","path":"2017/06/06/JSON学习1-什么是JSON/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/JSON/json_top_1.jpg?raw=true\" alt=\"JSON\"></p>\n<h1 id=\"什么是JSON\"><a href=\"#什么是JSON\" class=\"headerlink\" title=\"什么是JSON\"></a>什么是JSON</h1><hr>\n<p>　　JSON（JavaScript Object Notation）指的是 JavaScript 对象表示法，是一种轻量级的数据交换格式。它的优点是易于人的阅读和编写，同时也易于及其解析和生成。它是JavaScript语法的一个子集。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。  </p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;phone&quot; : &quot;123-456&quot; &#125;</span><br></pre></td></tr></table></figure>\n<p>　　以上便是一个最简单的JSON的实例。  </p>\n<h1 id=\"JSON的语法规则\"><a href=\"#JSON的语法规则\" class=\"headerlink\" title=\"JSON的语法规则\"></a>JSON的语法规则</h1><p>　　JSON的语法规范如下：<br>　　- 数据在名称/值对中<br>　　- 数据由逗号分隔<br>　　- 大括号保存对象<br>　　- 中括号保存数组<br>　　可能概念看起来不太直观，我们通过几个例子来说明一下。</p>\n<h2 id=\"JSON-名称-值对\"><a href=\"#JSON-名称-值对\" class=\"headerlink\" title=\"JSON 名称/值对\"></a>JSON 名称/值对</h2><p>　　JSON 数据的书写格式是：名称/值对。<br>　　名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值，我们还是以上面的例子作分析：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;　&quot;phone&quot; : &quot;123-456&quot;　&#125;</span><br></pre></td></tr></table></figure>\n<p>　　这等价于这条 JavaScript 语句：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">phone &#x3D; &quot;123-456&quot;</span><br></pre></td></tr></table></figure>\n<p>　　例子中包含了一个JSON对象，以大括号作为边界。其中包含了数据的名称<code>&quot;phone&quot;</code>，和数据的值<code>&quot;123-456&quot;</code>。 这两个元素构成了JSON中常见的数据格式——名称 / 值对。 </p>\n<h2 id=\"JSON-值\"><a href=\"#JSON-值\" class=\"headerlink\" title=\"JSON 值\"></a>JSON 值</h2><p>　　JSON 值可以是：<br>　　－ 数字（整数或浮点数）<br>　　- 字符串（在双引号中）<br>　　- 逻辑值（ <code>true</code>  或 <code>false</code> ）<br>　　- 数组（在中括号中）<br>　　- 对象（在大括号中）<br>　　-  <code>null</code><br>　　JSON 数字可以是整型或者浮点型：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;age&quot; : 20 &#125;</span><br></pre></td></tr></table></figure>\n<p>　　JSON 布尔值可以是 <code>true</code> 或者 <code>false</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;handsome&quot; : true &#125;</span><br></pre></td></tr></table></figure>\n<p>　　JSON 可以设置 <code>null</code> 值：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;name&quot; : null &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JSON-对象\"><a href=\"#JSON-对象\" class=\"headerlink\" title=\"JSON 对象\"></a>JSON 对象</h2><p>　　JSON 对象在大括号（{}）中书写：<br>　　对象可以包含多个名称/值对，对象之间用逗号隔开：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;name&quot; : &quot;hjs&quot; , &quot;age&quot; : 20 &#125;</span><br></pre></td></tr></table></figure>\n<p>　　这句等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name &#x3D; &quot;hjs&quot;;</span><br><span class=\"line\">age &#x3D; 20;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JSON-数组\"><a href=\"#JSON-数组\" class=\"headerlink\" title=\"JSON 数组\"></a>JSON 数组</h2><p>　　JSON 数组在中括号中书写。<br>　　数组可包含多个对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;name&quot; :　&quot;hjs&quot;,</span><br><span class=\"line\">\t&quot;phone&quot; : </span><br><span class=\"line\">\t[</span><br><span class=\"line\">\t\t&#123;&quot;cellphone1&quot; : &quot;123-456&quot;&#125;\t</span><br><span class=\"line\">\t\t&#123;&quot;cellphone2&quot; : &quot;789-000&quot;&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　例子中有两个名称/值对，第一个对象<code>name</code>的值是 <code>hjs</code> ，第二个对象 <code>phone</code> 的值是一个包含两个对象的数组。数组中的每个对象都代表一个电话（ <code>cellphone</code> ）。  </p>\n<h2 id=\"JSON-文件\"><a href=\"#JSON-文件\" class=\"headerlink\" title=\"JSON 文件\"></a>JSON 文件</h2><p>　　JSON 文件的文件类型是 “.json”<br>　　JSON 文本的 MIME 类型是 “application/json”  </p>\n<h1 id=\"JSON-与XML-异同点\"><a href=\"#JSON-与XML-异同点\" class=\"headerlink\" title=\"JSON 与XML 异同点\"></a>JSON 与XML 异同点</h1><h2 id=\"相同之处\"><a href=\"#相同之处\" class=\"headerlink\" title=\"相同之处\"></a>相同之处</h2><p>　　- JSON 是纯文本<br>　　- JSON 具有”自我描述性”（人类可读）<br>　　- JSON 具有层级结构（值中存在值）<br>　　- JSON 可通过 JavaScript 进行解析<br>　　- JSON 数据可使用 AJAX 进行传输  </p>\n<h2 id=\"不同之处\"><a href=\"#不同之处\" class=\"headerlink\" title=\"不同之处\"></a>不同之处</h2><p>　　- 没有结束标签<br>　　- 更短<br>　　- 读写的速度更快<br>　　- 能够使用内建的 JavaScript eval() 方法进行解析<br>　　- 使用数组<br>　　- 不使用保留字  \n　　</p>\n<h1 id=\"为什么使用-JSON？\"><a href=\"#为什么使用-JSON？\" class=\"headerlink\" title=\"为什么使用 JSON？\"></a>为什么使用 JSON？</h1><p>　　对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：</p>\n<h2 id=\"使用-XML\"><a href=\"#使用-XML\" class=\"headerlink\" title=\"使用 XML\"></a>使用 XML</h2><p>　　- 读取 XML 文档<br>　　- 使用 XML DOM 来循环遍历文档<br>　　- 读取值并存储在变量中  </p>\n<h2 id=\"使用-JSON\"><a href=\"#使用-JSON\" class=\"headerlink\" title=\"使用 JSON\"></a>使用 JSON</h2><p>　　- 读取 JSON 字符串<br>　　- 用 eval() 处理 JSON 字符串  </p>\n<hr />\n之后我们会学习如何用JavaScript读取JSON中的内容。\n\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/06/06/JSON%E5%AD%A6%E4%B9%A01-%E4%BB%80%E4%B9%88%E6%98%AFJSON/","tags":[{"name":"JSON","slug":"JSON","permalink":"https://stevehuge.gitee.io/blog/tags/JSON/"}]},{"title":"聊赖一记","date":"2017-05-05T13:22:07.000Z","path":"2017/05/05/聊赖一记/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E9%9A%8F%E7%AC%94/%E6%A1%83%E8%8A%B1.jpg?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>　这两天可以说是百无聊赖了。</p>\n<p>　　自从5.1放假之后，状态就不是很好。做完一个和手头项目不相关的实验，仿佛用掉了大部分的力气。现在便是和以前有段时间一样——脑袋昏沉不已，仿若脑中被抽成了真空，没有一丝的声音，也没有一丝的光线。而这种状态，经常如同春末夏初的风和雨，说来便来，说走就走。而我，对此无可奈何，任何尝试性的努力，看再多的鸡汤文也无济于事。只能等啊、等啊，等到这股无形的劲儿过去了，一切便风轻云淡，一如从前了。<br>　　风还在刮，这八楼的风一如从前，每到换季的日子，这些从西伯利亚吹来的冷空气，便又开始喋喋不休地在窗外回旋。而楼下刚开的丁香花，在这一轮又一轮的风中，瑟缩颤抖，直到被吹落到地上，再被风给卷起，不知飘到何处去了。寥落，便是这些花中一大部分成员的一生。春风来了，她们便也跟着来了，季风来了，她们也就跟着这风，这雨，一起飘到城市的另一端去了。<br>　　还记得前两天这些花刚绽放时，都是一簇簇，一团团地开，极美却又绝不妖艳。那花儿，缩成一小团却每团却又通透的紧，如同一个个刚出锅的糯米团，给人一种软软的很轻柔的亲切，又如同一颗颗月中时分的小月亮，透着明亮、干净，而又馨香馥郁。<br>　　来这科学园的人不少，大多数都是附近的白领，周末带着孩子来游玩。往往是一家三口，拍照的、小孩子玩轮滑的，一番和谐气象。在这些花、这些树的下面，便都是快乐的声音，这声音往往极富感染力，让你不由自主的亲近，不，应该是沉浸，沉浸在快乐和和谐交织的情境中，总能回忆起家的温馨、家的舒适自如。而过后的，便是怅然若失。<br>　　平日里总是一个人，幽寂得活着，不跟身边的人交流，而自己也在日复一日的沉默寡言和患得患失中，沉沦了。读书是个很好的消解寂寞的方式，但沉沦的人往往静不下心来，尝试这古老却又流行的法子。沉沦的人会出去闲逛，在春日的俯视下，在心中有无限沟壑却因不知如何表达的情况下，面沉如水。去逛逛吧，这是他对自己说的话。他也是这么做的，提着自己的身体，仰望园中各类的古树名木，静静地走一圈，又走一圈。身体累了，他便在园中随意找个地方，席地而坐，休息一会儿，但想来却也说不出什么名堂来。<br>…</p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/05/%E8%81%8A%E8%B5%96%E4%B8%80%E8%AE%B0/","tags":[{"name":"随笔","slug":"随笔","permalink":"https://stevehuge.gitee.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"我的git使用教程2","date":"2017-05-04T15:00:48.000Z","path":"2017/05/04/我的git使用教程2/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/Git.jpg?raw=true\" alt=\"Git\"></p>\n<h1 id=\"为仓库创建一个分支（branch）\"><a href=\"#为仓库创建一个分支（branch）\" class=\"headerlink\" title=\"为仓库创建一个分支（branch）\"></a>为仓库创建一个分支（branch）</h1><p>现在我们有个提交过几次的git仓库，如果我们想在给我们的项目加点测试的东西，而又不想留一份原始不被影响的代码。传统的做法是复制项目，创建一个副本项目，在副本项目中进行测试，这样原来的项目不会受到影响。<br>这样看似不错，但是万一我们觉得测试代码不错，想要把它放进原始项目中，我们又不得不把测试代码复制到原始项目中（测试副本要不断进行新的开发），多来几次，万一其中有次出现了错误而没有发现，那修改就很麻烦了。<br>不过不用担心，git提供了另一个很有用的功能——分支(branch)。使用它能多层次、用户进行开发，十分便于管理且提升了效率。版本控制软件的好处就是你可以回到任何一个之前的开发版本中，而分支功能能很好在不影响稳定代码的情况下，允许我们进行更多操作，快来学习一下吧。分支的建立详细参见<a href=\"https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6\" target=\"_blank\" rel=\"noopener\" title=\"Git分支 - 分支的新建与合并\">Git分支 - 分支的新建与合并</a>。</p>\n<a id=\"more\"></a>\n<p>1.在git bash中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b develop\t&#x2F;&#x2F;创建并切换到develop</span><br></pre></td></tr></table></figure>\n<p> 这句话等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch develop\t&#x2F;&#x2F;创建develop分支</span><br><span class=\"line\">git checkout develop\t&#x2F;&#x2F;切换到develop分支</span><br></pre></td></tr></table></figure>\n<p>我们现在处于develop分支中，与原来的master分支相对应，develop就是一个git分支，我们可以在develop分支中对代码进行各种修改，添加，删除操作，提交后（这个不能忘记），这些操作只会修改develop分支中的内容，而对主分支master不会造成任何影响。如果修改出现了问题，想要回到之前的master分支，只需要输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master\t&#x2F;&#x2F;回到master主分支</span><br></pre></td></tr></table></figure>\n<p> 就可回到主分支了。<br>2.如果在develop中开发了一段时间中，觉得代码已经稳定了，想要将develop分支合并到主分支去,那么git也提供合并操作。具体做法是：切换到主分支（不要忘记）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master\t&#x2F;&#x2F;回到master主分支</span><br></pre></td></tr></table></figure>\n<p> 合并分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge develop\t&#x2F;&#x2F;合并master和develop</span><br></pre></td></tr></table></figure>\n<p> 这样master分支和develop分支就合并到一起了，之前在develop分支开发的版本仍然存在，但是如果觉得develop版本已经没用了，以后不会再用到它，那么可以使用删除操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d develop\t&#x2F;&#x2F;删除develop分支</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"为项目添加-gitignore文件\"><a href=\"#为项目添加-gitignore文件\" class=\"headerlink\" title=\"为项目添加.gitignore文件\"></a>为项目添加.gitignore文件</h1><p>虽然上面的方法能帮助我们成功的将项目托管到GitHub上，但是总会遇到一些不完全如我们愿的事情。  </p>\n<center>![生成.gitigore文件之前](https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/gitignore之前.jpg?raw=true)</center>\n如图所示，我们把一个在eclipse上完成的项目上传到GitHub上。但是发现项目中的一些不想或者不必要上传的文件或文件夹也被上传了，例如其中的bin文件夹是存放由.java文件编译成的.class文件的地方，.class文件是虚拟机执行的文件，所以这是一个不必要上传的文件夹。事实上，如图中的bin文件夹、.setting文件夹、.classpath文件和.project文件都是不必要上传的。  \n怎么样能不上传这些文件和文件夹呢？一个不错的答案是每次使用`git add` 的时候手动添加文件盒文件夹，把这些文件不添加就行了。这可能在文件比较少的时候可行，如果遇到一个较大的项目，动辄几百个文件，手动添加就太耗费精力了，而且也没有必要。  \n其实Git已经给我们提供成熟的工具——`.gitignore` 文件，只要在`.gitignore` 文件中添加忽略路径就能达到有选择性的上传文件了，一起来学习一下。  \n在项目文件夹下打开git bash，输入：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch .gitignore    &#x2F;&#x2F;生成.gitigore文件</span><br></pre></td></tr></table></figure>\n之后.gitignore文件就由Git自动生成了，打开`.gitignore` 文件，我以上面图中的项目为例，在里面添加如下字段：\n\n<blockquote>\n<p>bin/<br>.settings<br>.classpath<br>.project  </p>\n</blockquote>\n<p>这样上面提到的文件和文件夹都可以被过滤掉了。之后继续输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached .&#x2F;&#x2F;清空缓存      </span><br><span class=\"line\">git add .&#x2F;&#x2F;重新提交     </span><br><span class=\"line\">git commit -m &quot;update .gitignore&quot;       </span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：  </p>\n<center>![生成.gitigore文件之后](https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/gitignore之后.jpg?raw=true)  </center>\n![具体过滤规则](https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/gitignore%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99.jpg?raw=true)\n\n<h1 id=\"撤销未提交的修改\"><a href=\"#撤销未提交的修改\" class=\"headerlink\" title=\"撤销未提交的修改\"></a>撤销未提交的修改</h1><p>例如对<code>README.md</code>文件进行了修改，之后发现提交不必要，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- README.md</span><br></pre></td></tr></table></figure>\n<p>则能取消修改，回到之前文件未修改的状态。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>[1] <a href=\"https://zhidao.baidu.com/question/2053485325521871027.html\" target=\"_blank\" rel=\"noopener\">如何创建.gitignore文件，忽略不必要提交的文件</a><br>[2] <a href=\"http://blog.csdn.net/qq_32388047/article/details/67724085\" target=\"_blank\" rel=\"noopener\">git更新.gitignore后如何提交</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/04/%E6%88%91%E7%9A%84git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B2/","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"git","slug":"git","permalink":"https://stevehuge.gitee.io/blog/tags/git/"}]},{"title":"我的git使用教程1","date":"2017-05-03T15:00:48.000Z","path":"2017/05/03/我的git使用教程1/","content":"<p><img src=\"https://github.com/StephenHuge/Markdown_Pic/blob/master/%E6%88%91%E7%9A%84Git%E6%95%99%E7%A8%8B/Git.jpg?raw=true\" alt=\"Git\"></p>\n<h1 id=\"将一个项目放到GitHub上\"><a href=\"#将一个项目放到GitHub上\" class=\"headerlink\" title=\"将一个项目放到GitHub上\"></a>将一个项目放到GitHub上</h1><hr>\n<p>Git是一个分布式的代码托管仓库，是每个程序员必备的工具。  </p>\n<a id=\"more\"></a>\n<p>前提：</p>\n<ul>\n<li>有一个GitHub账号</li>\n<li>本地已经安装Git</li>\n<li>github账号已经绑定本地ssh值</li>\n</ul>\n<p>这是后面步骤的基础，如果没有请参考此教程 <a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000\" target=\"_blank\" rel=\"noopener\" title=\"安装Git\">安装Git</a>，<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013752340242354807e192f02a44359908df8a5643103a000\" target=\"_blank\" rel=\"noopener\" title=\"Git添加远程仓库\">Git添加远程仓库</a>。</p>\n<p>步骤如下:<br>1.在github上新建一个repository,例如为“swordOffer”，带README.md文件；<br>2.在本地新建文件夹swordOffer，本地的swordOffer已存在的忽略这一步；<br>3.进入swordOffer；<br>4.在swordOffer文件夹内右键打开git bash；<br>5.现在我们github和本地都有文件夹swordOffer，不同的是github上文件夹内有README.md文件，而本地文件夹为空（或者有文件）；<br>6.在本地打开的git bash中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p> 进行初始化本地git仓库，本地swordOffer文件夹内会出现一个隐藏的.git文件夹。这个文件夹是本地的仓库，动了会破坏本地仓库，所以不要动它；<br>7.之后我们要做的是将本地和远程联系起来：在远程仓库中找到其地址，例如我的是：<br><a href=\"https://github.com/StephenHuge/swordOffer.git\" target=\"_blank\" rel=\"noopener\">https://github.com/StephenHuge/swordOffer.git</a> 。在git bash中输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;StephenHuge&#x2F;swordOffer.git</span><br></pre></td></tr></table></figure>\n<p> 之后没有什么报错的话就是成功了，现在本地仓库和远程仓库绑到一起了；<br>8.由于远程仓库中相比本地仓库还有一个README.md文件，所以我们必须先将这个文件同步到本地，之后才能在本地进行添加上传动作。git bash中输入：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>\n<p> pull是拉的意思，这个命令将README文件“拉”到本地来。此时本地会出现一个README文件。<br>9.之后我们就可以在本地添加代码了，写好之后，输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .\t&#x2F;&#x2F;添加修改</span><br></pre></td></tr></table></figure>\n<p>进行添加修改，其中的<code>.</code>表示添加所有已编辑文件，然后输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;**&quot;\t\t&#x2F;&#x2F;提交修改，**为本次修改的大概描述</span><br></pre></td></tr></table></figure>\n<p>进行提交，可以使用  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status\t\t&#x2F;&#x2F;查看Git状态</span><br></pre></td></tr></table></figure>\n<p>来查看当前的Git状态，显示更改已经全部提交，之后输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>push是推的意思，将本地代码“推”到远程仓库中。”-u”选项的意思是指定一个默认主机，第一次输入需要使用”-u”，以后可以不加任何参数使用  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>或者  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<p>进行提交。刷新github的页面，就会发现代码已经上传到远程仓库上了；<br>10.一段时间后又有新代码写好，要同步，add和commit按照第9步来，就可以直接推送了。<br>11.在github网页上改动了文件，需要同步到本地，本地应该怎么操作呢？在网页上修改了文件后，保存，然后在本地git bash中输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin</span><br></pre></td></tr></table></figure>\n<p> 就完成了远程修改。  </p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/03/%E6%88%91%E7%9A%84git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B1/","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"git","slug":"git","permalink":"https://stevehuge.gitee.io/blog/tags/git/"}]},{"title":"使用Hexo+github搭建个人博客","date":"2017-05-01T10:11:35.000Z","path":"2017/05/01/使用Hexo-github搭建个人博客/","content":"<h1 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a><strong>环境搭建</strong></h1><p>使用Hexo+github搭建个人博客。  </p>\n<a id=\"more\"></a>\n<p>由于本文只是一个对于搭建博客过程的记录而不是教程，所以仅供参考。想要详细的教程请参考参考文章中的第一篇。<br>需要的具体环境有：<br>Node.js<br>Git<br>GitHub账号<br>Hexo<br>简单介绍一下，Node.js 是一个Javascript运行环境，是一个基于Javascipt，性能十分优秀的前端框架。Git就不说了，是一个分布式的代码托管仓库。程序员必备工具，如果你还不会，赶紧去学，这里有篇很好的教程 <a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Git教程</a> 。<br><br>而GitHub是一个基于Git的线上代码托管仓库，你可以把你的代码上传到网站服务器进行托管。GitHub在这里充当的角色是服务器，通过访问你的线上仓库你就可以使用个人博客了~<br>当然只有这些还不够，之后是Hexo的安装，Hexo是一个开源的静态博客生成器，基于Node.js开发。安装结束后就可以进行博客的写作了。</p>\n<h1 id=\"个人博客的维护\"><a href=\"#个人博客的维护\" class=\"headerlink\" title=\"个人博客的维护\"></a><strong>个人博客的维护</strong></h1><p>这个部分可以分为两个部分：1.主题更换；2.发布文章。</p>\n<h2 id=\"主题更换\"><a href=\"#主题更换\" class=\"headerlink\" title=\"主题更换\"></a><strong>主题更换</strong></h2><p>主题就是基于个人博客的页面布局等具体结构的封装文件。每个不同的主题有不同的页面布置，操作方式等。<br>我用的主题是<a href=\"https://github.com/giscafer/hexo-theme-cafe\" target=\"_blank\" rel=\"noopener\">cafe</a>，将其下载下来放到Hexo安装目录下themes文件夹中，例如我的Hexo安装位置是G:\\Blog，cafe的位置是G:\\Blog\\themes\\cafe。<br>在Hexo中有两份配置文件，名称均为 _config.yml，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的各类选项。下面举例说明一下：<br>在G:\\Blog下的 _config.yml是整个<b>网站的配置文件</b>，而在G:\\Blog\\themes\\cafe\\下还有一个 _config.y文件，这个文件是cafe<b>主题的配置文件</b>。<br><b>主题配置文件</b>由主题作者提供，如何进行配置，主题作者都会在README中详细说明，例如主题cafe的 <a href=\"https://github.com/giscafer/hexo-theme-cafe/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">cafe的README文件</a>，故在此不再详述。<br>而<b>网站配置文件</b>是通用的。其中一般包括网站名称、作者（你的名字）、语言、友情链接等设置。其中重要的是两个：theme和repo（线上仓库的位置）。例如我的是：<br><img src=\"http://img.blog.csdn.net/20170501164908990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9tb255MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Hexo配置\"><br>其中theme是cafe，这样我就可以用cafe主题了。而deploy中type为git，repo为我自己在github中的io仓库。这样主题设置完成了。具体设置参见参考文章的第一个连接，其中有详细说明。</p>\n<h2 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a><strong>发布文章</strong></h2><p>新建一篇博客：<br>打开cmd（我用的是Windows，Linux用户直接Ctrl+Shift+T打开terminal），进入到Hexo的安装目录下，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>article title </code>是你的文章题目。这时候在安装目录下的source_posts文件夹下将看到  article title.md  文件，用MarkDown编辑器（我用的是MarkdownPad 2）打开就可以编辑文章了。文章编辑好之后保存，可以先预览一下我们写好的文章。运行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g\t&#x2F;&#x2F;部署文章</span><br><span class=\"line\">hexo server -p 4000\t&#x2F;&#x2F;打开本地server</span><br></pre></td></tr></table></figure>\n<p>第二句执行完效果如图  </p>\n<center>![hexoServer](https://github.com/StephenHuge/Markdown_Pic/blob/master/我的Git教程/hexoServer.jpg?raw=true)</center>\n\n<p>第二句的操作的作用是打开本地的server。其中-p为设置端口（port）操作，数字4000为默认端口，如果端口4000被占用也可以用别的数字。<br>之后通过访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\" title=\"http://localhost:4000\">http://localhost:4000</a> 即可预览我们部署好的文章。如果有排版或内容问题则继续修改，在本地修改好之后，执行 <code>hexo g</code> 重新部署。确认无误后，在远程生成文章</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d\t&#x2F;&#x2F;生成</span><br></pre></td></tr></table></figure>\n<p>部署成功后访问你的远程地址，例如我的是<a href=\"https://stephenhuge.github.io/\" target=\"_blank\" rel=\"noopener\">https://stephenhuge.github.io/</a>，打开就可以看到生成的文章了。<br>当然如果不需要在本地预览时，文章写好之后可以直接在git bash执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d -g &#x2F;&#x2F;在部署前生成</span><br></pre></td></tr></table></figure>\n\n<p>这句等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g\t&#x2F;&#x2F;部署\t</span><br><span class=\"line\">hexo d\t&#x2F;&#x2F;生成</span><br></pre></td></tr></table></figure>\n<p>之后访问远程地址也能看到生成好的文章。<br>ps:如果提示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deployer not found:git</span><br></pre></td></tr></table></figure>\n\n<p>则是没有安装扩展，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>即可。</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a><strong>参考文章</strong></h1><p>[1] 安装教程  <a href=\"http://blog.csdn.net/gdutxiaoxu/article/details/53576018\" target=\"_blank\" rel=\"noopener\">手把手教你用Hexo+Github 搭建属于自己的博客</a></p>\n<p>[2] 主题配置 <a href=\"http://www.zipperary.com/2013/05/29/hexo-guide-3/\" target=\"_blank\" rel=\"noopener\">hexo系列教程：（三）hexo博客的配置、使用</a></p>\n<p>[3] 遇到各种问题  <a href=\"https://segmentfault.com/q/1010000003870970\" target=\"_blank\" rel=\"noopener\">使用localhost:4000访问本地blog一直无响应</a></p>\n<p>[4] 遇到各种问题  <a href=\"http://bbs.csdn.net/topics/390538669\" target=\"_blank\" rel=\"noopener\">网站处于联机状态,但未对连接尝试做出响应</a></p>\n<p><strong>扩展阅读</strong></p>\n<p><a href=\"http://baixin.io/2016/10/jekyll_tutorials1/\" target=\"_blank\" rel=\"noopener\">Jekyll搭建个人博客</a></p>\n","link":"","permalink":"https://stevehuge.gitee.io/blog/2017/05/01/%E4%BD%BF%E7%94%A8Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://stevehuge.gitee.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"hexo","permalink":"https://stevehuge.gitee.io/blog/tags/hexo/"}]}]